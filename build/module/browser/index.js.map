{"version":3,"file":"index.js","sources":["../../../source/arrays/chunk.js","../../../source/arrays/clear.js","../../../source/arrays/clone.js","../../../source/types/isUndefined.js","../../../source/utilities/hasLength.js","../../../source/types/isNull.js","../../../source/types/hasValue.js","../../../source/utilities/returnValue.js","../../../source/arrays/each.js","../../../source/arrays/compactMap.js","../../../source/arrays/eachAsync.js","../../../source/arrays/compactMapAsync.js","../../../source/numbers/isNegative.js","../../../source/arrays/range.js","../../../source/utilities/forEach.js","../../../source/types/isArray.js","../../../source/arrays/ensure.js","../../../source/arrays/flattenDeep.js","../../../source/classes/construct.js","../../../source/arrays/difference.js","../../../source/arrays/drop.js","../../../source/arrays/dropRight.js","../../../source/arrays/eachRight.js","../../../source/arrays/eachRightAsync.js","../../../source/arrays/every.js","../../../source/arrays/everyAsync.js","../../../source/arrays/filter.js","../../../source/arrays/filterAsync.js","../../../source/arrays/first.js","../../../source/arrays/flatten.js","../../../source/arrays/initial.js","../../../source/arrays/intersect.js","../../../source/objects/keys.js","../../../source/utilities/toPath.js","../../../source/utilities/get.js","../../../source/objects/hasKeys.js","../../../source/types/isPlainObject.js","../../../source/types/isConstructor.js","../../../source/types/isTypeFactory.js","../../../source/types/isBuffer.js","../../../source/utilities/isEqual.js","../../../source/arrays/isMatch.js","../../../source/arrays/largest.js","../../../source/arrays/last.js","../../../source/arrays/map.js","../../../source/arrays/mapAsync.js","../../../source/arrays/mapRight.js","../../../source/arrays/mapWhile.js","../../../source/math/subtract.js","../../../source/arrays/sortNumberAscending.js","../../../source/arrays/object.js","../../../source/arrays/partition.js","../../../source/math/subtractReverse.js","../../../source/arrays/sortNumberDescening.js","../../../source/arrays/remove.js","../../../source/arrays/rest.js","../../../source/arrays/right.js","../../../source/math/randomInt.js","../../../source/internal/array.js","../../../source/numbers/isNumberEqual.js","../../../source/arrays/shuffle.js","../../../source/arrays/sample.js","../../../source/arrays/smallest.js","../../../source/arrays/getNumberInsertIndex.js","../../../source/arrays/take.js","../../../source/arrays/takeRight.js","../../../source/arrays/unique.js","../../../source/arrays/union.js","../../../source/arrays/untilFalse.js","../../../source/arrays/untilTrue.js","../../../source/arrays/whileCompactMap.js","../../../source/arrays/whileEach.js","../../../source/arrays/whileMap.js","../../../source/arrays/without.js","../../../source/arrays/xor.js","../../../source/arrays/zip.js","../../../source/buffers/ensure.js","../../../source/buffers/clear.js","../../../source/collection/countBy.js","../../../source/collection/countKey.js","../../../source/collection/countWithoutKey.js","../../../source/collection/findIndexCache.js","../../../source/collection/findIndex.js","../../../source/collection/findItem.js","../../../source/collection/sortCollectionDescending.js","../../../source/collection/sortCollectionAlphabetically.js","../../../source/collection/sortCollectionAscending.js","../../../source/collection/getHighest.js","../../../source/collection/getLowest.js","../../../source/collection/groupBy.js","../../../source/collection/indexBy.js","../../../source/collection/invoke.js","../../../source/collection/invokeAsync.js","../../../source/types/isString.js","../../../source/objects/pluckObject.js","../../../source/collection/pluck.js","../../../source/collection/sortCollectionAlphabeticallyReverse.js","../../../source/files/getExtension.js","../../../source/files/getFilename.js","../../../source/internal/regexTestFactory.js","../../../source/files/isFileCSS.js","../../../source/files/isFileHTML.js","../../../source/files/isFileJS.js","../../../source/files/isFileJSON.js","../../../source/functions/after.js","../../../source/functions/ary.js","../../../source/functions/before.js","../../../source/objects/assign.js","../../../source/objects/eachAsync.js","../../../source/objects/each.js","../../../source/utilities/forEachAsync.js","../../../source/types/isSet.js","../../../source/utilities/forOf.js","../../../source/types/isGenerator.js","../../../source/utilities/forOfAsync.js","../../../source/types/isFunction.js","../../../source/types/isAsync.js","../../../source/utilities/generateLoop.js","../../../source/utilities/each.js","../../../source/functions/chain.js","../../../source/functions/curry.js","../../../source/functions/curryRight.js","../../../source/utilities/stubTrue.js","../../../source/utilities/stubFalse.js","../../../source/utilities/noop.js","../../../source/utilities/times.js","../../../source/utilities/timer.js","../../../source/internal/apply.js","../../../source/functions/debounce.js","../../../source/functions/ifInvoke.js","../../../source/functions/inAsync.js","../../../source/functions/inSync.js","../../../source/functions/negate.js","../../../source/functions/nthArg.js","../../../source/functions/once.js","../../../source/objects/mapAsync.js","../../../source/objects/map.js","../../../source/types/getType.js","../../../source/types/cloneType.js","../../../source/utilities/forOfMap.js","../../../source/utilities/forOfMapAsync.js","../../../source/utilities/map.js","../../../source/functions/over.js","../../../source/objects/everyAsync.js","../../../source/objects/every.js","../../../source/utilities/forOfEvery.js","../../../source/utilities/forOfEveryAsync.js","../../../source/utilities/every.js","../../../source/functions/overEvery.js","../../../source/functions/rearged.js","../../../source/functions/throttle.js","../../../source/functions/wrap.js","../../../source/internal/isSame.js","../../../source/utilities/cacheNativeMethod.js","../../../source/internal/object.js","../../../source/math/add.js","../../../source/math/deduct.js","../../../source/math/divide.js","../../../source/math/increment.js","../../../source/math/multiple.js","../../../source/math/progress.js","../../../source/math/randomFloat.js","../../../source/math/remainder.js","../../../source/math/subtractAll.js","../../../source/math/sumAll.js","../../../source/numbers/isNumberInRange.js","../../../source/numbers/isNumberNotInRange.js","../../../source/numbers/isPositive.js","../../../source/numbers/isZero.js","../../../source/objects/compactKeys.js","../../../source/objects/compactMapAsync.js","../../../source/objects/compactMap.js","../../../source/objects/filter.js","../../../source/objects/filterAsync.js","../../../source/objects/invert.js","../../../source/objects/isMatch.js","../../../source/types/isNumber.js","../../../source/types/isRegex.js","../../../source/regexps/escapeRegex.js","../../../source/regexps/arrayToRegex.js","../../../source/objects/omit.js","../../../source/objects/pick.js","../../../source/objects/size.js","../../../source/objects/zip.js","../../../source/strings/camelCase.js","../../../source/strings/kebabCase.js","../../../source/strings/snakeCase.js","../../../source/strings/upperCase.js","../../../source/strings/lowerCase.js","../../../source/strings/range.js","../../../source/strings/replace.js","../../../source/strings/sanitize.js","../../../source/strings/tokenize.js","../../../source/strings/truncate.js","../../../source/strings/typography.js","../../../source/types/getTypeName.js","../../../source/types/isArguments.js","../../../source/types/noValue.js","../../../source/types/isMap.js","../../../source/types/isTypedArray.js","../../../source/types/isArrayLike.js","../../../source/types/isBigInt.js","../../../source/types/isBoolean.js","../../../source/types/isArrayBuffer.js","../../../source/types/isChild.js","../../../source/types/isCloneable.js","../../../source/types/isDate.js","../../../source/types/isEmpty.js","../../../source/types/isFalse.js","../../../source/types/isF32.js","../../../source/types/isF64.js","../../../source/types/isFloat.js","../../../source/types/isI16.js","../../../source/types/isI32.js","../../../source/types/isI8.js","../../../source/types/isIterable.js","../../../source/types/isPromise.js","../../../source/types/isKindAsync.js","../../../source/types/isParent.js","../../../source/types/isPrimitive.js","../../../source/types/isRelated.js","../../../source/types/isSafeInt.js","../../../source/types/isSameType.js","../../../source/types/isTrue.js","../../../source/types/isU16.js","../../../source/types/isU32.js","../../../source/types/isU8.js","../../../source/types/isU8C.js","../../../source/types/isWeakMap.js","../../../source/types/isDeno.js","../../../source/types/isNode.js","../../../source/types/isTruthy.js","../../../source/types/isFalsy.js","../../../source/utilities/ifValue.js","../../../source/utilities/notEqual.js","../../../source/utilities/json.js","../../../source/utilities/assert.js","../../../source/utilities/bindAll.js","../../../source/utilities/clear.js","../../../source/utilities/clone.js","../../../source/utilities/compact.js","../../../source/utilities/forOfCompactMapAsync.js","../../../source/utilities/forOfCompactMap.js","../../../source/utilities/compactMap.js","../../../source/utilities/everyArg.js","../../../source/utilities/forOfFilter.js","../../../source/utilities/forOfFilterAsync.js","../../../source/utilities/filter.js","../../../source/utilities/flow.js","../../../source/utilities/flowAsync.js","../../../source/utilities/forMap.js","../../../source/utilities/has.js","../../../source/utilities/hasDot.js","../../../source/utilities/ifNotAssign.js","../../../source/utilities/interval.js","../../../source/utilities/merge.js","../../../source/utilities/model.js","../../../source/utilities/pair.js","../../../source/utilities/concurrent.js","../../../source/utilities/concurrentStatus.js","../../../source/utilities/promise.js","../../../source/utilities/propertyMatch.js","../../../source/utilities/setKey.js","../../../source/utilities/setValue.js","../../../source/utilities/store.js","../../../source/utilities/stubArray.js","../../../source/utilities/stubObject.js","../../../source/utilities/stubString.js","../../../source/utilities/timesAsync.js","../../../source/utilities/toggle.js","../../../source/utilities/uid.js","../../../source/utilities/virtualStorage.js","../../../source/browser/agent.js","../../../source/browser/event.js","../../../source/browser/isEnter.js","../../../source/browser/frag.js","../../../source/browser/append.js","../../../source/browser/attribute.js","../../../source/browser/selector.js","../../../source/browser/importScript.js","../../../source/browser/ready.js","../../../source/browser/info.js","../../../source/browser/dimensions.js","../../../source/browser/storage.js","../../../source/browser/console.js","../../../source/browser/is.js"],"sourcesContent":["/**\n * Chunks an array according to a user defined number.\n *\n * @function chunk\n * @category Array\n * @type {Function}\n * @param {Array} array - Array to be chunked.\n * @param {Number} size - Number which determines the size of each chunk.\n * @returns {Array} - A chunked version of the source array.\n *\n * @example\n * import { chunk, assert } from '@universalweb/acid';\n * assert(chunk([1,2,3], 1), [[1],[2],[3]]);\n */\nexport function chunk(array, size = 1) {\n\tconst chunked = [];\n\tlet index = 0;\n\tarray.forEach((item, key) => {\n\t\tif (!(key % size)) {\n\t\t\tchunked.push([]);\n\t\t\tif (key) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tchunked[index].push(item);\n\t});\n\treturn chunked;\n}\n","/**\n * Clears the values out of an array.\n *\n * @function clearArray\n * @category Array\n * @type {Function}\n * @param {Array} source - Takes an array to be emptied.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { clearArray, assert } from '@universalweb/acid';\n * assert(clearArray([1,'B', 'Cat']), []);\n */\nexport function clearArray(source) {\n\tsource.length = 0;\n\treturn source;\n}\n\n","/**\n * Clone an array (uses .slice()) and assign the source arrays values to the new array.\n *\n * @function cloneArray\n * @category Array\n * @type {Function}\n * @param {Array} source - The array to be quick cloned.\n * @returns {Array} - The newly cloned array with assigned items.\n *\n * @example\n * import { cloneArray, assert } from '@universalweb/acid';\n * assert(cloneArray([1,'B', 'Cat']), [1, 'B', 'Cat']);\n */\nexport function cloneArray(source) {\n\treturn source.slice();\n}\n\n","/** Checks if the value is undefined.\n *\n * @function isUndefined\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isUndefined, assert } from '@universalweb/acid';\n * assert(isUndefined(undefined), true);\n */\nexport function isUndefined(source) {\n\treturn source === undefined;\n}\n","import { isUndefined } from '../types/isUndefined.js';\n/**\n * Checks if the value has length greater than 0.\n *\n * @function hasLength\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { hasLength, assert } from '@universalweb/acid';\n * assert(hasLength([1]), true);\n */\nexport function hasLength(source) {\n\treturn Boolean(source.length);\n}\n","import { hasLength } from '../utilities/hasLength.js';\n/**\n * Checks if the value is null.\n *\n * @function isNull\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNull, assert } from '@universalweb/acid';\n * assert(isNull(null), true);\n */\nexport function isNull(source) {\n\treturn source === null;\n}\n","import { isUndefined } from './isUndefined.js';\nimport { isNull } from './isNull.js';\n/**\n * Checks if the value is not null or undefined.\n *\n * @function hasValue\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { hasValue, assert } from '@universalweb/acid';\n * assert(hasValue(1), true);\n */\nexport function hasValue(source) {\n\treturn !isUndefined(source) && !isNull(source);\n}\n","/**\n * A simple function which returns the value it's given.\n *\n * @function returnValue\n * @category utility\n * @param {*} source - The source object.\n * @returns {source} The source object.\n */\nexport function returnValue(source) {\n\treturn source;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the given array.\n *\n * @function eachArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { eachArray, assert } from '@universalweb/acid';\n * const list = [];\n * eachArray([1, 2, 3], (item, index) => {\n *   list[index] = item;\n * });\n * assert(list, [1, 2, 3]);\n */\nexport function eachArray(source, iteratee, thisBind) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst arrayLength = source.length;\n\tfor (let index = 0;index < arrayLength;index++) {\n\t\titeratee(source[index], index, source, arrayLength, thisBind);\n\t}\n\treturn source;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachArray } from './each.js';\n/**\n * Iterates through the calling array and creates an array with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling array.\n *\n * @function compactMapArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results. Default value is a new empty array.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array with mapped properties that are not null or undefined.\n *\n * @example\n * import { compactMapArray, assert } from '@universalweb/acid';\n * assert(compactMapArray([null, 2, 3], (item) => {\n *   return item;\n * }), [2, 3]);\n */\nexport function compactMapArray(source, iteratee = returnValue, results = [], thisBind) {\n\teachArray(source, (item, index, arrayOriginal, arrayLength) => {\n\t\tconst returned = iteratee(item, index, results, arrayOriginal, arrayLength, thisBind);\n\t\tif (hasValue(returned)) {\n\t\t\tresults.push(returned);\n\t\t}\n\t});\n\treturn results;\n}\n\n","/**\n * Asynchronously Iterates through the given array. Each async function is awaited as to ensure synchronous order.\n *\n * @function eachAsyncArray\n * @category array\n * @type {Function}\n * @async\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @returns {Array} - Returns source the originally given array.\n *\n * @example\n * import { eachAsyncArray, assert } from '@universalweb/acid';\n * const tempList = [];\n * await eachAsyncArray([1, 2, 3], async (item) => {\n *   tempList.push(item);\n * });\n * assert(tempList, [1, 2, 3]);\n */\nexport async function eachAsyncArray(source, iteratee) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tawait iteratee(source[index], index, source, arrayLength);\n\t}\n\treturn source;\n}\n\n","import { eachAsyncArray } from './eachAsync.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { hasValue } from '../types/hasValue.js';\n/**\n * Asynchronously iterates through the calling array and creates an array with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling array.\n *\n * @function compactMapAsyncArray\n * @type {Function}\n * @category array\n * @async\n * @param {Array} source - Array to be compacted.\n * @param {Function} iteratee - Iteratee to be performed on array.\n * @returns {Array} - Array values after being put through an iterator.\n *\n * @example\n * import { compactMapAsync, assert } from '@universalweb/acid';\n * assert(await compactMapAsync([1, 2, 3, null], async (item) => {\n *   return item;\n * }), [1, 2, 3]);\n */\nexport async function compactMapAsyncArray(source, iteratee = returnValue) {\n\tconst results = [];\n\tawait eachAsyncArray(source, async (item, index, arrayLength) => {\n\t\tconst result = await iteratee(item, index, results, arrayLength);\n\t\tif (hasValue(result)) {\n\t\t\tresults.push(result);\n\t\t}\n\t});\n\treturn results;\n}\n\n","/**\n * Checks if a number is negative & returns true or false.\n *\n * @function isNegative\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNegative, assert } from '@universalweb/acid';\n * assert(isNegative(-1), true);\n */\nconst { sign } = Math;\nexport function isNegative(source) {\n\treturn sign(source) === -1;\n}\n","import { isNegative } from '../numbers/isNegative.js';\nexport function rangeUp(start, end, step, sourceArray) {\n\tlet position = start;\n\twhile (position < end) {\n\t\tsourceArray.push(position);\n\t\tposition += step;\n\t}\n\treturn sourceArray;\n}\nexport function rangeDown(start, end, step, sourceArray) {\n\tlet position = start;\n\twhile (position > end) {\n\t\tsourceArray.push(position);\n\t\tposition -= step;\n\t}\n\treturn sourceArray;\n}\n/**\n * Create a numbered list of integers.\n *\n * @function range\n * @category array\n * @type {Function}\n * @param {Number} start - Value which determines the start of the range.\n * @param {Number} end - Value which determines the end of the range.\n * @param {Number} step - Value used to step between integers.\n * @returns {Array} - An array of integers.\n *\n * @example\n * import { range, assert } from '@universalweb/acid';\n * assert(range(0, 30, 5), [0, 5, 10, 15, 20, 25]);\n */\nexport function range(start, end, step = 1, sourceArray = []) {\n\tif (isNegative(step)) {\n\t\treturn sourceArray;\n\t}\n\tif (start < end) {\n\t\treturn rangeUp(start, end, step, sourceArray);\n\t} else {\n\t\treturn rangeDown(start, end, step, sourceArray);\n\t}\n}\n","export function forEach(source, callback) {\n\tsource.forEach(callback);\n\treturn source;\n}\n","/**\n * Checks if the value is an array. This references Array.isArray.\n *\n * @function isArray\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isArray, assert } from '@universalweb/acid';\n * assert(isArray([]), true);\n * assert(isArray(2), false);\n */\nexport const isArray = Array.isArray;\n","import { isArray } from '../types/isArray.js';\nimport { hasValue } from '../types/hasValue.js';\n/**\n * Ensures the source is an array if not the source is wrapped in a array or an empty array is returned.\n *\n * @function ensureArray\n * @category array\n * @type {Function}\n * @param {*} source - Object to be checked.\n * @returns {Array} - Returns an array.\n *\n * @example\n * import { isArray, ensureArray, assert } from '@universalweb/acid';\n * assert(isArray(ensureArray('test')), ['test']);\n */\nexport function ensureArray(source) {\n\treturn (isArray(source) && source) || (hasValue(source) && [source]) || [];\n}\n\n","import { ensureArray } from './ensure.js';\n/**\n * Flattens an array to a single level.\n *\n * @function flattenDeep\n * @type {Function}\n * @category array\n * @param {Array} source - Array to flatten.\n * @returns {Array} - Returns a completely flattened array.\n *\n * @example\n * import { flattenDeep, assert } from '@universalweb/acid';\n * assert(flattenDeep([1, [2, [3, [4]], 5]]), [1, 2, 3, 4, 5]);\n */\nexport function flattenDeep(source) {\n\treturn source.flat(Infinity);\n}\n\n","/**\n * A function which acts like the \"new\" operator and can pass arguments. This is a safe version of the original which will error if given undefined\n * This is useful when working with classes and prefering to avoid the new operator and it's potential side effects.\n *\n * @function construct\n * @category class\n * @param {Function} target - The target function or class.\n * @param {Array} [argumentsList =[]] - An array-like object specifying the arguments with which target should be called. Default value is a new empty array.\n * @param {Array} newTarget - The constructor whose prototype should be used. See also the new.target operator. If newTarget is not present, its value defaults to target.\n * @returns {*} - A new instance of target (or newTarget, if present), initialized by target as a constructor with the given argumentsList.\n *\n * @example\n * import { construct, assert } from '@universalweb/acid';\n * class test {\n * constructor(a) {\n * return 1;\n * }\n * }\n * const newClass = construct(test, [1]);\n * assert(test, 1);\n */\nconst reflectConstruct = Reflect.construct;\nimport { isArray } from '../types/isArray.js';\nexport function construct(target, argumentsList = [], newTarget) {\n\tconst args = (isArray(argumentsList)) ? argumentsList : [argumentsList];\n\tif (newTarget) {\n\t\treturn reflectConstruct(target, args, newTarget);\n\t}\n\treturn reflectConstruct(target, args);\n}\n","import { eachArray } from './each.js';\nimport { forEach } from '../utilities/forEach.js';\nimport { flattenDeep } from './flattenDeep.js';\nimport { construct } from '../classes/construct.js';\n/**\n * Checks for primitive differences between a source array to other arrays, then returns a new array containing those differences.\n *\n * @function difference\n * @category array\n * @type {Function}\n * @param {Array} sources - Source array.\n * @param {...Array} compare - Array(s) source array is compared against.\n * @returns {Array} - An array which contains the differences between the source and compare array.\n *\n * @example\n * import { difference, assert } from '@universalweb/acid';\n * assert(difference([1, 2, 3], [1, 2]), [3]);\n */\nexport function difference(...sources) {\n\tconst differencesMap = construct(Map);\n\tconst differences = [];\n\teachArray(sources, (currentArray, parentIndex) => {\n\t\teachArray(currentArray, (child, childIndex) => {\n\t\t\tlet childRoot = differencesMap.get(child);\n\t\t\tif (!childRoot) {\n\t\t\t\tchildRoot = {\n\t\t\t\t\tcount: 1,\n\t\t\t\t\tparentIndex,\n\t\t\t\t\tchild\n\t\t\t\t};\n\t\t\t\tdifferencesMap.set(child, childRoot);\n\t\t\t} else if (childRoot.parentIndex === parentIndex) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tchildRoot.count++;\n\t\t\t}\n\t\t});\n\t});\n\tforEach(differencesMap, (item) => {\n\t\tif (item.count === 1 && item.parentIndex === 0) {\n\t\t\tdifferences.push(item.child);\n\t\t}\n\t});\n\treturn differences;\n}\n\n","/**\n * Removes all items from an array after a specified index.\n *\n * @function drop\n * @category array\n * @type {Function}\n * @param {Array} array - Source array.\n * @param {Number} amount - Amount of items to drop from the array.\n * @param {Number} [upTo = array.length] - Index to stop at.\n * @returns {Array} - An array with all values removed after a user defined index.\n *\n * @example\n * import { drop, assert } from '@universalweb/acid';\n * assert(drop([1, 2, 3]), [2, 3]);\n * assert(drop([1, 2, 3], 2), [3]);\n */\nexport function drop(array, amount = 1, upTo = array.length) {\n\treturn array.splice(amount, upTo);\n}\n","import { drop } from './drop.js';\n/**\n * Removes all items from an array before a specified index.\n *\n * @function dropRight\n * @type {Function}\n * @category array\n * @param {Array} array - Source array.\n * @param {Number} amount - Amount of items to drop from the array.\n * @param {Number} [upTo = array.length] - Index to stop at.\n * @returns {Array} - An array with all values removed before a user defined index.\n *\n * @example\n * import { dropRight, assert } from '@universalweb/acid';\n * assert(dropRight([1, 2, 3]), [1, 2]);\n * assert(dropRight([1, 2, 3], 2), [1]);\n */\nexport const dropRight = (array, amount = 1, upTo = array.length) => {\n\treturn drop(array, 0, upTo - amount);\n};\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the given array in reverse.\n *\n * @function eachRight\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { eachRight, assert } from '@universalweb/acid';\n * const tempList = [];\n * eachRight([1, 2, 3], (item) => {\n *   tempList.push(item);\n * });\n * assert(tempList, [3, 2, 1]);\n */\nexport function eachRight(source, iteratee, thisBind) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst arrayLength = source.length;\n\tfor (let index = arrayLength - 1;index >= 0;index--) {\n\t\titeratee(source[index], index, source, arrayLength, thisBind);\n\t}\n\treturn source;\n}\n\n","/**\n * Asynchronously Iterates through the given array in reverse. Each async function is awaited as to ensure synchronous order.\n *\n * @function eachRightAsync\n * @category array\n * @type {Function}\n * @async\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @returns {Object} - The originally given array.\n *\n * @example\n * import { eachRightAsync, assert } from '@universalweb/acid';\n * const tempList = [];\n * await eachRightAsync([1, 2, 3], async (item) => {\n *   tempList.push(item);\n * });\n * assert(tempList, [3, 2, 1]);\n */\nexport async function eachRightAsync(source, iteratee) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst arrayLength = source.length;\n\tfor (let index = arrayLength - 1; index >= 0; index--) {\n\t\tawait iteratee(source[index], index, source, arrayLength);\n\t}\n\treturn source;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the given array while the iteratee returns true else the loop exits & returns false.\n *\n * @function everyArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - Returns true if all returns are true or false if one value returns false.\n *\n * @example\n * import { everyArray, assert } from '@universalweb/acid';\n * assert(everyArray([true, true, false], (item, index, source, sourceLength, thisBind) => {\n *   return item;\n * }), false);\n * assert(everyArray([true, true, true], (item, index, source, sourceLength, thisBind) => {\n *   return item;\n * }), true);\n */\nexport function everyArray(source, iteratee, thisBind) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst sourceLength = source.length;\n\tfor (let index = 0;index < sourceLength;index++) {\n\t\tif (iteratee(source[index], index, source, sourceLength, thisBind) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the given array while the iteratee returns true else the loop exits & returns false.\n *\n * @function everyAsyncArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - Returns true if all returns are true or false if one value returns false.\n *\n * @example\n * import { everyAsyncArray, assert } from '@universalweb/acid';\n * assert(everyAsyncArray([true, true, false], (item, index, source, sourceLength, thisBind) => {\n *   return item;\n * }), false);\n * assert(everyAsyncArray([true, true, true], (item, index, source, sourceLength, thisBind) => {\n *   return item;\n * }), true);\n */\nexport async function everyAsyncArray(source, iteratee, thisBind) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst sourceLength = source.length;\n\tfor (let index = 0;index < sourceLength;index++) {\n\t\tif (await iteratee(source[index], index, source, sourceLength, thisBind) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachArray } from './each.js';\n/**\n * Iterates through the calling array and creates an array with all elements that pass the test implemented by the iteratee.\n *\n * @function filterArray\n * @category array\n * @type {Function}\n * @category array\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created object, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array with properties that passed the test.\n *\n * @example\n * import { filterArray, assert } from '@universalweb/acid';\n * assert(filterArray([false, true, true], (item) => {\n *   return item;\n * }), [true, true]);\n */\nexport function filterArray(source, iteratee, results = [], thisBind) {\n\teachArray(source, (item, index, arrayOriginal, arrayLength) => {\n\t\tif (iteratee(item, index, results, arrayOriginal, arrayLength, thisBind) === true) {\n\t\t\tresults.push(item);\n\t\t}\n\t});\n\treturn results;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachAsyncArray } from './eachAsync.js';\n/**\n * Iterates through the calling array and creates an array with all elements that pass the test implemented by the iteratee.\n *\n * @function filterAsyncArray\n * @category array\n * @type {Function}\n * @category array\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created object, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array with properties that passed the test.\n *\n * @example\n * import { filterAsyncArray, assert } from '@universalweb/acid';\n * assert(filterAsyncArray([false, true, true], (item) => {\n *   return item;\n * }), [true, true]);\n */\nexport async function filterAsyncArray(source, iteratee, results = [], thisBind) {\n\tawait eachAsyncArray(source, async (item, index, arrayOriginal, arrayLength) => {\n\t\tif (await iteratee(item, index, results, arrayOriginal, arrayLength, thisBind) === true) {\n\t\t\tresults.push(item);\n\t\t}\n\t});\n\treturn results;\n}\n\n","/**\n * Takes the first or multiple items from an array.\n *\n * @function first\n * @type {Function}\n * @category array\n * @param {Array} array - Array to extract from.\n * @param {Number} upTo - Number which determines how many items after the first item are extracted from the array.\n * @returns {Array} - Returns an array.\n *\n * @example\n * import { first, assert } from '@universalweb/acid';\n * assert(first([1, 2, 3]), 1);\n */\nexport function first(array, upTo) {\n\treturn (upTo) ? array.slice(0, upTo) : array[0];\n}\n\n","import { ensureArray } from './ensure.js';\n/**\n * Flattens an array up to the provided level.\n *\n * @function flatten\n * @type {Function}\n * @category array\n * @param {Array} source - Array to flatten.\n * @param {Number} [level = 1] - Number which determines how deep the array nest can be.\n * @returns {Array} - Returns an array.\n *\n * @example\n * import { flatten, assert } from '@universalweb/acid';\n * assert(flatten([1, [2, [3, [4]], 5]]), [1, 2, [3, [4]], 5]);\n */\nexport function flatten(source, level = 1) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tlet sourceArray = source;\n\tfor (let i = 0; i < level; i++) {\n\t\tsourceArray = sourceArray.reduce((previousValue, currentValue) => {\n\t\t\treturn previousValue.concat(ensureArray(currentValue));\n\t\t}, []);\n\t}\n\treturn sourceArray;\n}\n\n","/**\n * Takes all but the last item in the array.\n *\n * @function initial\n * @category array\n * @type {Function}\n * @param {Array} array - Array to have items extracted from.\n * @returns {Array} - Returns a completely flattened array.\n *\n * @example\n * import { initial, assert } from '@universalweb/acid';\n * assert(initial([1, 2, 3, 4, 5]), [1, 2, 3, 4]);\n */\nexport function initial(array) {\n\treturn array.slice(0, array.length - 1);\n}\n\n","import { compactMapArray } from './compactMap.js';\nimport { everyArray } from './every.js';\n// Add intersectionBy & intersectionWith\n/**\n * Returns an new array that is the [set intersection](http://en.wikipedia.org/wiki/Intersection_(set_theory))\n * of the array and the input array(s).\n *\n * @function intersection\n * @param {Array} array - Array to compare other arrays to.\n * @param {...Array} arrays - A variable number of arrays.\n * @category array\n * @returns {Array} - The new array of unique values shared by all of the arrays.\n *\n * @example\n * import { intersection, assert } from '@universalweb/acid';\n * assert(intersection([1, 2, 3], [2, 3, 4]), [2, 3]);\n */\nexport function intersection(array, ...arrays) {\n\treturn compactMapArray(array, (item) => {\n\t\tconst shouldReturn = everyArray(arrays, (otherItem) => {\n\t\t\treturn otherItem.includes(item);\n\t\t});\n\t\tif (shouldReturn) {\n\t\t\treturn item;\n\t\t}\n\t});\n}\n\n","/**\n * Get object's keys.\n *\n * @function keys\n * @category object\n * @param {*} source - The source object to pull keys from.\n * @returns {Array} - Array of keys.\n *\n * @example\n * keys({a: 1, b: 2});\n * // => ['a', 'b']\n*/\nconst objectKeys = Object.keys;\nexport function keys(source) {\n\tif (source) {\n\t\treturn objectKeys(source);\n\t}\n}\n","const regexToPath = /\\.|\\[/;\nconst regexCloseBracket = /]/g;\nconst emptyString = '';\n/**\n * Breaks up string into object chain list.\n *\n * @function toPath\n * @type {Function}\n * @category utility\n * @param {String} source - String to be broken up.\n * @returns {Array} - Array used to go through object chain.\n *\n * @example\n * import { toPath, assert } from '@universalweb/acid';\n * assert(toPath('post.like[2]'), ['post', 'like', '2']);\n */\nexport function toPath(source) {\n\treturn source.replace(regexCloseBracket, emptyString).split(regexToPath);\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { isArray } from '../types/isArray.js';\nimport { toPath } from './toPath.js';\nimport { everyArray } from '../arrays/every.js';\n/**\n * Returns property on an object.\n *\n * @function get\n * @category utility\n * @type {Function}\n * @param {String} propertyString - String used to retrieve properties.\n * @param {Object} target - Object which has a property retrieved from it.\n * @returns {Object} - Returns property from the given object.\n *\n * @example\n * import { get, assert } from '@universalweb/acid';\n * const objectTarget = {\n *   post: {\n *     like: ['a','b','c']\n *   }\n * };\n * assert(get('post.like[2]', objectTarget), 'c');\n */\nexport function get(propertyString, target) {\n\tif (!target) {\n\t\treturn false;\n\t}\n\tlet link = target;\n\tconst pathArray = (isArray(propertyString)) ? propertyString : toPath(propertyString);\n\teveryArray(pathArray, (item) => {\n\t\tlink = link[item];\n\t\treturn hasValue(link);\n\t});\n\treturn link;\n}\n\n","import { everyArray } from '../arrays/every.js';\nimport { keys } from './keys.js';\nimport { toPath } from '../utilities/toPath.js';\nimport { get } from '../utilities/get.js';\nconst hasOwn = Object.hasOwn;\n/**\n * Checks to see if an object has all of the given property names.\n *\n * @function hasKeys\n * @category object\n * @type {Function}\n * @param {Object} source - Source object to check for keys.\n * @param {...String} properties - List of strings to check.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { hasKeys, assert } from '@universalweb/acid';\n * assert(hasKeys({a: {b: { c: 1}}}, 'a', 'a.b', 'a.b.c'), true);\n */\nexport function hasKeys(source, ...properties) {\n\tif (!source) {\n\t\treturn;\n\t}\n\treturn everyArray(properties, (item) => {\n\t\tconst pathArray = toPath(item);\n\t\tif (pathArray.length === 1) {\n\t\t\treturn hasOwn(source, item);\n\t\t} else {\n\t\t\tconst lastPath = pathArray.pop();\n\t\t\tconst initialPathObject = get(pathArray, source);\n\t\t\tif (initialPathObject) {\n\t\t\t\treturn hasOwn(initialPathObject, lastPath);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t});\n}\n/**\n * Checks to see if an object has any of the given property names.\n *\n * @function hasAnyKeys\n * @category object\n * @type {Function}\n * @param {Object} source - Source object to check for keys.\n * @param {Array} properties - List of strings to check.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { hasAnyKeys, assert } from '@universalweb/acid';\n * assert(hasAnyKeys({a: {b: { yes : 1}}}, 'no', 'nope', 'a.b.yes'), true);\n * assert(hasAnyKeys({a: {b: { yes : 1}}}, 'no', 'nope', 'a.b.noped'), false);\n */\nexport function hasAnyKeys(source, ...properties) {\n\tif (!source) {\n\t\treturn;\n\t}\n\treturn Boolean(properties.find((item) => {\n\t\tconst pathArray = toPath(item);\n\t\tif (pathArray.length === 1) {\n\t\t\treturn hasOwn(source, item);\n\t\t} else {\n\t\t\tconst lastPath = pathArray.pop();\n\t\t\tconst initialPathObject = get(pathArray, source);\n\t\t\tif (initialPathObject) {\n\t\t\t\treturn hasOwn(initialPathObject, lastPath);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}));\n}\n\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if the value is a plain object.\n *\n * @function isPlainObject\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isPlainObject } from '@universalweb/acid';\n * isPlainObject({});\n * // => true\n */\nexport const isPlainObject = (value) => {\n\tif (hasValue(value)) {\n\t\treturn value.constructor.toString().trim()\n\t\t\t.slice(9, 16) === 'Object(';\n\t}\n\treturn false;\n};\n","import { hasValue } from './hasValue.js';\n/**\n * Checks to see if the constructor is that of a native object.\n *\n * @function isConstructor\n * @category type\n * @param {Object} target - The object to be checked.\n * @param {Object} source - The source constructor object.\n * @returns {Object} - Returns the target object.\n *\n * @example\n * import { isConstructor, assert } from '@universalweb/acid';\n * assert(isConstructor(2, Number), true);\n */\nexport function isConstructor(target, source) {\n\treturn target?.constructor === source || false;\n}\nexport function isConstructorFactory(source) {\n\treturn (target) => {\n\t\treturn isConstructor(target, source);\n\t};\n}\nexport function constructorName(source) {\n\treturn source?.constructor?.name;\n}\nexport function isConstructorNameFactory(source) {\n\treturn (target) => {\n\t\treturn constructorName(target) === source || false;\n\t};\n}\n","import { everyArray } from '../arrays/every.js';\nexport function isTypeFactory(method) {\n\treturn function(primarySource, ...otherSources) {\n\t\tif (otherSources) {\n\t\t\treturn method(primarySource) && everyArray(otherSources, method);\n\t\t}\n\t\treturn method(primarySource);\n\t};\n}\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Buffer.\n *\n * @function isBuffer\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isBuffer, assert } from '@universalweb/acid';\n * assert(isBuffer(Buffer.from('test')), true);\n */\nexport const isBufferCall = isConstructorNameFactory('Buffer');\nexport const isBuffer = isTypeFactory(isBufferCall);\n","import { hasKeys } from '../objects/hasKeys.js';\nimport { everyArray } from '../arrays/every.js';\nimport { keys } from '../objects/keys.js';\nimport { isArray } from '../types/isArray.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isBuffer } from '../types/isBuffer.js';\n/**\n * Performs a deep comparison between two objects & determines if the value is the same using strict comparison.\n *\n * @function isEqual\n * @type {Function}\n * @category utility\n * @param {*} source - Source object.\n * @param {*} target - Object to be compared.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isEqual, assert } from '@universalweb/acid';\n * assert(isEqual({a: [1,2,3]}, {a: [1,2,3]}), true);\n */\n// Add map & buffer Support - Review required for performance and support for more types\nexport const isEqual = (source, target) => {\n\tif (source === target) {\n\t\treturn true;\n\t} else if (isBuffer(source)) {\n\t\treturn source.equals(target);\n\t} else if (source.toString() === target.toString()) {\n\t\tif (isPlainObject(source)) {\n\t\t\tconst sourceProperties = keys(source);\n\t\t\tif (hasKeys(target, sourceProperties)) {\n\t\t\t\treturn everyArray(sourceProperties, (key) => {\n\t\t\t\t\treturn isEqual(source[key], target[key]);\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (isArray(source)) {\n\t\t\tif (source.length === target.length) {\n\t\t\t\treturn everyArray(source, (item, index) => {\n\t\t\t\t\treturn isEqual(item, target[index]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n","import { everyArray } from './every.js';\nimport { isEqual } from '../utilities/isEqual.js';\n/**\n * Performs a shallow strict comparison between two objects.\n *\n * @function isMatchArray\n * @type {Function}\n * @category array\n * @param {Array} source - Source object.\n * @param {Array} compareArray - Object to compare to source.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isMatchArray, assert } from '@universalweb/acid';\n * assert(isMatchArray([1, 2, 3], [1, 2, 3]), true);\n */\nexport function isMatchArray(source, compareArray) {\n\tif (source.length === compareArray.length) {\n\t\treturn everyArray(source, (item, index) => {\n\t\t\treturn isEqual(compareArray[index], item);\n\t\t});\n\t}\n\treturn false;\n}\n\n","const mathNativeMax = Math.max;\n/**\n * Plucks the largest value from an array.\n *\n * @function largest\n * @type {Function}\n * @category array\n * @param {Array} array - Array from which largest number is taken.\n * @returns {Number} - The largest number.\n *\n * @example\n * import { largest, assert } from '@universalweb/acid';\n * assert(largest([1,2,3]), 3);\n */\nexport function largest(array) {\n\treturn mathNativeMax(...array);\n}\n\n","/**\n * Extracts item(s) from an array starting from the last item in the array.\n *\n * @function last\n * @type {Function}\n * @category array\n * @param {Array} array - Array to have items extracted from.\n * @param {Number} [indexFrom = 0] - Value which determines how many items are extracted from the array.\n * @returns {Array} - Items from the array.\n *\n * @example\n * import { last, assert } from '@universalweb/acid';\n * assert(last([1, 2, 3, 4, 5] , 2), [4, 5]);\n */\nexport function last(array, indexFrom) {\n\tconst arrayLength = array.length;\n\treturn (indexFrom) ? array.slice(arrayLength - indexFrom, arrayLength) : array[arrayLength - 1];\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachArray } from './each.js';\n/**\n * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n *\n * @function mapArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array of the same calling array's type.\n *\n * @example\n * import { mapArray, assert } from '@universalweb/acid';\n * assert(mapArray([1, 2, 3], (item) => {\n *   return item * 2;\n * }), [2, 4, 6]);\n */\nexport function mapArray(source, iteratee, results = [], thisBind) {\n\teachArray(source, (item, index, arrayOriginal, arrayLength) => {\n\t\tresults[index] = iteratee(item, index, results, arrayOriginal, arrayLength, thisBind);\n\t});\n\treturn results;\n}\n","import { eachAsyncArray } from './eachAsync.js';\n/**\n * Asynchronously iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n *\n * @function mapAsyncArray\n * @category array\n * @type {Function}\n * @async\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n * @returns {Array} - An array of the same calling array's type.\n *\n * @example\n * import { mapAsyncArray, assert } from '@universalweb/acid';\n * assert(await mapAsyncArray([1, 2, 3], async (item) => {\n *   return item * 2;\n * }), [2, 4, 6]);\n */\nexport async function mapAsyncArray(source, iteratee) {\n\tconst results = [];\n\tawait eachAsyncArray(source, async (item, index, arrayLength) => {\n\t\tresults[index] = await iteratee(item, index, arrayLength);\n\t});\n\treturn results;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachArray } from './each.js';\n/**\n * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array in reverse.\n *\n * @function mapRightArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results. Default value is a new empty array.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array of the same calling array's type.\n *\n * @example\n * import { mapRightArray, assert } from '@universalweb/acid';\n * assert(mapRightArray([1, 2, 3], (item) => {\n *   return item * 2;\n * }), [6, 4, 2]);\n */\nexport function mapRightArray(source, iteratee, results = [], thisBind) {\n\tlet trueIndex = 0;\n\tconst arrayLength = source.length;\n\tfor (let index = arrayLength - 1;index >= 0;index--) {\n\t\tresults[trueIndex] = iteratee(source[index], index, source, arrayLength, thisBind);\n\t\ttrueIndex++;\n\t}\n\treturn results;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { eachArray } from './each.js';\n/**\n * Iterates through the given and creates an object with all elements that pass the test implemented by the iteratee.\n *\n * @function mapWhile\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results. Default value is a new empty array.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - An array with properties that passed the test.\n *\n * @example\n * import { mapWhile, assert } from '@universalweb/acid';\n * assert(mapWhile([1, 2, 0], (item) => {\n *   return Boolean(item);\n * }), [1, 2]);\n */\nexport function mapWhile(source, iteratee, results = [], thisBind) {\n\tconst arrayLength = source.length;\n\tfor (let index = 0;index < arrayLength;index++) {\n\t\tconst item = source[index];\n\t\tconst returned = iteratee(item, index, results, source, arrayLength, thisBind);\n\t\tif (returned === false) {\n\t\t\tbreak;\n\t\t}\n\t\tresults[index] = item;\n\t}\n\treturn results;\n}\n\n","/**\n * Subtracts the subtrahend (second argument) from the minuend (first argument).\n *\n * @function subtract\n * @category math\n * @type {Function}\n * @param {Number} minuend - The minuend.\n * @param {Number} subtrahend - The subtrahend.\n * @returns {Number} - Returns the difference.\n *\n * @example\n * import { subtract, assert } from '@universalweb/acid';\n * assert(subtract(3, 1), 2);\n */\nexport function subtract(minuend, subtrahend) {\n\treturn minuend - subtrahend;\n}\n","import { subtract } from '../math/subtract.js';\n/**\n * Sorts an array of numbers in ascending order. Smallest to largest.\n *\n * @function sortNumberAscending\n * @category array\n * @param {Array} numberList - Array of numbers.\n * @returns {Array} - The array this method was called on.\n *\n * @example\n * import { sortNumberAscending, assert } from '@universalweb/acid';\n * assert(sortNumberAscending([10, 0, 2, 1]),  [0, 1, 2, 10]);\n */\nexport function sortNumberAscending(numberList) {\n\treturn numberList.sort(subtract);\n}\n","import { eachArray } from './each.js';\n/**\n * Takes all but the last item in the array.\n *\n * @function arrayToObject\n * @type {Function}\n * @category array\n * @param {Array} source - Array to have items extracted from.\n * @param {Array} properties - Array to have items extracted from.\n * @returns {Array} - Returns a completely flattened array.\n *\n * @example\n * import { arrayToObject, assert } from '@universalweb/acid';\n * assert(arrayToObject([1, 2, 3], ['a', 'b', 'c']), {a:1, b:2, c: 3});\n */\nexport function arrayToObject(source, properties) {\n\tconst sortedObject = {};\n\teachArray(source, (item, key) => {\n\t\tsortedObject[properties[key]] = item;\n\t});\n\treturn sortedObject;\n}\n\n","import { compactMapArray } from './compactMap.js';\n/**\n * Split array into two arrays: one whose elements all satisfy predicate and one whose elements all do not satisfy predicate.\n *\n * @function partition\n * @type {Function}\n * @category array\n * @param {Array} array - Takes an array to split.\n * @param {Function} predicate - Function run on each item in the array.\n * @returns {Array} - One array split into two arrays.\n *\n * @example\n * import { partition, assert } from '@universalweb/acid';\n * const result = partition([\n *  {user: 'barney', age: 36, active: false},\n *  {user: 'fred', age: 40, active: true},\n *  {user: 'pebbles', age: 1,  active: false}\n * ], (item) => { return item.active; });\n * assert(result, [{\"user\":\"fred\",\"age\":40,\"active\":true}],\n *   [{\"user\":\"barney\",\"age\":36,\"active\":false},\n *   {\"user\":\"pebbles\",\"age\":1,\"active\":false}]);\n */\nexport function partition(array, predicate) {\n\tconst rejected = [];\n\treturn [\n\t\tcompactMapArray(array, (item, index) => {\n\t\t\tif (predicate(item, index)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t\trejected.push(item);\n\t\t}),\n\t\trejected\n\t];\n}\n\n","/**\n * Subtracts the subtrahend (first argument) from the minuend (second argument). The arguments are reversed compared to the subtract function.\n *\n * @function subtractReverse\n * @category math\n * @type {Function}\n * @param {Number} minuend - The minuend.\n * @param {Number} subtrahend - The subtrahend.\n * @returns {Number} - Returns the difference.\n *\n * @example\n * import { subtractReverse, assert } from '@universalweb/acid';\n * assert(subtractReverse(1, 3), 2);\n */\nexport function subtractReverse(subtrahend, minuend) {\n\treturn minuend - subtrahend;\n}\n","import { subtractReverse } from '../math/subtractReverse.js';\n/**\n * Sorts an array of numbers in descending order. Largest to smallest.\n *\n * @function sortNumberDescening\n * @category array\n * @param {Array} numberList - Array of numbers.\n * @returns {Array} - The array this method was called on.\n *\n * @example\n * import { sortNumberDescening, assert } from '@universalweb/acid';\n * assert(sortNumberDescening([10, 0, 2, 1]), [10, 2, 1, 0]);\n */\nexport function sortNumberDescening(numberList) {\n\treturn numberList.sort(subtractReverse);\n}\n","/**\n * Removes all occurrences of the passed in items from the array and returns the array. This mutates the given array. Clone the array if you desire to avoid mutation.\n *\n * @function remove\n * @category array\n * @param {Array} array - Array to be mutated.\n * @param {String|Array} removeThese - Items to remove from the array.\n * @returns {Array} - The array this method was called on.\n *\n * @example\n * remove([1, 2, 3, 3, 4, 3, 5], 1);\n * // => [2, 3, 3, 4, 3, 5]\n * @example\n * remove([3, 3, 4, 5], 3, 4);\n * // => [5]\n */\nexport function remove(array, removeThese) {\n\tlet arrayLength = array.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst item = array[index];\n\t\tif (removeThese.includes(item)) {\n\t\t\tarray.splice(index, 1);\n\t\t\tindex--;\n\t\t\tarrayLength--;\n\t\t}\n\t}\n\treturn array;\n}\n/**\n * Removes items that pass the method's test. This mutates the given array. Clone the array if you desire to avoid mutation.\n *\n * @function removeBy\n * @category array\n * @param {Array} source - Array to be mutated.\n * @param {Function} iteratee - Function used to check object. Return true to remove the value.\n * @returns {Array} - The array this method was called on.\n *\n * @example\n * removeBy([1, 2, 3, 3, 4, 3, 5], (item) => { return Boolean(item % 2);});\n * // => [2, 4]\n */\nexport function removeBy(source, iteratee) {\n\tlet arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst item = source[index];\n\t\tif (iteratee(item, index)) {\n\t\t\tsource.splice(index, 1);\n\t\t\tindex--;\n\t\t\tarrayLength--;\n\t\t}\n\t}\n\treturn source;\n}\n\n","/**\n * Extracts all items in array except the first and last item.\n *\n * @function rest\n * @type {Function}\n * @category array\n * @param {Array} array - Array to be sliced.\n * @returns {Array} - Returns the aggregated array.\n *\n * @example\n * rest([1, 2, 3, 4, 5]);\n * // => [2, 3, 4, 5]\n */\nexport function rest(array) {\n\treturn array.slice(1, array.length);\n}\n\n","/**\n * Get the item at the supplied index starting at the end of the array.\n *\n * @function right\n * @type {Function}\n * @category array\n * @param {Array} source - Array to be sliced.\n * @param {Number} amount - Amount from the right.\n * @returns {*} - Returns the object at the evaluated position.\n *\n * @example\n * right([1, 2, 3, 4, 5] , 1);\n * // => 4\n */\nexport function right(source, amount) {\n\treturn source[source.length - 1 - amount];\n}\n\n","const {\n\tfloor,\n\trandom\n} = Math;\n/**\n *  Produces a random whole number between min (included) and max (excluded). Do not use for security or encryption.\n *\n * @function randomInt\n * @category number\n * @type {Function}\n * @param {Number} max - The highest possible value for the random number.\n * @param {Number} [min = 0] - Establishes lowest possible value for the random number.\n * @returns {Number} - Returns random integer between the max and min range.\n *\n * @example\n * import { randomInt, assert } from '@universalweb/acid';\n * assert(randomInt(10, 0), (value) => { return value > 0 && value < 10;});\n */\nexport function randomInt(max, min = 0) {\n\treturn floor(random() * (max - min)) + min;\n}\n","const arrayNative = Array;\n/**\n * Takes an array like object and creates a new Array from it.\n *\n * @function toArray\n * @category array\n * @param {*} arrayLike - Array like object.\n * @returns {*} - New array.\n *\n * @example\n * toArray([1, 2, 3]);\n * // => [1, 2, 3]\n*/\nexport const toArray = arrayNative.from;\n\n","/**\n * Checks if two numbers are the same.\n *\n * @function isNumberEqual\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @param {Number} target - Number to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNumberEqual, assert } from '@universalweb/acid';\n * assert(isNumberEqual(0, 0), true);\n */\nexport function isNumberEqual(source, target) {\n\treturn source === target;\n}\n","import { randomInt } from '../math/randomInt.js';\nimport { toArray } from '../internal/array.js';\nimport { isNumberEqual } from '../numbers/isNumberEqual.js';\n/**\n * Shuffle an array and return a new array.\n *\n * @function shuffle\n * @category array\n * @param {Array} target - Target Array to be shuffled.\n * @param {Number} amount - The amount of times to shuffle the array.\n * @returns {Array} - An array with the shuffled results.\n *\n * @example\n * import { shuffle, assert } from '@universalweb/acid';\n * assert(shuffle([1, 2, 3, 4]), [3, 4, 2, 1]);\n */\nexport function shuffle(target, amount = target.length) {\n\tif (target.length <= 1) {\n\t\treturn toArray(target);\n\t}\n\tconst shuffleArray = toArray(target);\n\tlet count = 0;\n\tlet index;\n\tlet value;\n\twhile (count < amount) {\n\t\tindex = randomInt(shuffleArray.length - 1, 0);\n\t\tvalue = shuffleArray[count];\n\t\tshuffleArray[count] = shuffleArray[index];\n\t\tshuffleArray[index] = value;\n\t\tcount++;\n\t}\n\treturn shuffleArray;\n}\n\n","import { randomInt } from '../math/randomInt.js';\nimport { shuffle } from './shuffle.js';\n/**\n * Produce a random sample from the list. Pass a number to return n random elements from the list. Otherwise a single random item will be returned.\n *\n * @function sample\n * @category array\n * @param {Array} source - The array to pull sample(s) from.\n * @param {Number} amount - The amount of samples to take.\n * @returns {Array} - An array of randomly pulled samples.\n *\n * @test\n * (async () => {\n *   const tempResult = sample([1, 2] , 2);\n *   return assert(tempResult.includes(1) && tempResult.includes(2), true);\n * });\n *\n * @example\n * sample([1, 2, 3, 4] , 2);\n * // => [1, 3]\n */\nexport function sample(source, amount) {\n\tif (!source) {\n\t\treturn false;\n\t}\n\tconst arrayLength = source.length;\n\tif (arrayLength === amount || amount > arrayLength) {\n\t\treturn shuffle(source);\n\t}\n\tif (amount === 1) {\n\t\treturn [source[randomInt(arrayLength - 1, 0)]];\n\t}\n\tconst sampleArray = [];\n\tconst used = {};\n\tlet count = 0;\n\tlet index;\n\twhile (count < amount) {\n\t\tindex = randomInt(source.length - 1, 0);\n\t\tif (!used[index]) {\n\t\t\tsampleArray.push(source[index]);\n\t\t\tused[index] = true;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn sampleArray;\n}\n\n","const mathNativeMin = Math.min;\n/**\n * Plucks the smallest value from an array.\n *\n * @function smallest\n * @category array\n * @type {Function}\n * @param {Array} array - Array from which smallest number is taken.\n * @returns {Number} - The smallest number.\n *\n * @example\n * smallest([1,2,3]);\n * // => 1\n */\nexport function smallest(array) {\n\treturn mathNativeMin(...array);\n}\n\n","import { everyArray } from './every.js';\n/**\n * What index should the number be inserted at to keep a sorted array still sorted.\n *\n * @function getNumberInsertIndex\n * @category array\n * @type {Function}\n * @param {Array} source - Array to be checked.\n * @param {Number} target - Number to check where to be inserted.\n * @returns {Number} - The index at which to insert.\n *\n * @example\n * import { getNumberInsertIndex, assert } from '@universalweb/acid';\n * assert(getNumberInsertIndex([30, 39, 50], 40), 1);\n */\nexport function getNumberInsertIndex(source, target) {\n\tlet insertIndex = 0;\n\teveryArray(source, (item, index) => {\n\t\tinsertIndex = index;\n\t\tif (target >= item) {\n\t\t\tinsertIndex = index + 1;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn insertIndex;\n}\n","/**\n * Returns a shallow copy of the array up to an amount.\n *\n * @function take\n * @category array\n * @type {Function}\n * @param {Array} source - The source array to take from.\n * @param {Array} [endIndex = 1] - Zero-based index before which to end extraction.\n * @returns {Array} - The aggregated array.\n *\n * @example\n * import { take, assert } from '@universalweb/acid';\n * assert(take([1,2,3], 2), [1, 2]);\n */\nexport function take(source, endIndex = 1) {\n\treturn source.slice(0, endIndex);\n}\n\n","/**\n * Returns a shallow copy of the array up to an amount starting from the right.\n *\n * @function takeRight\n * @category array\n * @type {Function}\n * @param {Array} source - The source array to take right from.\n * @param {Array} [indexRight = 1] - Zero-based index from the right to begin extraction.\n * @returns {Array} - The aggregated array.\n *\n * @example\n * import { takeRight, assert } from '@universalweb/acid';\n * assert(takeRight([1,2,3], 2), [2, 3]);\n */\nexport function takeRight(source, indexRight = 1) {\n\tconst arrayLength = source.length;\n\treturn source.slice(arrayLength - indexRight, arrayLength);\n}\n\n","export function onlyUnique(value, index, array) {\n\treturn array.indexOf(value) === index;\n}\nexport function sortUnique(item, index, array) {\n\treturn item !== array[index - 1];\n}\n/**\n * Filters the array down to unique elements.\n *\n * @function unique\n * @category array\n * @type {Function}\n * @param {Array} source - The array to be filtered.\n * @param {Boolean} isSorted - Flag which means the array is already sorted.\n * @returns {Array} - The filtered array.\n *\n * @example\n * unique([1, 2, 2, 4]);\n * // => [1, 2, 4]\n */\nexport function unique(source, isSorted) {\n\tif (isSorted) {\n\t\treturn source.filter(sortUnique);\n\t}\n\treturn source.filter(onlyUnique);\n}\n\n","import { flattenDeep } from './flattenDeep.js';\nimport { unique } from './unique.js';\n/**\n * Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.\n *\n * @function union\n * @category array\n * @type {Function}\n * @param {...Array} arrays - The arrays to be evaluated.\n * @returns {Array} - The aggregated array.\n *\n * @example\n * union([1,2,4], [1,2,3]);\n * // => [1, 2, 4, 3]\n */\nexport function union(...arrays) {\n\treturn unique(flattenDeep(arrays));\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Loops through an array invoking an iteratee with (value, key). If the iteratee always yields true then true is returned.\n * If and when the iteratee yields false the loop stops & false is returned.\n *\n * @function untilFalseArray\n * @category array\n * @type {Function}\n * @param {Array} source - The array to iterate over.\n * @param {Function} iteratee - Transformation function which is passed item & key and expects a boolean to be returned.\n * @returns {Array} - Returns true if all returns are true or false if one value returns false.\n *\n * @example\n * import { untilFalseArray, assert } from '@universalweb/acid';\n * assert(untilFalseArray([true, true, false], (item) => {\n *   return item;\n * }), false);\n * assert(untilFalseArray([true, true, true], (item) => {\n *   return item;\n * }), true);\n */\nexport function untilFalseArray(source, iteratee) {\n\tconst sourceLength = source.length;\n\tfor (let index = 0;index < sourceLength;index++) {\n\t\tif (iteratee(source[index], index) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Loops through an array invoking an iteratee with (value, key). If the iteratee always yields false then true is returned.\n * If and when the iteratee yields true the loop stops & false is returned.\n *\n * @function untilTrueArray\n * @category array\n * @type {Function}\n * @param {Array} source - The array to iterate over.\n * @param {Function} iteratee - Transformation function which is passed item & key and expects a boolean to be returned.\n * @returns {Array} - Returns true if all returns are false or false if one value returns true.\n *\n * @example\n * import { untilTrueArray, assert } from '@universalweb/acid';\n * assert(untilTrueArray([true], (item) => {\n *   return item;\n * }), false);\n * assert(untilTrueArray([true, true, true], (item) => {\n *   return item;\n * }), true);\n */\nexport function untilTrueArray(source, iteratee) {\n\tconst sourceLength = source.length;\n\tfor (let index = 0;index < sourceLength;index++) {\n\t\tif (iteratee(source[index], index) === true) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the calling object and creates a new object based on the calling object's type with the results,\n * (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n * Re-checks the length each loop.\n *\n * @function whileCompactMap\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results. Default value is a new empty array.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { whileCompactMap, assert } from '@universalweb/acid';\n * assert(whileCompactMap([1, 2, 3, false, undefined, null], (item) => {\n *   return item;\n * }), [1, 2, 3, false]);\n */\nexport function whileCompactMap(source, iteratee, results = [], thisBind) {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\tconst result = results.push(iteratee(source[index], index, source, source.length, thisBind));\n\t\tindex++;\n\t\tif (hasValue(result)) {\n\t\t\tresults.push(result);\n\t\t}\n\t}\n\treturn source;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the given array but re-checks the length each loop. Usefull while mutating the same array being looped over.\n *\n * @function whileEachArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { whileEachArray, assert } from '@universalweb/acid';\n * const list = [];\n * whileEachArray([1, 2, 3], (item, index) => {\n *   list[index] = item;\n * });\n * assert(list, [1, 2, 3]);\n */\nexport function whileEachArray(source, iteratee, thisBind) {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\titeratee(source[index], index, source, source.length, thisBind);\n\t\tindex++;\n\t}\n\treturn source;\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\n/**\n * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n * Re-checks the length each loop.\n *\n * @function whileMapArray\n * @category array\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {Array} results - Array that will be used to assign results. Default value is a new empty array.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { whileMapArray, assert } from '@universalweb/acid';\n * assert(whileMapArray([1, 2, 3], (item, index, source) => {\n *   if (index === 0) {\n *     source.push(4);\n *   }\n *   return item;\n * }), [1, 2, 3, 4]);\n */\nexport function whileMapArray(source, iteratee, results = [], thisBind) {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\tresults.push(iteratee(source[index], index, source, source.length, thisBind));\n\t\tindex++;\n\t}\n\treturn source;\n}\n\n","import { construct } from '../classes/construct.js';\n/**\n * Returns a copy of the array with all instances of the values removed.\n *\n * @function without\n * @type {Function}\n * @category array\n * @param {Array} target - The target array to be filtered.\n * @param {Array} sources - Items to be removed.\n * @returns {Array} - The target array filtered.\n *\n * @example\n * import { without, assert } from '@universalweb/acid';\n * assert(without([1, 2, 2, 4], [4]), [1, 2, 2]);\n */\nexport function without(target, sources) {\n\tif (!sources) {\n\t\treturn target;\n\t}\n\tconst sourcesSet = construct(Set, sources);\n\treturn target.filter((item) => {\n\t\treturn !sourcesSet.has(item);\n\t});\n}\n\n","import { eachArray } from './each.js';\nimport { forEach } from '../utilities/forEach.js';\nimport { difference } from './difference.js';\nimport { construct } from '../classes/construct.js';\n/**\n * Creates an array that is the symmetric difference of the provided arrays.\n *\n * @function xor\n * @category array\n * @type {Function}\n * @param {...Array} arrays - The array(s) to be filtered.\n * @returns {Array} - The filtered array.\n *\n * @example\n * xor([2, 1], [2, 3, 5], [6]);\n * // => [1, 3, 5, 6]\n */\nexport function xor(...sources) {\n\tconst xorMap = construct(Map);\n\tconst xored = [];\n\tconst sourcesLength = sources.length;\n\tif (sourcesLength === 2) {\n\t\treturn difference(sources[0], sources[1]);\n\t}\n\teachArray(sources, (currentArray, parentIndex) => {\n\t\teachArray(currentArray, (child, childIndex) => {\n\t\t\tlet childRoot = xorMap.get(child);\n\t\t\tif (!childRoot) {\n\t\t\t\tchildRoot = {\n\t\t\t\t\tcount: 1,\n\t\t\t\t\tparentIndex,\n\t\t\t\t\tchild\n\t\t\t\t};\n\t\t\t\txorMap.set(child, childRoot);\n\t\t\t} else if (childRoot.parentIndex === parentIndex) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tchildRoot.count++;\n\t\t\t}\n\t\t});\n\t});\n\tforEach(xorMap, (item) => {\n\t\tif (item.count === 1) {\n\t\t\txored.push(item.child);\n\t\t}\n\t});\n\treturn xored;\n}\n\n","/**\n * Merges together the values of each of the arrays with the values at the corresponding position.\n *\n * @function zip\n * @type {Function}\n * @category array\n * @param {Array} arrays - The arrays to process.\n * @returns {Array} - Returns the new array of regrouped elements.\n *\n * @example\n * zip(['a', 'b'], [1, 2], [true, false]);\n * // => [['a', 1, true], ['b', 2, false]]\n */\nexport function zip(...arrays) {\n\treturn arrays[0].map((item, index) => {\n\t\treturn arrays.map((array) => {\n\t\t\treturn array[index];\n\t\t});\n\t});\n}\n/**\n * Takes an array of grouped elements and creates an array regrouping the elements to their pre-zip array configuration.\n *\n * @function unZip\n * @type {Function}\n * @category array\n * @param {Array} source - The array of grouped elements to process.\n * @returns {Array} - Returns the new array of regrouped elements.\n *\n * @example\n * unZip([['a', 1, true], ['b', 2, false]]);\n * // => [['a', 'b'], [1, 2], [true, false]]\n */\nexport function unZip(source) {\n\treturn source[0].map((item, index) => {\n\t\treturn source.map((arraySet) => {\n\t\t\treturn arraySet[index];\n\t\t});\n\t});\n}\n\n","import { isBuffer } from '../types/isBuffer.js';\nimport { hasValue } from '../types/hasValue.js';\n/**\n * Ensures the source is a Buffer if not the source is used to create a buffer using Buffer.from else if there's no source an empty Buffer is returned with Buffer.alloc(0). Keep in mind not all objects can be used to create a Buffer.\n *\n * @function ensureBuffer\n * @category buffer\n * @type {Function}\n * @param {*} source - Object to be checked.\n * @returns {Array} - Returns an array.\n *\n * @example\n * import { isBuffer, ensureBuffer, assert } from '@universalweb/acid';\n * assert(isBuffer(ensureBuffer('test')), true);\n */\nexport function ensureBuffer(source) {\n\treturn (isBuffer(source) && source) || (hasValue(source) && Buffer.from(source)) || Buffer.alloc(0);\n}\n","/**\n * Clears the values out of a buffer.\n *\n * @function clearBuffer\n * @category buffer\n * @type {Function}\n * @param {Array} source - Takes an array to be emptied.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { clearBuffer, assert } from '@universalweb/acid';\n * assert(clearBuffer(Buffer.from([1,'B', 'Cat'])), Buffer.from([]));\n */\nexport function clearBuffer(source) {\n\tsource.fill(0);\n\treturn source;\n}\n\n","import { eachArray } from '../arrays/each.js';\nimport { chunk } from '../arrays/chunk.js';\n/**\n * Creates an object composed of keys generated from the results of running each element of collection through iteratee.\n *\n * @function countBy\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array of objects.\n * @param {Function} iteratee - The iteratee to transform keys.\n * @returns {Object} - Returns the composed aggregate object.\n *\n * @example\n * import { countBy, assert } from '@universalweb/acid';\n * assert(countBy([{a:1}, {a:3}], (item) => { return 'a';}), {a: 2});\n */\nexport function countBy(collection, iteratee) {\n\tconst object = {};\n\tlet result;\n\teachArray(collection, (item) => {\n\t\tresult = iteratee(item);\n\t\tif (!object[result]) {\n\t\t\tobject[result] = 0;\n\t\t}\n\t\tobject[result]++;\n\t});\n\treturn object;\n}\n","import { eachArray } from '../arrays/each.js';\n/**\n * Count the amount of times a key is present in a collection.\n *\n * @function countKey\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array of objects.\n * @param {Function} propertyName - The name of the key.\n * @returns {Number} - The count.\n *\n * @example\n * import { countKey, assert } from '@universalweb/acid';\n * assert(countKey([{a:1}, {a:3}], 'a'), 2);\n */\nexport function countKey(collection, propertyName) {\n\tlet count = 0;\n\teachArray(collection, (item) => {\n\t\tif (item[propertyName]) {\n\t\t\tcount++;\n\t\t}\n\t});\n\treturn count;\n}\n","import { eachArray } from '../arrays/each.js';\n/**\n * Count the amount of times a key is not present in a collection.\n *\n * @function countWithoutKey\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array of objects.\n * @param {String} propertyName - The name of the key.\n * @returns {Number} - The count.\n *\n * @example\n * import { countWithoutKey, assert } from '@universalweb/acid';\n * assert(countWithoutKey([{a:1}, {a:3}], 'b'), 2);\n */\nexport function countWithoutKey(collection, propertyName) {\n\tlet count = 0;\n\teachArray(collection, (item) => {\n\t\tif (!item[propertyName]) {\n\t\t\tcount++;\n\t\t}\n\t});\n\treturn count;\n}\n","export function findIndexCache(element, index, array, indexMatch, propertyName) {\n\tif (element[propertyName] === indexMatch) {\n\t\treturn true;\n\t}\n}\n","import { findIndexCache } from './findIndexCache.js';\n/**\n * Finds an object in a collection by the given id and property name and returns the array index of the object.\n *\n * @function findIndex\n * @type {Function}\n * @category collection\n * @param {Array} collection - Collection to be checked for an item.\n * @param {Number|string} id - The value to look for.\n * @param {String} [propertyName = 'id'] - The name of the property to compare.\n * @returns {Number} - The index of the object.\n *\n * @example\n * findIndex([{id: 1}, {id: 2}], 1);\n * // => 0\n */\nexport function findIndex(collection, id, propertyName = 'id') {\n\tconst result = collection.findIndex((element, index) => {\n\t\treturn findIndexCache(element, index, collection, id, propertyName);\n\t});\n\treturn (result === -1) ? false : result;\n}\n\n","import { findIndexCache } from './findIndexCache.js';\n/**\n * Finds an object in a collection by the given id and property name.\n *\n * @function findItem\n * @type {Function}\n * @category collection\n * @param {Array} collection - Collection to be checked for an item.\n * @param {Number|string} id - The value to look for.\n * @param {String} [propertyName = 'id'] - The name of the property to compare.\n * @returns {Object} - The found object.\n *\n * @example\n * findItem([{id: 1}, {id: 2}], 1);\n * // => {id: 1}\n */\nexport function findItem(collection, id, propertyName = 'id') {\n\tconst result = collection.find((element, index) => {\n\t\treturn findIndexCache(element, index, collection, id, propertyName);\n\t});\n\treturn (result === -1) ? false : result;\n}\n","/**\n * Sorts an array in place using a key in descending order.\n *\n * @function sortCollectionDescending\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - The property name to sort by based on it's value.\n * @param {Function} ifMatch - A function which returns a number for the sort function if two object properties match.\n * @returns {Array} - The sorted array and or a clone of the array sorted.\n *\n * @example\n * import { sortCollectionDescending, assert } from '@universalweb/acid';\n * const result = [{id: 1}, {id: 0}];\n * const collect = [{id: 0}, {id: 1}];\n * const prop = 'id';\n * assert(sortCollectionDescending(collect, prop), result);\n */\nexport function sortCollectionDescendingFilter(previous, next, propertyName, ifMatch) {\n\tconst previousKey = previous[propertyName];\n\tconst nextKey = next[propertyName];\n\tif (previousKey === nextKey && ifMatch) {\n\t\treturn ifMatch(previous, next, propertyName);\n\t}\n\tif (!nextKey) {\n\t\treturn -1;\n\t} else if (!previousKey) {\n\t\treturn 1;\n\t} else if (previousKey < nextKey) {\n\t\treturn 1;\n\t} else if (previousKey > nextKey) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nexport function sortCollectionDescending(collection, propertyName = 'id', ifMatch) {\n\treturn collection.sort((previous, next) => {\n\t\treturn sortCollectionDescendingFilter(previous, next, propertyName, ifMatch);\n\t});\n}\n\n","/**\n * Perform alphabetical A-Z sort on a collection with the provided key name. Mutates the array.\n *\n * @function sortCollectionAlphabetically\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - Name of property to compare.\n * @param {Function} ifMatch - A function which returns a number for the sort function if two object properties match.\n * @returns {Array} - The sorted array.\n *\n * @example\n * import { sortCollectionAlphabetically, assert } from '@universalweb/acid';\n * const result = [{\"letter\":\"a\"},{\"letter\":\"c\", g: 0},{\"letter\":\"c\", g: 2}, {letter:'f'}];\n * const collect = [{letter:'a'}, {letter:'f'}, {\"letter\":\"c\", g: 2}, {letter:'c', g: 0}];\n * const prop = 'letter';\n * function ifMatchSort(c, n) {\n * if (c.g < n.g) {\n * return -1;\n * }\n * if (c.g > n.g) {\n * return 1;\n\t* }\n * }\n * assert(sortCollectionAlphabetically(collect, prop, ifMatchSort), result);\n */\nexport function sortObjectsAlphabetically(previous, next, propertyName, ifMatch) {\n\tconst previousKey = previous[propertyName];\n\tconst nextKey = next[propertyName];\n\tif (previousKey === nextKey && ifMatch) {\n\t\treturn ifMatch(previous, next, propertyName);\n\t}\n\treturn previousKey.localeCompare(nextKey);\n}\nexport function sortCollectionAlphabetically(collection, propertyName = 'id', ifMatch) {\n\treturn collection.sort((previous, next) => {\n\t\treturn sortObjectsAlphabetically(previous, next, propertyName, ifMatch);\n\t});\n}\n","/**\n * Sorts an array in place using a key in ascending order.\n *\n * @function sortCollectionAscending\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - The property name to sort by based on it's value.\n * @param {Function} ifMatch - A function which returns a number for the sort function if two object properties match.\n * @returns {Array} - The sorted array and or a clone of the array sorted.\n *\n * @example\n * import { sortCollectionAscending, assert } from '@universalweb/acid';\n * const result = [{id: 0}, {id: 1}];\n * const collect = [{id: 1}, {id: 0}];\n * const prop = 'id';\n * assert(sortCollectionAscending(collect, prop), result);\n */\nexport function sortCollectionAscendingFilter(previous, next, propertyName, ifMatch) {\n\tconst previousKey = previous[propertyName];\n\tconst nextKey = next[propertyName];\n\tif (previousKey === nextKey && ifMatch) {\n\t\treturn ifMatch(previous, next, propertyName);\n\t}\n\tif (!nextKey) {\n\t\treturn 1;\n\t} else if (!previousKey) {\n\t\treturn -1;\n\t} else if (previousKey < nextKey) {\n\t\treturn -1;\n\t} else if (previousKey > nextKey) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nexport function sortCollectionAscending(collection, propertyName = 'id', ifMatch) {\n\treturn collection.sort((previous, next) => {\n\t\treturn sortCollectionAscendingFilter(previous, next, propertyName, ifMatch);\n\t});\n}\n","import { sortCollectionAscending } from './sortCollectionAscending.js';\nimport { sortCollectionAlphabetically } from './sortCollectionAlphabetically';\n/**\n * Sorts an array in place using a key from oldest to newest and returns the oldest. Does not mutate the array.\n *\n * @function getHighest\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - The property name to sort by based on it's value.\n * @returns {Object} - The newest object in the collection.\n *\n * @example\n * import { getHighest, assert } from '@universalweb/acid';\n * assert(getHighest([{id: 1}, {id: 0}], 'id'), {id: 0});\n */\nexport function getHighest(collection, propertyName = 'id') {\n\treturn sortCollectionAscending(collection, propertyName)[0];\n}\n","import { sortCollectionDescending } from './sortCollectionDescending.js';\nimport { sortCollectionAlphabetically } from './sortCollectionAlphabetically';\nimport { getHighest } from './getHighest';\n/**\n * Sorts an array in place using a key from newest to oldest and returns the latest. Does not mutate the array.\n *\n * @function getLowest\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - The property name to sort by based on it's value.\n * @returns {Object} - The newest object in the collection.\n *\n * @example\n * import { getLowest, assert } from '@universalweb/acid';\n * assert(getLowest([{id: 1}, {id: 0}], 'id'), {id: 1});\n */\nexport function getLowest(collection, propertyName) {\n\treturn sortCollectionDescending(collection, propertyName, false)[0];\n}\n","import { eachArray } from '../arrays/each.js';\n/**\n * Creates an object composed of keys generated from the results of running each element of collection thru iteratee.\n * The order of grouped values is determined by the order they occur in collection.\n * The corresponding value of each key is an array of elements responsible for generating the key.\n *\n * @function groupBy\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array of objects.\n * @param {Function} iteratee - The iteratee to transform keys.\n * @returns {Object} - Returns the composed aggregate object.\n *\n * @example\n * groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n */\nexport function groupBy(collection, iteratee) {\n\tconst sortedObject = {};\n\teachArray(collection, (item) => {\n\t\tconst results = iteratee(item);\n\t\tif (!sortedObject[results]) {\n\t\t\tsortedObject[results] = [];\n\t\t}\n\t\tsortedObject[results].push(item);\n\t});\n\treturn sortedObject;\n}\n\n","import { eachArray } from '../arrays/each.js';\n/**\n * Given a list, and an iteratee function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know the keys are unique.\n *\n * @function indexBy\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array of objects.\n * @param {String} propertyName - The property name to index by.\n * @returns {Object} - Returns the composed aggregate object.\n *\n * @example\n * import { indexBy, assert } from '@universalweb/acid';\n * const result = { \"0\": {name: 'test', id: 0}, \"1\": {name: 'test2', id: 1}};\n * const indexed = indexBy([{name: 'test', id: 0}, {name: 'test2', id: 1}], 'id');\n * assert(indexed, result);\n */\nexport function indexBy(collection, propertyName = 'id') {\n\tconst sortedObject = {};\n\teachArray(collection, (item) => {\n\t\tsortedObject[item[propertyName]] = item;\n\t});\n\treturn sortedObject;\n}\n\n","import { mapArray } from '../arrays/map.js';\n/**\n * Invokes a function on the provided property name in each object in the collection.\n *\n * @function invoke\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection from which method will be taken.\n * @param {String} property - Value used to pluck method from object.\n * @param {*} value - Value to be passed to callable property.\n * @returns {Array} - Returns the results of the invoked method.\n *\n * @example\n * invoke([{lucy(item, index) { return [item, index];}}, {lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n * // => [['EXAMPLE', 0], ['EXAMPLE', 1]]\n */\nexport function invoke(collection, property, value) {\n\treturn mapArray(collection, (item, index) => {\n\t\treturn item[property](value, index);\n\t});\n}\n\n","import { mapAsyncArray } from '../arrays/mapAsync.js';\n/**\n * Asynchronously awaits & invokes a function on the provided property name in each object in the collection.\n *\n * @function invokeAsync\n * @category collection\n * @type {Function}\n * @async\n * @param {Array} collection - Collection from which method will be taken.\n * @param {String} property - Value used to pluck method from object.\n * @param {*} value - Value to be passed to callable property.\n * @returns {Array} - Returns the results of the invoked method.\n *\n * @test\n * (async () => {\n *   const result = await invokeAsync([{async lucy(item, index) { return [item, index];}}, {async lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n *   return assert(result, [['EXAMPLE', 0], ['EXAMPLE', 1]]);\n * });\n *\n * @example\n * invokeAsync([{async lucy(item, index) { return [item, index];}}, {async lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n * // => [['EXAMPLE', 0], ['EXAMPLE', 1]]\n */\nexport function invokeAsync(collection, property, value) {\n\treturn mapAsyncArray(collection, async (item, index) => {\n\t\treturn item[property](value, index);\n\t});\n}\n\n","import { isConstructorFactory } from './isConstructor.js';\n/**\n * Checks if the value is a string.\n *\n * @function isString\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isString } from '@universalweb/acid';\n * isString('Lucy');\n * // => true\n */\nexport const isString = isConstructorFactory(String);\n","import { isString } from '../types/isString.js';\nimport { mapArray } from '../arrays/map.js';\n/**\n * Returns an array of the plucked sources from the object. Sources are plucked in the order given by the array.\n *\n * @function pluckObject\n * @category object\n * @type {Function}\n * @param {Object} source - Array used to determine what sources to be plucked.\n * @param {String|Array} targets - Property name.\n * @returns {Array} - An array of plucked sources.\n *\n * @example\n * import { pluckObject, assert } from '@universalweb/acid';\n * assert(pluckObject({a: 1, b:3}, ['a','b']), [1, 3]);\n */\nexport function pluckObject(source, targets) {\n\tif (!source) {\n\t\treturn;\n\t} else if (isString(targets)) {\n\t\treturn source[targets];\n\t}\n\treturn mapArray(targets, (item) => {\n\t\treturn source[item];\n\t});\n}\n\n","import { mapArray } from '../arrays/map.js';\nimport { pluckObject } from '../objects/pluckObject.js';\n/**\n * Returns an array of the plucked values from the collection.\n *\n * @function pluck\n * @category collection\n * @type {Function}\n * @param {Array} collection - Array used to determine what value to be plucked.\n * @param {(String|Number|Array.<string, number>)} targets - Property name.\n * @returns {Array} - An array of plucked values.\n *\n * @example\n * import { pluck, assert } from '@universalweb/acid';\n * assert(pluck([{a: 1}, {a: 2}], 'a'), [1, 2]);\n * assert(pluck([{a: 1, b:3}, {a: 1, b:3}], ['a','b']), [[1, 3], [1, 3]]);\n */\nexport function pluck(collection, targets) {\n\treturn mapArray(collection, (item) => {\n\t\treturn pluckObject(item, targets);\n\t});\n}\n","/**\n * Perform alphabetical in reverse Z-A sort on a collection with the provided key name. Mutates the array.\n *\n * @function sortCollectionAlphabeticallyReverse\n * @category collection\n * @type {Function}\n * @param {Array} collection - Collection to be sorted.\n * @param {String} propertyName - Name of property to compare.\n * @param {Function} ifMatch - A function which returns a number for the sort function if two object properties match.\n * @returns {Array} - The sorted array.\n *\n * @example\n * import { sortCollectionAlphabeticallyReverse, assert } from '@universalweb/acid';\n * const result = [{letter:'f'},{\"letter\":\"c\"}, {\"letter\":\"a\"}];\n * const collect = [{letter:'a'}, {letter:'f'}, {\"letter\":\"c\"}];\n * const prop = 'letter';\n * assert(sortCollectionAlphabeticallyReverse(collect, prop), result);\n */\nexport function sortObjectsAlphabeticallyReverse(previous, next, propertyName, ifMatch) {\n\tconst previousKey = previous[propertyName];\n\tconst nextKey = next[propertyName];\n\tif (previousKey === nextKey && ifMatch) {\n\t\treturn ifMatch(previous, next, propertyName);\n\t}\n\treturn nextKey.localeCompare(previousKey);\n}\nexport function sortCollectionAlphabeticallyReverse(collection, propertyName = 'id', ifMatch) {\n\treturn collection.sort((previous, next) => {\n\t\treturn sortObjectsAlphabeticallyReverse(previous, next, propertyName, ifMatch);\n\t});\n}\n","/**\n * Return the file extension.\n *\n * @function getFileExtension\n * @category file\n * @param {*} source - Object to be checked.\n * @returns {String} - Returns the extension.\n *\n * @example\n * import { getFileExtension, assert } from '@universalweb/acid';\n * assert(getFileExtension('test.js'),'js');\n */\nexport function getFileExtension(source) {\n\tif (source) {\n\t\treturn source.substring(source.lastIndexOf('.') + 1);\n\t}\n}\n","/**\n * Return the file extension.\n *\n * @function getFilename\n * @category file\n * @param {*} source - Object to be checked.\n * @returns {String} - Returns the extension.\n *\n * @example\n * import { getFilename, assert } from '@universalweb/acid';\n * assert(getFilename('./universalweb/test.js'),'test.js');\n */\nexport function getFilename(source) {\n\tif (source) {\n\t\treturn source.substring(source.lastIndexOf('/') + 1);\n\t}\n}\n","import { hasValue } from '../types/hasValue.js';\nexport function regexTestFactory(regexType) {\n\treturn (item) => {\n\t\treturn (hasValue(item)) ? regexType.test(item) : false;\n\t};\n}\n","import { regexTestFactory } from '../internal/regexTestFactory.js';\n/**\n * Checks if the string has a .css extension.\n *\n * @function isFileCSS\n * @category file\n * @param {String} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFileCSS, assert } from '@universalweb/acid';\n * assert(isFileCSS('test.css'), true);\n */\nexport const isFileCSS = regexTestFactory(/\\.css$/);\n","import { regexTestFactory } from '../internal/regexTestFactory.js';\n/**\n * Checks if the string has a .html extension.\n *\n * @function isFileHTML\n * @category file\n * @param {String} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFileHTML, assert } from '@universalweb/acid';\n * assert(isFileHTML('test.html'), true);\n */\nexport const isFileHTML = regexTestFactory(/\\.html$/);\n","import { regexTestFactory } from '../internal/regexTestFactory.js';\n/**\n * Checks if the string has a .js extension.\n *\n * @function isFileJS\n * @category file\n * @param {String} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFileJS, assert } from '@universalweb/acid';\n * assert(isFileJS('test.js'), true);\n */\nexport const isFileJS = regexTestFactory(/\\.js$/);\n","import { regexTestFactory } from '../internal/regexTestFactory.js';\n/**\n * Checks if the string has a .json extension.\n *\n * @function isFileJSON\n * @category file\n * @param {String} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFileJSON, assert } from '@universalweb/acid';\n * assert(isFileJSON('test.json'), true);\n */\nexport const isFileJSON = regexTestFactory(/\\.json$/);\n","/**\n * Creates a function that executes callable, only after being called n times.\n *\n * @function after\n * @category function\n * @type {Function}\n * @param {Number} amount - The number of calls until method is invoked.\n * @param {Function} callable - The function to be called.\n * @returns {Function} - Returns the new pass-thru function.\n *\n * @test\n * (async () => {\n *   const onlyAfter = after(2, (item) => { return item;});\n *   return await assert(onlyAfter(1), undefined) && await assert(onlyAfter(2), 2);\n * });\n *\n * @example\n * import { after, assert } from '@universalweb/acid';\n * const onlyAfter = after(1, (item) => { return item;});\n * assert(onlyAfter(1), undefined);\n * assert(onlyAfter(2), 2);\n */\nexport function after(amount, callable) {\n\tlet point = amount;\n\tlet value;\n\tconst onlyAfter = (...args) => {\n\t\tif (point !== null) {\n\t\t\tpoint--;\n\t\t}\n\t\tif (point <= 0) {\n\t\t\tvalue = callable(...args);\n\t\t\tpoint = null;\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyAfter;\n}\n","/**\n * Creates a function that invokes callable, with up to n arguments, ignoring any additional arguments.\n *\n * @function ary\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to cap arguments for.\n * @param {Number} amount - The arity cap.\n * @returns {Object} - Returns the new capped function.\n *\n * @example\n * import { ary, assert } from '@universalweb/acid';\n * assert(ary((...args) => { return args;}, 2)(1, 2, 3), [1, 2]);\n */\nexport function ary(callable, amount) {\n\treturn (...args) => {\n\t\treturn callable(...args.splice(0, amount));\n\t};\n}\n\n","/**\n * Creates a function that executes callable, only before n times.\n *\n * @function before\n * @category function\n * @type {Function}\n * @param {Number} amount - The number of calls before n.\n * @param {Function} callable - The function to be called.\n * @returns {Function} - Returns the new pass-thru function.\n *\n * @example\n * import { before, assert } from '@universalweb/acid';\n * const onlyBefore = before(3, () => { return 1;});\n * assert(onlyBefore(1), 1);\n */\nexport function before(amount, callable) {\n\tlet point = amount;\n\tlet value;\n\tconst onlyBefore = (...args) => {\n\t\tif (point !== null) {\n\t\t\tpoint--;\n\t\t}\n\t\tif (point >= 1) {\n\t\t\tvalue = callable(...args);\n\t\t} else {\n\t\t\tpoint = null;\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyBefore;\n}\n","const objectAssign = Object.assign;\n/**\n * Copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\n *\n * @function assign\n * @category object\n * @param {Object} target - The target object.\n * @param {...Object} sources - The source object(s).\n * @returns {Object} - Returns the target object.\n *\n * @example\n * import { assign, assert } from '@universalweb/acid';\n * assert(assign({b: 2}, {a: 1}), {b: 2, a: 1});\n */\nexport function assign(target, ...sources) {\n\tif (target) {\n\t\treturn objectAssign(target, ...sources);\n\t}\n}\n","import { eachAsyncArray } from '../arrays/eachAsync.js';\nimport { keys } from './keys.js';\n/**\n * Asynchronously iterates through the given object.\n *\n * @function eachAsyncObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling object, key count, and array of keys.\n * @returns {Object|Function} - Returns source.\n *\n * @example\n * import { eachAsyncObject, assert } from '@universalweb/acid';\n * const tempList = [];\n * await eachAsyncObject({a: 1, b: 2, c: 3}, async (item, key) => {\n *     tempList[key] = item;\n *   });\n * assert(tempList, {a: 1, b: 2, c: 3});\n */\nexport const eachAsyncObject = async (source, iteratee) => {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst objectKeys = keys(source);\n\tawait eachAsyncArray(objectKeys, (key, index, array, propertyCount) => {\n\t\treturn iteratee(source[key], key, source, propertyCount, objectKeys);\n\t});\n\treturn source;\n};\n\n","import { keys } from './keys.js';\nimport { eachArray } from '../arrays/each.js';\n/**\n * Iterates through the given object.\n *\n * @function eachObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling object, key count, and array of keys.\n * @returns {Object|Function} - Returns the calling object.\n *\n * @example\n * import { eachObject, assert } from '@universalweb/acid';\n * assert(eachObject({a: 1, b: 2, c: 3}, (item) => {\n *   console.log(item);\n * }), {a: 1, b: 2, c: 3});\n */\nexport function eachObject(source, iteratee) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst objectKeys = keys(source);\n\treturn eachArray(objectKeys, (key, index, original, propertyCount) => {\n\t\titeratee(source[key], key, source, propertyCount, original);\n\t});\n}\n\n","export async function forEachAsync(source, callback) {\n\tconst values = [];\n\tconst properties = [];\n\tlet valuesLength = 0;\n\tsource.forEach((item, key) => {\n\t\tvalues[valuesLength] = item;\n\t\tproperties[valuesLength] = item;\n\t\tvaluesLength++;\n\t});\n\tfor (let index = 0; index < valuesLength; index++) {\n\t\tawait callback(values[index], properties[index]);\n\t}\n\treturn source;\n}\n","import { hasValue } from './hasValue.js';\nimport { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object(s) is a Set.\n *\n * @function isSet\n * @category type\n * @param {...*} sources - Objects to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isSet, assert } from '@universalweb/acid';\n * assert(isSet(new Set()), true);\n */\nexport const isSetCall = isConstructorNameFactory('Set');\nexport const isSet = isTypeFactory(isSetCall);\n","import { isSet } from '../types/isSet.js';\nexport function forOf(source, iteratee) {\n\tif (isSet(source)) {\n\t\tfor (const value of source) {\n\t\t\titeratee(value, source);\n\t\t}\n\t\treturn source;\n\t}\n\tfor (const [key, value] of source) {\n\t\titeratee(value, key, source);\n\t}\n\treturn source;\n}\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Int16Array.\n *\n * @function isGenerator\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isGenerator } from '@universalweb/acid';\n * isGenerator(function* (){});\n * // => true\n */\nexport const isGeneratorCall = isConstructorNameFactory('GeneratorFunction');\nexport const isGenerator = isTypeFactory(isGeneratorCall);\n","import { isGenerator } from '../types/isGenerator.js';\nimport { isSet } from '../types/isSet.js';\nexport async function forOfAsync(source, iteratee, generatorArgs) {\n\tif (isSet(source)) {\n\t\tfor (const value of source) {\n\t\t\tawait iteratee(value, source);\n\t\t}\n\t\treturn source;\n\t}\n\tif (isGenerator(source)) {\n\t\tfor await (const item of source(...generatorArgs)) {\n\t\t\tawait iteratee(item, source);\n\t\t}\n\t}\n\tfor (const [key, value] of source) {\n\t\tawait iteratee(value, key, source);\n\t}\n\treturn source;\n}\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if an object or objects are a plain object.\n *\n * @function isFunction\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFunction } from '@universalweb/acid';\n * isFunction(() => {});\n * // => true\n */\nexport const isFunction = (source) => {\n\treturn (hasValue(source)) ? source instanceof Function : false;\n};\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object is an async function.\n *\n * @function isAsync\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - True or false.\n *\n * @example\n * import { isAsync, assert } from '@universalweb/acid';\n * assert(isAsync(async() => {}), true);\n */\nexport const isAsyncCall = isConstructorNameFactory('AsyncFunction');\nexport const isAsync = isTypeFactory(isAsyncCall);\n\n","import { isArray } from '../types/isArray.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { isAsync } from '../types/isAsync.js';\nimport { isGenerator } from '../types/isGenerator.js';\nexport function generateLoop(arrayLoop, arrayLoopAsync, objectLoop, objectLoopAsync, forOfLoop, forOfLoopAsync) {\n\treturn (source, iteratee, results) => {\n\t\tlet returned;\n\t\tconst isIterateeAsync = isAsync(iteratee);\n\t\tif (!hasValue(source) || !iteratee) {\n\t\t\treturn;\n\t\t} else if (isArray(source)) {\n\t\t\treturned = (isIterateeAsync) ? arrayLoopAsync : arrayLoop;\n\t\t} else if (isPlainObject(source) || isFunction(source)) {\n\t\t\treturned = (isIterateeAsync) ? objectLoopAsync : objectLoop;\n\t\t} else if (forOfLoop) {\n\t\t\treturned = (isIterateeAsync) ? forOfLoopAsync : forOfLoop;\n\t\t} else if (isGenerator(source)) {\n\t\t\treturned = forOfLoopAsync;\n\t\t} else {\n\t\t\treturned = (isIterateeAsync) ? objectLoopAsync : objectLoop;\n\t\t}\n\t\treturn returned(source, iteratee, results);\n\t};\n}\n\n","import { eachArray } from '../arrays/each.js';\nimport { eachAsyncArray } from '../arrays/eachAsync.js';\nimport { eachAsyncObject } from '../objects/eachAsync.js';\nimport { eachObject } from '../objects/each.js';\nimport { forEach } from './forEach.js';\nimport { forEachAsync } from './forEachAsync.js';\nimport { forOf } from './forOf.js';\nimport { forOfAsync } from './forOfAsync.js';\nimport { generateLoop } from './generateLoop.js';\n/**\n * Iterates through the given object.\n *\n * @function each\n * @category utility\n * @type {Function}\n * @param {Array | object | Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n * @returns {Array | object | Function} - The originally given object.\n *\n * @example\n * import { each, assert } from '@universalweb/acid';\n * const list = {};\n * each({a: 1, b: 2, c: 3}, (item, key) => {\n *   list[key] = item;\n * });\n * assert(list, {a: 1, b: 2, c: 3});\n */\nexport const each = generateLoop(eachArray, eachAsyncArray, eachObject, eachAsyncObject, forOf, forOfAsync);\n\n","import { assign } from '../objects/assign.js';\nimport { each } from '../utilities/each.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { construct } from '../classes/construct.js';\nimport { isArray } from '../types/isArray.js';\nexport class Chain {\n\tconstructor(methods) {\n\t\tthis.addChainMethod(methods);\n\t}\n\taddChainMethod(methods) {\n\t\tconst thisChain = this;\n\t\teach(methods, (method, methodName) => {\n\t\t\tthisChain[methodName] = function(...args) {\n\t\t\t\tthis.value = method.call(thisChain, thisChain.value, ...args);\n\t\t\t\treturn thisChain;\n\t\t\t};\n\t\t});\n\t}\n\tsetValue(value) {\n\t\tthis.value = value;\n\t\treturn this;\n\t}\n\tdone() {\n\t\tconst value = this.value;\n\t\tthis.value = null;\n\t\treturn value;\n\t}\n\tvalue = null;\n}\n/**\n * Creates a chainable set of functions.\n *\n * @function chain\n * @category function\n * @type {Function}\n * @param {Array|Object} methods - The object to take methods from.\n * @returns {*} - Returns a function which has value, methods, add, and done. When invoking the function the argument is saved as the value property for further chaining.\n *\n * @example\n * import { chain, assert } from '@universalweb/acid';\n * const chained = chain({\n * \ta(value, c) {\n * \t\treturn value + c;\n * \t}\n * }).setValue(2).a(1).done();\n * assert(chained, 3);\n */\nexport function chain(config) {\n\treturn construct(Chain, [config]);\n}\n\n","import { clearArray } from '../arrays/clear.js';\n/**\n * Creates a function that accepts arguments of method and either invokes method returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining method arguments, and so on. The arity of method may be specified if method length is not sufficient.\n *\n * @function curry\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to curry.\n * @param {Number} arity - The arity of method.\n * @returns {*} - Returns the new curried function.\n *\n * @example\n * import { curry, assert } from '@universalweb/acid';\n * const result = curry((a, b, c) => {\n *   return [a, b, c];\n * })(1)(2)(3);\n * assert(result, [1, 2, 3]);\n */\nexport function curry(callable, arity = callable.length) {\n\tconst curries = [];\n\tconst curried = (...curryArgs) => {\n\t\tcurries.push(...curryArgs);\n\t\tif (curries.length === arity) {\n\t\t\tconst result = callable(...curries);\n\t\t\tclearArray(curries);\n\t\t\treturn result;\n\t\t}\n\t\treturn curried;\n\t};\n\treturn curried;\n}\n\n","import { clearArray } from '../arrays/clear.js';\n/**\n * Creates a function that accepts arguments of method and either invokes method returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining method arguments, and so on. The arity of method may be specified if method.length is not sufficient. The arguments are given in reverse order.\n *\n * @function curryRight\n * @type {Function}\n * @param {Function} callable - The function to curry.\n * @param {Number} arity - The arity of method.\n * @returns {*} - Returns the new curried function.\n *\n * @example\n * import { curryRight, assert } from '@universalweb/acid';\n * const result = curryRight((a, b, c) => {\n *   return [a, b, c];\n * })(1)(2)(3);\n * assert(result, [3, 2, 1]);\n */\nexport function curryRight(callable, arity = callable.length) {\n\tconst curries = [];\n\tconst curried = (...curryArgs) => {\n\t\tcurries.unshift(...curryArgs);\n\t\tif (curries.length === arity) {\n\t\t\tconst result = callable(...curries);\n\t\t\tclearArray(curries);\n\t\t\treturn result;\n\t\t}\n\t\treturn curried;\n\t};\n\treturn curried;\n}\n","/**\n * This method returns true.\n *\n * @function stubTrue\n * @category utility\n * @type {Function}\n * @returns {Boolean} - Returns true.\n *\n * @example\n * import { stubTrue } from '@universalweb/acid';\n * stubTrue();\n * // => true\n */\nexport const truth = true;\nexport const stubTrue = () => {\n\treturn truth;\n};\n","/**\n * This method returns false.\n *\n * @function stubFalse\n * @category utility\n * @type {Function}\n * @returns {Boolean} - Returns false.\n *\n * @example\n * import { stubFalse } from '@universalweb/acid';\n * stubFalse();\n * // => false\n */\nexport const falsy = false;\nexport const stubFalse = () => {\n\treturn falsy;\n};\n","/**\n * This method returns undefined.\n *\n * @function noop\n * @category function\n * @type {Function}\n * @returns {undefined} - Returns undefined.\n * @example\n * noop();\n * // => undefined\n */\nexport const noop = () => {\n\treturn;\n};\n\n","/**\n * Iterates based on the amount given invoking the iteratee with the current index as an argument.\n *\n * @function times\n * @category utility\n * @type {Function}\n * @param {Number} amount - The amount of times to loop invoking the iteratee.\n * @param {Function} iteratee - Transformation function which is passed index and amount.\n * @returns {undefined} - Nothing.\n *\n * @example\n * import { times } from '@universalweb/acid';\n * times(3, (item) => {\n *   console.log(item);\n * });\n * // 0\n * // 1\n * // 2\n * // => undefined\n */\nexport function times(amount, iteratee) {\n\tfor (let index = 0; index < amount; index++) {\n\t\titeratee(index);\n\t}\n}\n/**\n * Iterates based on the amount given and maps the results returned by the iteratee each time to an array.\n *\n * @function timesMap\n * @category utility\n * @type {Function}\n * @param {Number} amount - The amount of times to loop invoking the iteratee.\n * @param {Function} iteratee - Transformation function which is passed index and amount.\n * @param {Array} [results = []] - Array that will have iteratee return pushed to.\n * @returns {Array} - An array with iteratee's returned values.\n *\n * @example\n * import { timesMap } from '@universalweb/acid';\n * timesMap(3, (item) => {\n *   return item;\n * });\n * // => [0, 1, 2]\n */\nexport function timesMap(amount, iteratee, results = []) {\n\tfor (let index = 0; index < amount; index++) {\n\t\tresults[index] = iteratee(amount);\n\t}\n\treturn results;\n}\n","import { construct } from '../classes/construct.js';\nimport { truth } from './stubTrue.js';\nimport { falsy } from './stubFalse.js';\nimport { noop } from './noop.js';\nimport { times } from './times.js';\nexport class Timers {\n\tlist = construct(Map);\n\tconstruct() {\n\t}\n\t/**\n\t * Remove a timer that was created using the timer function.\n\t *\n\t * @param {Number} id - The id of the timer to remove.\n\t * @returns {undefined} - Returns nothing.\n\t *\n\t * @example\n\t * import { timer, assert } from '@universalweb/acid';\n\t * timer(() => {}, 100);\n\t * // => 0\n\t */\n\tremove(id) {\n\t\tclearTimeout(id);\n\t\tthis.list.delete(id);\n\t}\n\thas(id) {\n\t\treturn this.list.has(id);\n\t}\n\tget(id) {\n\t\treturn this.list.get(id);\n\t}\n\t/**\n\t * Create a timer and add it to the list of timers.\n\t *\n\t * @type {Function}\n\t * @param {Function} callable - The function to be invoked.\n\t * @param {Number} time - The time in milliseconds.\n\t * @returns {Object} - Returns setTimeoutId ID.\n\t *\n\t * @example\n\t * import { timers, assert } from '@universalweb/acid';\n\t * timers.set(() => {}, 100);\n\t * // => 0\n\t */\n\tset(callable, time) {\n\t\tconst currentThis = this;\n\t\tconst id = setTimeout(() => {\n\t\t\tcallable();\n\t\t\tcurrentThis.remove(id);\n\t\t}, time);\n\t\tthis.list.set(id, truth);\n\t\treturn id;\n\t}\n\t/**\n\t * Clear all active timers.\n\t *\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { timers, assert } from '@universalweb/acid';\n\t * timers.clear();\n\t * // => undefined\n\t */\n\tclear() {\n\t\tconst currentThis = this;\n\t\tcurrentThis.list.forEach((id) => {\n\t\t\tcurrentThis.remove(id);\n\t\t});\n\t}\n}\nexport const timers = construct(Timers);\n/**\n * Timer wrapper.\n *\n * @function timer\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked.\n * @param {Number} time - The time in milliseconds.\n * @returns {Object} - Returns setTimeoutId ID.\n *\n * @example\n * import { timer, assert } from '@universalweb/acid';\n * timer(() => {}, 100);\n * // => 0\n */\nexport function timer(callable, time) {\n\treturn timers.set(callable, time);\n}\n/**\n * Clear all active timers.\n *\n * @function clearTimers\n * @category function\n * @returns {undefined} - Returns undefined.\n *\n * @example\n * import { clearTimers, assert } from '@universalweb/acid';\n * clearTimers();\n * // => undefined\n */\nexport function clearTimers() {\n\tconst id = setTimeout(noop, 0);\n\ttimes(id, (index) => {\n\t\ttimers.remove(index);\n\t});\n}\n","/**\n * Calls a target function with arguments as specified.\n *\n * @function apply\n * @category function\n * @param {Function} target - The target function to call.\n * @param {*} thisArgument - Array like object.\n * @param {Array} argumentsList - An array-like object specifying the arguments with which target should be called.\n * @returns {*} - The result of calling the given target function with the specified this value and arguments.\n *\n * @example\n * apply(function (a) {return a;}, undefined, [2]);\n * // => 2\n*/\nexport const apply = Reflect.apply;\n","import { truth } from '../utilities/stubTrue.js';\nimport { falsy } from '../utilities/stubFalse.js';\nimport { timer, timers } from '../utilities/timer.js';\nimport { apply } from '../internal/apply.js';\n/**\n * Creates a debounced function that delays invoking callable until after milliseconds have elapsed since the last time the debounced function was invoked. The debounce function has a clear method to cancel the timer.\n *\n * @function debounce\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked.\n * @param {Number} time - The time in milliseconds.\n * @returns {Function} - The debounced function.\n *\n * @example\n * import { debounce, promise, assert } from '@universalweb/acid';\n * const promised = promise((a) => {\n * \t\tconst debounced = debounce(() => { debounced.clear(); a('debounced'); }, 0);\n * });\n * assert(await promised(), 'debounced');\n */\nexport function debounce(callable, time) {\n\tfunction debounced(...args) {\n\t\tif (debounced.id !== falsy) {\n\t\t\ttimers.remove(debounced.id);\n\t\t}\n\t\tdebounced.id = timer(() => {\n\t\t\tdebounced.callable(...args);\n\t\t\tdebounced.id = falsy;\n\t\t}, time);\n\t}\n\tdebounced.id = falsy;\n\tdebounced.callable = callable.bind(debounced);\n\tdebounced.clear = () => {\n\t\tif (debounced.id !== falsy) {\n\t\t\ttimers.remove(debounced.id);\n\t\t\tdebounced.id = falsy;\n\t\t}\n\t};\n\treturn debounced;\n}\n","import { isFunction } from '../types/isFunction.js';\n/**\n * Checks if the given method is a function. If it is then it invokes it with the given arguments.\n *\n * @function ifInvoke\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked if possible.\n * @param {...Array} args - Arguments to pass to the method.\n * @returns {*} - Returns the method invoked or undefined.\n *\n * @example\n * import { ifInvoke, assert } from '@universalweb/acid';\n * assert(ifInvoke((...args) => { return args;}, 1, 2), [1, 2]);\n */\nexport function ifInvoke(callable, ...args) {\n\tif (isFunction(callable)) {\n\t\treturn callable(...args);\n\t}\n}\n\n","/**\n * Iterates through the given array of async function(s). Each async function is awaited as to ensure synchronous order and is given the supplied object.\n *\n * @function inAsync\n * @type {Function}\n * @category Array\n * @async\n * @param {Array} source - Array of async functions that will be looped through.\n * Functions are given the supplied object, index, the calling array, and the array length.\n * @param {*} firstArgument - The first argument given to each function.\n * @returns {Object} - The originally given array.\n *\n * @example\n * import { inAsync, assert } from '@universalweb/acid';\n * const list = [];\n * await inAsync([async (firstArgument, item, index) => {\n *   list.push(index + firstArgument.a);\n * }, async (firstArgument, item, index) => {\n *   list.push(index);\n * }], {a:1});\n * assert(list, [1, 1]);\n */\nexport async function inAsync(source, firstArgument) {\n\tconst arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst method = source[index];\n\t\tawait method(firstArgument, index, source, arrayLength);\n\t}\n\treturn source;\n}\n\n","import { each } from '../utilities/each.js';\n/**\n * Invoke an array of functions.\n *\n * @function inSync\n * @category function\n * @type {Function}\n * @param {Array|Object|Function} collection - The functions to be invoked.\n * @param {*} value - The object passed as an argument to each method.\n * @returns {undefined} - Returns undefined.\n *\n * @test\n * (() => {\n *   const tempList = [];\n *   inSync([() => {tempList.push(1);}, () => {tempList.push(2);}]);\n *   return assert(tempList, [1, 2]);\n * });\n *\n * @example\n * inSync([() => {console.log(1);}, () => {console.log(2);}]);\n * // 1\n * // 2\n * // => undefined\n */\nexport const inSync = (collection, value) => {\n\treturn each(collection, (item) => {\n\t\titem(value);\n\t});\n};\n\n","/**\n * Creates a function that negates the result of the predicate callable.\n *\n * @function negate\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked.\n * @returns {*} - Returns the given methods result.\n *\n * @example\n * negate(() => { return false;})();\n * // => true\n */\nexport function negate(callable) {\n\treturn (...args) => {\n\t\treturn !callable(...args);\n\t};\n}\n\n","/**\n * Creates a function that gets the argument at index n. If n is negative, the nth argument from the end is returned.\n *\n * @function nthArg\n * @category function\n * @type {Function}\n * @param {Number} [index = 0] - The index of the argument to return.\n * @returns {Function} - Returns the new pass-thru function.\n *\n * @example\n * nthArg(1)('a', 'b');\n * // => 'b'\n */\nexport function nthArg(index = 0) {\n\treturn (...args) => {\n\t\treturn args[index];\n\t};\n}\n\n","import { hasValue } from '../types/hasValue.js';\n/**\n  * Creates a function that is restricted to execute method once. Repeat calls to the function will return the value of the first call. The method is executed with the this binding of the created function.\n  *\n  * @function once\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be called.\n  * @returns {Function} - Returns the new pass-thru function.\n  *\n  * @test\n  * (async () => {\n  *   const onceOnly = once((item) => { return item;});\n  *   return await assert(onceOnly(5), 5) && await assert(onceOnly(2), 5);\n  * });\n  *\n  * @example\n  * const onceOnly = once((item) => { return item;});\n  * onceOnly(5);\n  * onceOnly(3);\n  * // => 5\n*/\nexport const once = (callable) => {\n\tlet value;\n\tconst onlyOnce = (...args) => {\n\t\tif (!hasValue(value)) {\n\t\t\tvalue = callable(...args);\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyOnce;\n};\n","import { eachAsyncObject } from './eachAsync.js';\nimport { hasValue } from '../types/hasValue.js';\n/**\n * Asynchronously iterates through the calling object and creates an object with the results of the iteratee on every element in the calling object.\n *\n * @function mapObjectAsync\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object of the same calling object's type.\n *\n * @example\n * import { mapAsyncObject, assert } from '@universalweb/acid';\n * assert(await mapAsyncObject({a: 1, b: undefined, c: 3}, (item) => {\n *   return item;\n * }), {a: 1, b: undefined, c: 3});\n */\nexport async function mapAsyncObject(source, iteratee, results = {}) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tawait eachAsyncObject(source, async (item, key, thisObject, propertyCount, objectKeys) => {\n\t\tresults[key] = await iteratee(item, key, results, thisObject, propertyCount, objectKeys);\n\t});\n\treturn results;\n}\n\n","import { eachObject } from './each.js';\nimport { mapAsyncObject } from './mapAsync.js';\n/**\n * Iterates through the calling object and creates an object with the results of the iteratee on every element in the calling object.\n *\n * @function mapObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object of the same calling object's type.\n *\n * @example\n * import { mapObject, assert } from '@universalweb/acid';\n * assert(mapObject({a: 1, b: undefined, c: 3}, (item) => {\n *   return item;\n * }), {a: 1, b: undefined, c: 3});\n */\nexport function mapObject(source, iteratee, results = {}) {\n\tif (!source) {\n\t\treturn;\n\t}\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tresults[key] = iteratee(item, key, results, original, propertyCount, objectKeys);\n\t});\n\treturn results;\n}\n","/**\n * Returns the constructor of an object.\n *\n * @function getType\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { getType, assert } from '@universalweb/acid';\n * assert(getType(1), true);\n */\nexport function getType(source) {\n\treturn source?.constructor;\n}\n","import { getType } from './getType.js';\nimport { construct } from '../classes/construct.js';\n/**\n * Returns a new empty object of the same type.\n *\n * @function cloneType\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { cloneType, assert } from '@universalweb/acid';\n * assert(cloneType([1]), []);\n */\nexport function cloneType(source, args = []) {\n\tconst sourceType = getType(source);\n\tif (sourceType === Function) {\n\t\tif (sourceType.name === 'function') {\n\t\t\treturn function() {};\n\t\t}\n\t}\n\treturn construct(sourceType, args);\n}\n","import { returnValue } from './returnValue.js';\nimport { cloneType } from '../types/cloneType.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\nimport { isGenerator } from '../types/isGenerator.js';\n/**\n * Iterates through (using for of) the calling object and creates an object with the results of the iteratee on every element in the calling object.\n *\n * @function forOfCompactMap\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results else source is type cloned.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * forOfCompactMap({a: undefined, b: 2, c: 3}, (item) => {\n *   return item;\n * });\n * // => {b: 2, c: 3}\n */\nexport function forOfMap(source, iteratee = returnValue, resultsObject) {\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = iteratee(value, results, source);\n\t\t\tmethodPushBound(result);\n\t\t}\n\t\treturn results;\n\t}\n\tconst methodSet = isFunction(results.set);\n\tfor (const [key, value] of source) {\n\t\tconst result = iteratee(value, key, results, source);\n\t\tif (methodSet) {\n\t\t\tresults.set(key, result);\n\t\t} else {\n\t\t\tresults[key] = result;\n\t\t}\n\t}\n\treturn results;\n}\n","import { returnValue } from './returnValue.js';\nimport { cloneType } from '../types/cloneType.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isGenerator } from '../types/isGenerator.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\n/**\n * Asynchronously iterates (for of) through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function forOfCompactMapAsync\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * import { forOfCompactMapAsync, assert } from '@universalweb/acid';\n * assert(forOfCompactMapAsync({a: undefined, b: 2, c: 3}, (item) => {\n *   return item;\n * }), {b: 2, c: 3});\n */\nexport async function forOfMapAsync(source, iteratee = returnValue, resultsObject, generatorArgs) {\n\tif (isGenerator(source)) {\n\t\tconst resultsGenerator = [];\n\t\tfor await (const item of source(...generatorArgs)) {\n\t\t\tresultsGenerator.push(await iteratee(item, resultsGenerator, source));\n\t\t}\n\t\treturn resultsGenerator;\n\t}\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = await iteratee(value, results, source);\n\t\t\tmethodPushBound(result);\n\t\t}\n\t\treturn results;\n\t}\n\tconst methodSet = isFunction(results.set);\n\tfor await (const [key, value] of source) {\n\t\tconst result = await iteratee(value, key, results, source);\n\t\tif (methodSet) {\n\t\t\tresults.set(key, result);\n\t\t} else {\n\t\t\tresults[key] = result;\n\t\t}\n\t}\n\treturn results;\n}\n","import { mapArray } from '../arrays/map.js';\nimport { mapObject } from '../objects/map.js';\nimport { generateLoop } from './generateLoop.js';\nimport { mapAsyncArray } from '../arrays/mapAsync.js';\nimport { mapAsyncObject } from '../objects/mapAsync.js';\nimport { forOfMap } from './forOfMap.js';\nimport { forOfMapAsync } from './forOfMapAsync.js';\n/**\n * Iterates through the calling object and creates a new object based on the calling object's type with the results of the iteratee on every element in the calling object.\n *\n * @function map\n * @category utility\n * @type {Function}\n * @param {Array | object | Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n * @param {Object | Function} [results = {}] - Object that will be used to assign results.\n * @returns {Array | object | Function} - A new object of the same calling object's type.'.\n *\n * @example\n * import { map, assert } from '@universalweb/acid';\n * assert(map({a: 1, b: 2, c: 3}, (item) => {\n *   return item * 2;\n * }), {a: 2, b: 4, c: 6});\n */\nexport const map = generateLoop(mapArray, mapAsyncArray, mapObject, mapAsyncObject, forOfMap, forOfMapAsync);\n\n","import { map } from '../utilities/map.js';\n/**\n * Creates a function that invokes iteratee with the arguments it receives and returns their results.\n *\n * @function over\n * @category function\n * @type {Function}\n * @param {(Array.<function>|Object.<function>)} iteratees - The list of functions to loop through.\n * @returns {Function} - Returns the new over wrapped function.\n *\n * @example\n * import { overEvery, assert } from '@universalweb/acid';\n * assert(over([Math.max, Math.min])(1, 2, 3, 4), [4, 1]);\n */\nexport function over(iteratees) {\n\treturn (...args) => {\n\t\treturn map(iteratees, (item) => {\n\t\t\treturn item(...args);\n\t\t});\n\t};\n}\n","import { everyAsyncArray } from '../arrays/everyAsync.js';\nimport { keys } from './keys.js';\nimport { each } from '../utilities/each.js';\n/**\n * Iterates through the given object while the iteratee returns true.\n *\n * @function everyAsyncObject\n * @category object\n * @type {Function}\n * @param {Object} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n * @returns {Boolean} - Returns true if all values returned are true or false if one value returns false.\n *\n * @example\n * import { everyAsyncObject, assert } from '@universalweb/acid';\n * const result =  await everyAsyncObject({a: true, b: true, c: true}, (item) => {\n *   return item;\n * });\n * assert(result, true);\n */\nexport async function everyAsyncObject(source, iteratee) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst objectKeys = keys(source);\n\treturn everyAsyncArray(objectKeys, (key, index, original, propertyCount) => {\n\t\treturn iteratee(source[key], key, source, propertyCount, original);\n\t});\n}\n","import { everyArray } from '../arrays/every.js';\nimport { keys } from './keys.js';\n/**\n * Iterates through the given object while the iteratee returns true.\n *\n * @function everyObject\n * @category object\n * @type {Function}\n * @param {Object} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n * @returns {Boolean} - Returns true if all values returned are true or false if one value returns false.\n *\n * @example\n * import { everyObject, assert } from '@universalweb/acid';\n * const result =  everyObject({a: true, b: true, c: true}, (item) => {\n *   return item;\n * });\n * assert(result, true);\n */\nexport function everyObject(source, iteratee) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tconst objectKeys = keys(source);\n\treturn everyArray(objectKeys, (key, index, original, propertyCount) => {\n\t\treturn iteratee(source[key], key, source, propertyCount, original);\n\t});\n}\n","import { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\nimport { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\n/**\n * Iterates (for of) through the given object while the iteratee returns true using a for of loop.\n *\n * @function forOfEvery\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @returns {Boolean} - Returns true if all values returned are true or false if one value returns false.\n *\n * @example\n * import { every, assert } from '@universalweb/acid';\n * assert(forOfEvery({a: false, b: true, c: true}, (item) => {\n *  return item;\n * }), false);\n */\nexport function forOfEvery(source, iteratee = returnValue) {\n\tif (isArray(source) || isSet(source)) {\n\t\tfor (const value of source) {\n\t\t\tconst result = iteratee(value, source);\n\t\t\tif (result === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const [key, value] of source) {\n\t\t\tconst result = iteratee(value, key, source);\n\t\t\tif (result === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n","import { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\nimport { isGenerator } from '../types/isGenerator.js';\n/**\n * Asynchronously iterates (for of) through the given object while the iteratee returns true using a for of loop.\n *\n * @function forOfEveryAsync\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @returns {Boolean} - Returns true if all values returned are true or false if one value returns false.\n *\n * @example\n * import { every, assert } from '@universalweb/acid';\n * assert(forOfEveryAsync({a: false, b: true, c: true}, (item) => {\n *  return item;\n * }), false);\n */\nexport async function forOfEveryAsync(source, iteratee = returnValue, generatorArgs) {\n\tif (isGenerator(source)) {\n\t\tfor await (const item of source(...generatorArgs)) {\n\t\t\tconst result = await iteratee(item, source);\n\t\t\tif (result === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else if (isArray(source) || isSet(source)) {\n\t\tfor (const value of source) {\n\t\t\tconst result = await iteratee(value, source);\n\t\t\tif (result === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const [key, value] of source) {\n\t\t\tconst result = await iteratee(value, key, source);\n\t\t\tif (result === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n","import { everyArray } from '../arrays/every.js';\nimport { everyAsyncArray } from '../arrays/everyAsync.js';\nimport { everyAsyncObject } from '../objects/everyAsync.js';\nimport { everyObject } from '../objects/every.js';\nimport { generateLoop } from './generateLoop.js';\nimport { forOfEvery } from './forOfEvery.js';\nimport { forOfEveryAsync } from './forOfEveryAsync.js';\n/**\n * Iterates through the given object while the iteratee returns true.\n *\n * @function every\n * @category utility\n * @type {Function}\n * @param {Object | Array | Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n * @returns {Boolean} - Returns true if all values returned are true or false if one value returns false.\n *\n * @example\n * import { every, assert } from '@universalweb/acid';\n * assert(every({a: false, b: true, c: true}, (item) => {\n *  return item;\n * }), false);\n */\nexport const every = generateLoop(everyArray, everyAsyncArray, everyObject, everyAsyncObject, forOfEvery, forOfEveryAsync);\n","import { every } from '../utilities/every.js';\n/**\n * Creates a function that checks if all of the predicates return truthy when invoked with the arguments it receives.\n *\n * @function overEvery\n * @category function\n * @type {Function}\n * @param {(Array.<function>|Object.<function>)} predicates - The list of functions to loop through.\n * @returns {Function} - Returns the new overEvery wrapped function.\n *\n * @example\n * import { overEvery, assert } from '@universalweb/acid';\n * assert(overEvery([Boolean, isFinite])('1'), true);\n */\nexport function overEvery(predicates) {\n\treturn (arg) => {\n\t\treturn every(predicates, (predicate) => {\n\t\t\treturn predicate(arg);\n\t\t});\n\t};\n}\n\n","/**\n * Creates a function that invokes method with arguments arranged according to the specified indexes where the argument value at the first index is provided as the first argument, the argument value at the second index is provided as the second argument, and so on.\n *\n * @function reArg\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked.\n * @param {Array} indexes - The arranged argument indexes.\n * @returns {Function} - Returns the new function.\n *\n * @example\n * reArg((a, b, c) => {\n *   return [a, b, c];\n * }, [1,2,0])(1,2,3);\n * // => [2, 3, 1]\n */\nexport function reArg(callable, indexes) {\n\treturn (...args) => {\n\t\treturn callable(...indexes.map((item) => {\n\t\t\treturn args[item];\n\t\t}));\n\t};\n}\n\n","import { truth } from '../utilities/stubTrue.js';\nimport { falsy } from '../utilities/stubFalse.js';\nimport { timer, timers } from '../utilities/timer.js';\n/**\n  * Creates a throttled function that only invokes callable at most once per every milliseconds. The throttle function has a clear method to cancel the timer.\n  *\n  * @function throttle\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {Number} time - The time in milliseconds.\n  * @returns {Function} - The throttled function.\n  *\n  * @example\n  * const throttled = throttle(() => { console.log('throttle'); }, 0)();\n  * throttled();\n  * // 'throttle'\n*/\nexport function throttle(callable, time) {\n\tfunction throttled(...args) {\n\t\tif (throttled.id) {\n\t\t\tthrottled.shouldThrottle = truth;\n\t\t\treturn;\n\t\t}\n\t\tthrottled.callable(...args);\n\t\tthrottled.id = timer(() => {\n\t\t\tif (throttled.shouldThrottle) {\n\t\t\t\tthrottled.callable(...args);\n\t\t\t}\n\t\t\tthrottled.id = falsy;\n\t\t}, time);\n\t}\n\tthrottled.id = falsy;\n\tthrottled.callable = callable.bind(throttled);\n\tthrottled.clear = () => {\n\t\ttimers.remove(throttled.id);\n\t\tthrottled.id = falsy;\n\t};\n\treturn throttled;\n}\n\n","/**\n * Creates a function that provides value to wrapper as its first argument. The wrapper function is given two arguments the value and the provided argument from the newly created function.\n *\n * @function wrap\n * @category function\n * @type {Function}\n * @param {*} value - The value to wrap.\n * @param {Function} wrapper - The wrapper function.\n * @returns {Function} - The new function.\n *\n * @example\n * wrap('Lucy', (firstName, lastName) => {\n *  return `My name is ${firstName} ${lastName}.`;\n * })('Diamonds');\n * // => 'My name is Lucy Diamonds.'\n */\nexport function wrap(value, wrapper) {\n\treturn (...arg) => {\n\t\treturn wrapper(value, ...arg);\n\t};\n}\n\n","/**\n * Determines whether two values are the same value.\n *\n * @function isSame\n * @category object\n * @param {*} source - Value to compare to.\n * @param {*} target - A value to compare.\n * @returns {Boolean} - A Boolean indicating whether or not the two arguments are the same value.\n *\n * @example\n * isSame('foo', 'foo');\n * // => true\n*/\nexport const isSame = Object.is;\n","const functionPrototype = Function.prototype;\n/**\n * Caches a prototype method.\n *\n * @function cacheNativeMethod\n * @category utility\n * @type {Function}\n * @param {Function} method - Prototype method.\n * @returns {Function} - Cached method.\n *\n * @example\n * import { cacheNativeMethod, assert } from '@universalweb/acid';\n * assert(cacheNativeMethod(Array.prototype.push)([], 1), 1);\n */\nexport function cacheNativeMethod(method) {\n\treturn functionPrototype.call.bind(method);\n}\n\n","import { cacheNativeMethod } from '../utilities/cacheNativeMethod.js';\n/**\n * Returns an array of all properties (enumerable or not) found directly upon a given object.\n *\n * @function getPropNames\n * @category object\n * @param {Object} source - The object whose enumerable and non-enumerable own properties are to be returned.\n * @returns {Object} - An array of strings that correspond to the properties found directly upon the given object.\n *\n * @example\n * import { getPropNames, assert } from '@universalweb/acid';\n * assert(getPropNames({ 0: 'a', 1: 'b', 2: 'c' }), ['0', '1', '2']);\n */\nexport const getPropNames = Object.getOwnPropertyNames;\n/**\n * Returns a property descriptor for an own property (that is, one directly present on an object and not in the object's prototype chain) of a given object.\n *\n * @function getPropDesc\n * @category object\n * @param {Object} target - The target object.\n * @param {String} property - The name of the property whose description is to be retrieved.\n * @returns {Object} - A property descriptor of the given property if it exists on the object, undefined otherwise.\n *\n * @example\n * getPropDesc({ bar: 42 }, 'bar');\n * // => { configurable: true, enumerable: true, value: 42, writable: true }\n */\nexport const getPropDesc = Object.getOwnPropertyDescriptor;\n/**\n * Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n *\n * @function defProp\n * @category object\n * @param {Object} target - The object on which to define the property.\n * @param {String} property - The name of the property whose description is to be retrieved.\n * @param {Object} descriptor - The descriptor for the property being defined or modified.\n * @returns {Object} - The object that was passed to the function.\n *\n * @example\n * defProp({}, 'key', {\n *  enumerable: false,\n *  configurable: false,\n *  writable: false,\n *  value: 'static'\n * }).key;\n * // => 'static'\n */\nexport const defProp = Object.defineProperty;\nexport const hasProp = cacheNativeMethod(Object.hasOwnProperty);\n","/**\n * Adds two numbers.\n *\n * @function add\n * @category math\n * @type {Function}\n * @param {Number} augend - First number.\n * @param {Number} addend - Second number which is being added to another (augend).\n * @returns {Number} - Returns the sum of the arguments.\n *\n * @example\n * import { add, assert } from '@universalweb/acid';\n * assert(add(1, 1), 2);\n */\nexport function add(augend, addend) {\n\treturn augend + addend;\n}\n","/**\n *  Decrements a number.\n *\n * @function deduct\n * @category math\n * @type {Function}\n * @param {Number} number - First number.\n * @returns {Number} - Returns a decremented version of the number.\n *\n * @example\n * import { multiply, assert } from '@universalweb/acid';\n * assert(multiply(10, 5), 50);\n * deduct(10);\n * // => 9\n */\nexport function deduct(source) {\n\treturn source - 1;\n}\n","/**\n * Divides two numbers.\n *\n * @function divide\n * @category math\n * @type {Function}\n * @param {Number} number - First number.\n * @param {Number} value - Second number.\n * @returns {Number} - Returns the quotient of the arguments.\n *\n * @example\n * import { divide, assert } from '@universalweb/acid';\n * assert(divide(10, 5), 2);\n */\nexport function divide(source, value) {\n\treturn source / value;\n}\n","/**\n *  Increments a number.\n *\n * @function increment\n * @category math\n * @type {Function}\n * @param {Number} number - First number.\n * @returns {Number} - Returns an incremented version of the number.\n *\n * @example\n * import { multiply, assert } from '@universalweb/acid';\n * assert(multiply(10, 5), 50);\n * increment(10);\n * // => 11\n */\nexport function increment(source) {\n\treturn source + 1;\n}\n","/**\n * Multiplies two numbers.\n *\n * @function multiply\n * @category math\n * @type {Function}\n * @param {Number} number - First number.\n * @param {Number} value - Second number.\n * @returns {Number} - Returns the product of the arguments.\n *\n * @example\n * import { multiply, assert } from '@universalweb/acid';\n * assert(multiply(10, 5), 50);\n */\nexport function multiply(source, value) {\n\treturn source * value;\n}\n","/**\n * Calculate the progress from a given total and current amount.\n *\n * @function calcProgress\n * @category utility\n * @type {Function}\n * @param {Number} total - The total amount.\n * @param {Number} currentAmount - The current amount.\n * @returns {Number} - The progress as a percentage.\n *\n * @example\n * import { calcProgress, assert } from '@universalweb/acid';\n * assert(calcProgress(100, 1), 1);\n */\nexport function calcProgress(total, currentAmount) {\n\tif (total === 0) {\n\t\treturn false;\n\t}\n\tif (currentAmount === 0) {\n\t\treturn 0;\n\t}\n\treturn (currentAmount / total) * 100;\n}\n\n","const { random } = Math;\n/**\n *  Produces a random floating-point number between min (included) and max (excluded). Do not use for security or encryption.\n *\n * @function randomFloat\n * @category math\n * @type {Function}\n * @param {Number} max - Establishes highest possible value for the random number.\n * @param {Number} [min = 0] - Establishes lowest possible value for the random number.\n * @returns {Number} - Returns random integer between the max and min range.\n *\n * @example\n * import { randomFloat, assert } from '@universalweb/acid';\n * assert(randomFloat(10, 0), (value) => { return value > 0 && value < 10;});\n * // => 9.1\n */\nexport function randomFloat(max, min = 0) {\n\treturn random() * (max - min) + min;\n}\n","/**\n *  Extracts the remainder between two numbers.\n *\n * @function remainder\n * @category math\n * @type {Function}\n * @param {Number} number - First number.\n * @param {Number} value - Second number.\n * @returns {Number} - Returns the remainder of the arguments.\n *\n * @example\n * import { multiply, assert } from '@universalweb/acid';\n * assert(multiply(10, 5), 50);\n * remainder(10, 6);\n * // => 4\n */\nexport function remainder(source, value) {\n\treturn source % value;\n}\n","/**\n * Subtract all numbers in the array starting from left to right & return the difference.\n *\n * @function subtractAll\n * @category math\n * @type {Function}\n * @param {Number[]} source - Array of numbers.\n * @returns {Number} - Returns the final difference.\n *\n * @example\n * import { subtractAll, assert } from '@universalweb/acid';\n * assert(subtractAll([10, 1, 2, 3]), 5);\n */\nexport function subtractAll(source) {\n\treturn source.reduce((a, b) => {\n\t\treturn a - b;\n\t}, 0);\n}\n\n","/**\n * Sum all numbers in a given array.\n *\n * @function sumAll\n * @category math\n * @type {Function}\n * @param {Number[]} source - Array of numbers.\n * @returns {Number} - Returns a single number.\n *\n * @example\n * import { sumAll, assert } from '@universalweb/acid';\n * assert(sumAll([10, 1, 2, 3]), 5);\n */\nexport function sumAll(source) {\n\treturn source.reduce((a, b) => {\n\t\treturn a + b;\n\t}, 0);\n}\n\n","/**\n * Checks if a number is within a range.\n *\n * @function isNumberInRange\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @param {Number} start - Beginning of range.\n * @param {Number} end - End of range.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNumberInRange, assert } from '@universalweb/acid';\n * assert(isNumberInRange(1, 0, 2), true);\n * assert(isNumberInRange(1, 2, 5), false);\n */\nexport function isNumberInRange(source, start, end) {\n\treturn source > start && source < end;\n}\n","/**\n * Checks if a number is within a range.\n *\n * @function isNumberNotInRange\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @param {Number} start - Beginning of range.\n * @param {Number} end - End of range.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNumberNotInRange, assert } from '@universalweb/acid';\n * assert(isNumberNotInRange(1, 0, 2), false);\n * assert(isNumberNotInRange(1, 2, 5), true);\n */\nexport function isNumberNotInRange(source, start, end) {\n\treturn source < start || source > end;\n}\n","/**\n * Checks if a number is negative & returns true or false.\n *\n * @function isPositive\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isPositive, assert } from '@universalweb/acid';\n * assert(isPositive(1), true);\n */\nconst { sign } = Math;\nexport function isPositive(source) {\n\treturn sign(source) === 1;\n}\n","/**\n * Strictly checks if a number is zero.\n *\n * @function isZero\n * @category number\n * @type {Function}\n * @param {Number} source - Number to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isZero, assert } from '@universalweb/acid';\n * assert(isZero(0), true);\n */\nexport function isZero(source) {\n\treturn source === 0;\n}\n","import { eachObject } from './each.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { assign } from './assign.js';\n/**\n * Extracts all keys from an object whose values are not null or undefined.\n *\n * @function compactKeys\n * @category object\n * @type {Function}\n * @param {Object} object - Object from which keys are extracted.\n * @returns {Array} - Returns an array of key values.\n *\n * @example\n * import { compactKeys, assert } from '@universalweb/acid';\n * assert(compactKeys({a: 1, b: 0, c: undefined, d: false, e: null}), ['a', 'b', 'd']);\n */\nexport function compactKeys(object) {\n\tconst compactedKeys = [];\n\teachObject(object, (item, key) => {\n\t\tif (hasValue(item)) {\n\t\t\tcompactedKeys.push(key);\n\t\t}\n\t});\n\treturn compactedKeys;\n}\n\n","import { eachAsyncObject } from './eachAsync.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { mapAsyncObject } from './mapAsync.js';\n/**\n * Asynchronously iterates through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function compactMapAsyncObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * import { compactMapAsyncObject, assert } from '@universalweb/acid';\n * assert(await compactMapAsyncObject({a: 1, b: undefined, c: 3}, (item) => {\n *   return item;\n * }), {a: 1, c: 3});\n */\nexport async function compactMapAsyncObject(source, iteratee = returnValue, results = {}) {\n\tawait eachAsyncObject(source, async (item, key, original, propertyCount, objectKeys) => {\n\t\tconst result = await iteratee(item, key, results, original, propertyCount, objectKeys);\n\t\tif (hasValue(result)) {\n\t\t\tresults[key] = result;\n\t\t}\n\t});\n\treturn results;\n}\n","import { eachObject } from './each.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from '../utilities/returnValue.js';\nimport { mapAsyncObject } from './mapAsync.js';\nimport { compactMapAsyncObject } from './compactMapAsync.js';\n/**\n * Iterates through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function compactMapObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * import { compactMapObject, assert } from '@universalweb/acid';\n * assert(compactMapObject({a: 1, b: undefined, c: 3}, (item) => {\n *   return item;\n * }), {a: 1, c: 3});\n */\nexport function compactMapObject(source, iteratee = returnValue, results = {}) {\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tconst result = iteratee(item, key, results, original, propertyCount, objectKeys);\n\t\tif (hasValue(result)) {\n\t\t\tresults[key] = result;\n\t\t}\n\t});\n\treturn results;\n}\n","import { eachObject } from './each.js';\n/**\n * Iterates through the calling object and creates an object with all elements that pass the test implemented by the iteratee.\n *\n * @function filterObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object with properties that passed the test.\n *\n * @example\n * filterObject({a: false, b: true, c: true}, (item) => {\n *   return item;\n * });\n * // => {b: true, c: true}\n */\nexport function filterObject(source, iteratee, results = {}) {\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tif (iteratee(item, key, results, original, propertyCount, objectKeys) === true) {\n\t\t\tresults[key] = item;\n\t\t}\n\t});\n\treturn results;\n}\n","import { eachAsyncObject } from './eachAsync.js';\n/**\n * Iterates through the calling object and creates an object with all elements that pass the test implemented by the iteratee.\n *\n * @function filterAsyncObject\n * @category object\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n * @returns {Object|Function} - An object with properties that passed the test.\n *\n * @example\n * filterAsyncObject({a: false, b: true, c: true}, (item) => {\n *   return item;\n * });\n * // => {b: true, c: true}\n */\nexport async function filterAsyncObject(source, iteratee, results = {}) {\n\tawait eachAsyncObject(source, async (item, key, original, propertyCount, objectKeys) => {\n\t\tif (await iteratee(item, key, results, original, propertyCount, objectKeys) === true) {\n\t\t\tresults[key] = item;\n\t\t}\n\t});\n\treturn results;\n}\n","import { eachObject } from './each.js';\nimport { hasAnyKeys } from './hasKeys.js';\n/**\n * Creates an inverted version of a given object by switching it's keys and values.\n *\n * @function invert\n * @type {Function}\n * @category object\n * @param {Object} source - Object to be inverted.\n * @param {Array} [target = {}] - Empty object to be populated with inverted values from source.\n * @returns {Object} - Returns object with keys and values switched.\n *\n * @example\n * import { invert, assert } from '@universalweb/acid';\n * assert(invert({a:1}), {1:'a'});\n */\nexport function invert(source, target = {}) {\n\tif (!source) {\n\t\treturn;\n\t}\n\teachObject(source, (item, key) => {\n\t\ttarget[item] = key;\n\t});\n\treturn target;\n}\n\n","import { isMatchArray } from '../arrays/isMatch.js';\nimport { everyArray } from '../arrays/every.js';\nimport { keys } from './keys.js';\n/**\n * Performs a shallow strict comparison between two objects.\n *\n * @function isMatchObject\n * @type {Function}\n * @category object\n * @param {Object} source - Source object.\n * @param {Object} target - Object to compare to source.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { assert, isMatchObject } from '@universalweb/acid';\n * assert(isMatchObject({a: 1}, {a: 1}), true);\n */\nexport const isMatchObject = (source, target) => {\n\tif (source === target) {\n\t\treturn true;\n\t}\n\tconst sourceKeys = keys(source);\n\tconst targetKeys = keys(target);\n\tif (sourceKeys.length === targetKeys.length) {\n\t\treturn everyArray(sourceKeys, (key) => {\n\t\t\treturn source[key] === target[key];\n\t\t});\n\t}\n\treturn false;\n};\n\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if the value is a number.\n *\n * @function isNumber\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNumber, assert } from '@universalweb/acid';\n * assert(isNumber(1), true);\n */\nexport const isNumberCall = isConstructorNameFactory('Number');\nexport const isNumber = isTypeFactory(isNumberCall);\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if the value is a RegExp.\n *\n * @function isRegex\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isRegex, assert } from '@universalweb/acid';\n * assert(isRegex(/test/), true);\n */\nexport const isRegexCall = isConstructorNameFactory('RegExp');\nexport const isRegex = isTypeFactory(isRegexCall);\n","/**\n * Returns a regex safe special characters escaped version of a string.\n *\n * @function regexSafe\n * @category regex\n * @type {Function}\n * @param {Object} source - String to make safe.\n * @returns {Object} - Returns a regex safe version of the string.\n *\n * @example\n * import { regexSafe, assert } from '@universalweb/acid';\n * assert(regexSafe(/.+/), '\\/\\.\\+\\/');\n */\nexport const escapeRegexRegex = /[()[\\]{}*+?^$|#.,/\\\\\\s-]/g;\nexport function escapeRegex(source) {\n\treturn source.replace(escapeRegexRegex, '\\\\$&');\n}\n","import { escapeRegex } from './escapeRegex.js';\nimport { mapArray } from '../arrays/map.js';\n/**\n * Convert array of strings to regex.\n *\n * @function arrayToRegex\n * @category regex\n * @type {Function}\n * @param {Object} source - Array of strings.\n * @returns {Object} - Returns a regex safe version of the string.\n *\n * @example\n * import { arrayToRegex, assert } from '@universalweb/acid';\n * assert(String(arrayToRegex(['a','b'])), String(/a|b/));\n */\nexport function arrayToRegex(source, makeSafe) {\n\tif (makeSafe) {\n\t\treturn arrayToRegex(mapArray(source, escapeRegex));\n\t}\n\treturn RegExp(source.join('|'));\n}\n","import { filterObject } from './filter.js';\nimport { isArray } from '../types/isArray.js';\nimport { isString } from '../types/isString.js';\nimport { isNumber } from '../types/isNumber.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isRegex } from '../types/isRegex.js';\nimport { arrayToRegex } from '../regexps/arrayToRegex.js';\n/**\n * Returns a clone of the given object without the given properties.\n *\n * @function omit\n * @category object\n * @type {Function}\n * @param {Object} source - Object from which keys are extracted.\n * @param {Array|RegExp|String} blacklist - List of property keys to omit from the returned object.\n * @returns {Object} - A new object with the removed.\n *\n * @example\n * import { omit, assert } from '@universalweb/acid';\n * assert(omit({a:1, b:2}, ['a']), {b:2});\n * assert(omit({a:1, b:2}, 'a'), {b:2});\n * assert(omit({1:'test', b:2}, 1), {b:2});\n */\nexport function omit(source, blacklist) {\n\tif (!source) {\n\t\treturn;\n\t}\n\tif (isArray(blacklist)) {\n\t\tconst blacklistRegex = arrayToRegex(blacklist);\n\t\treturn filterObject(source, (item, key) => {\n\t\t\treturn !blacklistRegex.test(key);\n\t\t});\n\t}\n\tif (isRegex(blacklist)) {\n\t\treturn filterObject(source, (item, key) => {\n\t\t\treturn !blacklist.test(key);\n\t\t});\n\t}\n\tif (isString(blacklist)) {\n\t\treturn filterObject(source, (item, key) => {\n\t\t\treturn key !== blacklist;\n\t\t});\n\t}\n\tif (isNumber(blacklist)) {\n\t\tconst numberToString = blacklist.toString();\n\t\treturn filterObject(source, (item, key) => {\n\t\t\treturn key !== numberToString;\n\t\t});\n\t}\n\tif (isFunction(blacklist)) {\n\t\treturn filterObject(source, (item, key) => {\n\t\t\treturn !blacklist(item, key);\n\t\t});\n\t}\n}\n\n","import { eachArray } from '../arrays/each.js';\n/**\n  * Returns a clone of the source object with the plucked properties.\n  *\n  * @function pick\n  * @type {Function}\n  * @category object\n  * @param {Object} source - Object to be cloned.\n  * @param {Array} whitelist - Array of property names used to determine what values to pluck.\n  * @param {Object} [target = {}] - Object to be populated with plucked values.\n  * @returns {Object} - A new object with plucked properties.\n  *\n  * @example\n  * pick({a:1, b:2, c:3}, ['a','b']);\n  * // => {a:1, b:2}\n*/\nexport const pick = (source, whitelist, target = {}) => {\n\tif (!source) {\n\t\treturn;\n\t}\n\teachArray(whitelist, (item) => {\n\t\ttarget[item] = source[item];\n\t});\n\treturn target;\n};\n\n","import { keys } from './keys.js';\n/**\n * Returns the amount of keys on the object.\n *\n * @function objectSize\n * @category object\n * @param {Object} source - The source object.\n * @returns {Number} - The amount of keys.\n *\n * @example\n * objectSize({ 0: 'a', 1: 'b', 2: 'c' });\n * // => 3\n*/\nexport function objectSize(source) {\n\tif (!source) {\n\t\treturn;\n\t}\n\treturn keys(source).length;\n}\n","import { eachArray } from '../arrays/each.js';\nimport { eachObject } from './each.js';\n/**\n * Creates an object from two arrays, one of property identifiers and one of corresponding values.\n *\n * @function zipObject\n * @type {Function}\n * @category object\n * @param {Array} properties - The property identifiers.\n * @param {Array} values - The property values.\n * @returns {Object} - Returns the new object.\n *\n * @example\n * zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nexport const zipObject = (properties, values) => {\n\tconst zipedObject = {};\n\teachArray(properties, (item, key) => {\n\t\tzipedObject[item] = values[key];\n\t});\n\treturn zipedObject;\n};\n/**\n * Takes an array of grouped elements and creates an array regrouping the elements to their pre-zip object configuration.\n *\n * @function unZipObject\n * @type {Function}\n * @category object\n * @param {Object} object - The object to process.\n * @returns {Array} - Returns two arrays one of keys and the other of values inside a single array.\n *\n * @example\n * unZipObject({ 'a': 1, 'b': 2 });\n * // => [['a', 'b'], [1, 2]]\n */\nexport const unZipObject = (object) => {\n\tconst unZippedKeys = [];\n\tconst values = [];\n\teachObject(object, (item, key) => {\n\t\tunZippedKeys.push(key);\n\t\tvalues.push(item);\n\t});\n\treturn [unZippedKeys, values];\n};\n\n","const normalizeCase = /[ _-]+/g;\n/**\n * Converts a string into Camel case format.\n *\n * @function camelCase\n * @category string\n * @type {Function}\n * @param {String} source - String to be converted into Camel case.\n * @returns {String} - Converted string in Camel case.\n *\n * @example\n * import { camelCase, assert } from '@universalweb/acid';\n * assert(camelCase('camel case'), 'camelCase');\n */\nexport function camelCase(source) {\n\tlet result = '';\n\tsource.replace(normalizeCase, ' ').trim()\n\t\t.split(' ')\n\t\t.forEach((item, index) => {\n\t\t\tif (index === 0) {\n\t\t\t\tresult += item.toLowerCase();\n\t\t\t} else {\n\t\t\t\tresult += item[0].toUpperCase() + item.slice(1).toLowerCase();\n\t\t\t}\n\t\t});\n\treturn result;\n}\n","const normalizeCase = /[ _-]+/g;\nconst space = /[ ]+/g;\n/**\n * Converts a string into single space sepperated words in Kebab case.\n *\n * @function kebabCase\n * @category string\n * @type {Function}\n * @param {String} source - String to be converted into Kebab case.\n * @returns {String} - Converted string in Kebab case.\n *\n * @example\n * import { kebabCase, assert } from '@universalweb/acid';\n * assert(kebabCase('kebab case'), 'kebab-case');\n */\nexport function kebabCase(source) {\n\treturn source.replace(/([A-Z]+)/g, ' $1')\n\t\t.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toLowerCase()\n\t\t.replace(space, '-');\n}\n\n","const normalizeCase = /[ _-]+/g;\nconst space = /[ ]+/g;\n/**\n * Converts a string into single space sepperated words in snake case.\n *\n * @function snakeCase\n * @category string\n * @type {Function}\n * @param {String} source - String to be converted into snake case.\n * @returns {String} - Converted string in Snake case.\n *\n * @example\n * import { snakeCase, assert } from '@universalweb/acid';\n * assert(snakeCase('snake case'), 'snake_case');\n */\nexport function snakeCase(source) {\n\treturn source.replace(/([A-Z]+)/g, ' $1')\n\t\t.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toLowerCase()\n\t\t.replace(space, '_');\n}\n","const normalizeCase = /[ _-]+/g;\n/**\n * Converts a string into single space sepperated words in uppercase.\n *\n * @function upperCase\n * @category string\n * @type {Function}\n * @param {String} source - String to be converted into upper case.\n * @returns {String} - Converted string in upper case.\n *\n * @example\n * import { upperCase, assert } from '@universalweb/acid';\n * assert(upperCase('upper-case'), 'UPPER CASE');\n * assert(upperCase('upper_case'), 'UPPER CASE');\n */\nexport function upperCase(source) {\n\treturn source\n\t\t.replace(/([A-Z]+)/g, ' $1')\n\t\t.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toUpperCase();\n}\n","const normalizeCase = /[ _-]+/g;\n/**\n * Converts a string into single space sepperated words in lowerCase.\n *\n * @function lowerCase\n * @category string\n * @type {Function}\n * @param {String} source - String to be converted into upper case.\n * @returns {String} - Converted string in upper case.\n *\n * @example\n * import { lowerCase, assert } from '@universalweb/acid';\n * assert(lowerCase('upper-case'), 'upper case');\n * assert(lowerCase('upper_case'), 'upper case');\n */\nexport function lowerCase(source) {\n\treturn source\n\t\t.replace(/([A-Z]+)/g, ' $1')\n\t\t.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toLowerCase();\n}\n","/**\n * Inserts text into a string at a given position.\n *\n * @function insertInRange\n * @category string\n * @type {Function}\n * @param {String} string - String to insert the text into.\n * @param {Number} index - Point of insertion.\n * @param {String} text - The string to be inserted.\n * @returns {String} - The string with the text inserted at the given point.\n *\n * @example\n * import { insertInRange, assert } from '@universalweb/acid';\n * insertInRange('A from Lucy.', 1, ' tab');\n * // => 'A tab from Lucy.'\n */\nexport function insertInRange(string, index, text) {\n\treturn string.slice(0, index) + text + string.slice(index, string.length);\n}\n/**\n * Plucks a letter using the index starting from the right.\n *\n * @function rightString\n * @category string\n * @type {Function}\n * @param {String} string - String to extract the letter from.\n * @param {Number} [index=1] - The starting position.\n * @returns {String} - A letter at the given index.\n *\n * @example\n * import { rightString, assert } from '@universalweb/acid';\n * rightString('rightString');\n * // => 'g'\n * rightString('rightString', 2);\n * // => 'n'\n */\nexport function rightString(string, index = 1) {\n\treturn string[string.length - index];\n}\n/**\n * Splits up a string into chunks.\n *\n * @function chunkString\n * @category string\n * @type {Function}\n * @param {String} string - String to chunked.\n * @param {Number} [size] - The max string length per chunk.\n * @returns {Array} - An array with strings that are <= size parameter.\n *\n * @example\n * import { chunkString, assert } from '@universalweb/acid';\n * chunkString('chunk', 2);\n * // => ['ch', 'un', 'k']\n */\nexport function chunkString(string, size) {\n\treturn string.match(new RegExp(`(.|[\\r\\n]){1,${size}}`, 'g'));\n}\n/**\n * Truncates everything before the index starting from the right.\n *\n * @function initialString\n * @category string\n * @type {Function}\n * @param {String} string - String to extract the initial letters from.\n * @param {Number} [index=1] - Starting point from the right.\n * @returns {String} - A string with the characters before the index starting from the right.\n *\n * @example\n * import { initialString, assert } from '@universalweb/acid';\n * initialString('initialString');\n * // => 'initialStrin'\n * initialString('initialString', 2);\n * // => 'initialStri'\n */\nexport function initialString(string, index = 1) {\n\treturn string.slice(0, index * -1);\n}\n/**\n * Truncates everything after a index.\n *\n * @function restString\n * @category string\n * @type {Function}\n * @param {String} string - String to extract the rest of the letters from.\n * @param {Number} [index=1] - Starting point.\n * @returns {String} - A string without the characters up-to to the index.\n *\n * @example\n * import { restString, assert } from '@universalweb/acid';\n * restString('restString');\n * // => 'estString'\n * restString('restString', 2);\n * // => 'stString'\n */\nexport function restString(string, index = 1) {\n\treturn string.substr(index);\n}\n\n","/**\n * Replaces all occurrences of strings in an array with a value.\n *\n * @function replaceList\n * @category string\n * @type {Function}\n * @param {String} string - String to be replaced.\n * @param {Array} words - Strings to replace.\n * @param {String} value - The match replacement.\n * @returns {String} - The string with the replacement.\n *\n * @example\n * import { replaceList, assert } from '@universalweb/acid';\n * replaceList('Her name was user.', ['user'], 'Lucy');\n * // => 'Her name was Lucy.'\n */\nexport function replaceList(string, words, value) {\n\treturn string.replace(new RegExp(`\\\\b${words.join('|')}\\\\b`, 'gi'), value);\n}\n\n","const rawURLDecodeRegex = /%(?![\\da-f]{2})/gi;\nconst andRegex = /&/g;\nconst lessThanRegex = /</g;\nconst moreThanRegex = />/g;\nconst doubleQuoteRegex = /\"/g;\n/**\n * Raw URL decoder.\n *\n * @function rawURLDecode\n * @category string\n * @type {Function}\n * @param {String} string - String to be replaced.\n * @returns {String} - Converted string into the decoded URI Component .\n *\n * @example\n * import { rawURLDecode, assert } from '@universalweb/acid';\n * rawURLDecode('Lucy%20saw%20diamonds%20in%20the%20sky.');\n * // => 'Lucy saw diamonds in the sky.'\n */\nexport function rawURLDecode(string) {\n\treturn decodeURIComponent(string.replace(rawURLDecodeRegex, () => {\n\t\treturn '%25';\n\t}));\n}\n/**\n * Replaced sensitive characters with their matching html entity.\n *\n * @function htmlEntities\n * @category string\n * @type {Function}\n * @param {String} string - String to be replaced.\n * @returns {String} - Replaced string.\n *\n * @example\n * import { htmlEntities, assert } from '@universalweb/acid';\n * htmlEntities(`<script>console.log('Lucy & diamonds.')</script>`);\n * // => `&lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;`\n */\nexport function htmlEntities(string) {\n\treturn string.replace(andRegex, '&amp;')\n\t\t.replace(lessThanRegex, '&lt;')\n\t\t.replace(moreThanRegex, '&gt;')\n\t\t.replace(doubleQuoteRegex, '&quot;');\n}\n/**\n * Executes rawURLDecode followd by htmlEntities methods on a string.\n *\n * @function sanitize\n * @category string\n * @type {Function}\n * @param {String} string - String to be replaced.\n * @returns {String} - Replaced string.\n *\n * @example\n * import { sanitize, assert } from '@universalweb/acid';\n * sanitize(`<script>console.log('Lucy%20&%20diamonds.')</script>`);\n * // => `&lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;`\n */\nexport function sanitize(string) {\n\treturn htmlEntities(rawURLDecode(string));\n}\n\n","const tokenizeRegEx = /\\S+/g;\nconst wordsRegEx = /\\w+/g;\n/**\n * Break string by non-white space characters matches.\n *\n * @function tokenize\n * @type {Function}\n * @category string\n * @param {String} string - String to be broken up.\n * @returns {Array} - Array of words without white space characters.\n *\n * @example\n * import { tokenize, assert } from '@universalweb/acid';\n * tokenize('I am Lucy!');\n * // => [\"I\", \"am\", \"Lucy!\"]\n */\nexport function tokenize(string) {\n\treturn string.match(tokenizeRegEx) || [];\n}\n/**\n * Break string into word matches.\n *\n * @function words\n * @type {Function}\n * @param {String} string - String to be broken up.\n * @returns {Array} - Array of words with word characters only.\n *\n * @example\n * import { words, assert } from '@universalweb/acid';\n * words('I am Lucy!');\n * // => [\"I\", \"am\", \"Lucy\"]\n */\nexport function words(string) {\n\treturn string.match(wordsRegEx) || [];\n}\n\n","const truncateDown = (string, maxLength, stringLength) => {\n\tconst breakAll = string.split('');\n\tconst breakAllLength = breakAll.length;\n\tlet item;\n\tlet index = stringLength - maxLength;\n\tfor (; index < breakAllLength && index >= 0; index--) {\n\t\titem = breakAll[index];\n\t\tif (item === ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string.slice(0, index).trim();\n};\nconst truncateUp = (string, maxLength, stringLength) => {\n\tconst breakAll = string.split('');\n\tconst breakAllLength = breakAll.length;\n\tlet item;\n\tlet index = maxLength;\n\tfor (; index < breakAllLength && index > 0; index++) {\n\t\titem = breakAll[index];\n\t\tif (item === ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string.substr(index, stringLength).trim();\n};\n/**\n * Truncates the string, accounting for word placement and character count.\n *\n * @function truncate\n * @type {Function}\n * @category string\n * @param {String} string - String to be truncated.\n * @param {Number} maxLength - The desired max length of the string.\n * @returns {String} - The mutated string.\n *\n * @example\n * import { truncate, assert } from '@universalweb/acid';\n * truncate('Where is Lucy?', 2);\n * // => 'Where is'\n */\nexport function truncate(string, maxLength) {\n\tconst stringLength = string.length;\n\treturn (stringLength > maxLength) ? truncateDown(string, maxLength, stringLength) : string;\n}\n/**\n * Truncates the string, accounting for word placement and character count from the right.\n *\n * @function truncateRight\n * @type {Function}\n * @category string\n * @param {String} string - String to be truncated.\n * @param {Number} maxLength - The desired max length of the string.\n * @returns {String} - The mutated string.\n *\n * @example\n * import { truncateRight, assert } from '@universalweb/acid';\n * truncateRight('Where is Lucy?', 6);\n * // => 'Lucy?'\n */\nexport function truncateRight(string, maxLength) {\n\tconst stringLength = string.length;\n\treturn (stringLength > maxLength) ? truncateUp(string, maxLength, stringLength) : string;\n}\n\n","import { restString } from './range.js';\nconst spaceFirstLetter = / (.)/g;\n/**\n * Returns the first letter capitalized.\n *\n * @function upperFirstLetter\n * @type {Function}\n * @category string\n * @param {String} string - String to extract first letter from.\n * @returns {String} - An upper case letter.\n *\n * @example\n * import { upperFirstLetter, assert } from '@universalweb/acid';\n * upperFirstLetter('upper');\n * // => \"U\"\n */\nexport function upperFirstLetter(string) {\n\treturn string[0].toUpperCase();\n}\n/**\n * Capitalizes the first letter.\n *\n * @function upperFirst\n * @type {Function}\n * @category string\n * @param {String} string - String to be mutated.\n * @returns {String} - String with first letter capitalized.\n *\n * @example\n * import { upperFirst, assert } from '@universalweb/acid';\n * upperFirst('upper');\n * // => 'Upper'\n */\nexport function upperFirst(string) {\n\treturn upperFirstLetter(string) + restString(string);\n}\n/**\n * Capitalize all first letters.\n *\n * @function upperFirstAll\n * @type {Function}\n * @category string\n * @param {String} string - String to be mutated.\n * @returns {String} - String with all first letters capitalized.\n *\n * @example\n * import { upperFirstAll, assert } from '@universalweb/acid';\n * upperFirstAll('Lucy is next up.');\n * // => 'Lucy Is Next Up.'\n */\nexport function upperFirstAll(string) {\n\treturn string.replace(spaceFirstLetter, (match) => {\n\t\treturn match.toUpperCase();\n\t});\n}\n/**\n * Capitalize first letter and lower case the rest.\n *\n * @function upperFirstOnly\n * @type {Function}\n * @category string\n * @param {String} string - String to be mutated.\n * @returns {String} - String with first letter capitalized.\n *\n * @example\n * import { upperFirstOnly, assert } from '@universalweb/acid';\n * upperFirstOnly('LYSERGIC ACID DIETHYLAMIDE');\n * // => 'Lysergic namespace diethylamide'\n */\nexport function upperFirstOnly(string) {\n\treturn upperFirstLetter(string) + restString(string).toLowerCase();\n}\n/**\n * Capitalize all first letters and lower case the rest.\n *\n * @function upperFirstOnlyAll\n * @type {Function}\n * @category string\n * @param {String} string - String to be mutated.\n * @returns {String} - String with all first letters capitalized.\n *\n * @example\n * import { upperFirstOnlyAll, assert } from '@universalweb/acid';\n * upperFirstOnlyAll('LYSERGIC ACID DIETHYLAMIDE');\n * // => 'Lysergic Acid Diethylamide'\n */\nexport function upperFirstOnlyAll(string) {\n\treturn upperFirstOnly(string.toLowerCase()).replace(spaceFirstLetter, (match) => {\n\t\treturn match.toUpperCase();\n\t});\n}\n\n","import { getType } from './getType.js';\n/**\n * Returns the constructor name of an object.\n *\n * @function getTypeName\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { getTypeName, assert } from '@universalweb/acid';\n * assert(getTypeName(1), true);\n */\nexport function getTypeName(source) {\n\treturn getType(source)?.name;\n}\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if the value is an Arguments object.\n *\n * @function isArguments\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isArguments, assert } from '@universalweb/acid';\n * assert(isArguments((function() { return arguments;})()), true);\n * assert(isArguments([]), false);\n */\nconst objectArguments = '[object Arguments]';\nexport function isArguments(source) {\n\treturn (hasValue(source)) ? source.toString() === objectArguments : false;\n}\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if an object is null or undefined.\n *\n * @function noValue\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { noValue, assert } from '@universalweb/acid';\n * assert(noValue(null), true);\n * assert(noValue(undefined), true);\n * assert(noValue(1), false);\n * assert(noValue(0), false);\n */\nexport function noValue(source) {\n\treturn !hasValue(source);\n}\n","import { hasValue } from './hasValue.js';\nimport { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Map.\n *\n * @function isMap\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isMap } from '@universalweb/acid';\n * isMap(new Map());\n * // => true\n */\nexport const isMapCall = isConstructorNameFactory('Map');\nexport const isMap = isTypeFactory(isMapCall);\n","import { getTypeName } from './getTypeName.js';\n/**\n * Checks if an object is a TypedArray. A TypedArray object is an array-like view of an underlying binary data buffer.\n *\n * @function isTypedArray\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isTypedArray, assert } from '@universalweb/acid';\n * assert(isTypedArray([]), false);\n * assert(isTypedArray(new Int8Array()), true);\n */\nconst typedArrayRegex = /Array/;\nconst arrayConstructorName = 'Array';\nexport function isTypedArray(source) {\n\tif (source) {\n\t\tconst constructorName = getTypeName(source);\n\t\tif (typedArrayRegex.test(constructorName) && constructorName !== arrayConstructorName) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n","import { isNumber } from './isNumber.js';\nimport { noValue } from './noValue.js';\nimport { isFunction } from './isFunction.js';\nimport { hasProp } from '../internal/object.js';\nimport { every } from '../utilities/every.js';\nimport { keys } from '../objects/keys.js';\nimport { isArray } from './isArray.js';\nimport { isMap } from './isMap.js';\nimport { isTypedArray } from './isTypedArray.js';\n/**\n * Checks if an object has a .length property that's greater than or equal to 0 & is not a function. If strict is enabled it will check to see if there is an item returned in range of the number returned bu the length property.\n *\n * @function isArrayLike\n * @category type\n * @param {*} source - Object to be checked.\n * @param {*} strictFlag - Strict flag to also check to see if keys are whole intigers greater than or equal to 0.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isArrayLike, assert } from '@universalweb/acid';\n * assert(isArrayLike([]), true);\n * assert(isArrayLike(2), false);\n */\nexport function isArrayLike(source, strictFlag) {\n\tif (noValue(source) || isFunction(source)) {\n\t\treturn false;\n\t}\n\tif (isArray(source) || isTypedArray(source)) {\n\t\treturn true;\n\t}\n\tconst sourceLength = source.length;\n\tif (!noValue(sourceLength) || !isNumber(sourceLength) || sourceLength < 0) {\n\t\treturn false;\n\t}\n\tif (strictFlag) {\n\t\tconst indexes = keys(source);\n\t\tif (indexes) {\n\t\t\treturn every(indexes, (value, index) => {\n\t\t\t\treturn index >= 0 && isNumber(index);\n\t\t\t});\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a BigInt.\n *\n * @function isBigInt\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isBigInt, assert } from '@universalweb/acid';\n * assert(isBigInt(BigInt(123)), true);\n */\nexport const isBigIntCall = isConstructorNameFactory('BigInt');\nexport const isBigInt = isTypeFactory(isBigIntCall);\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if the value is a Boolean.\n *\n * @function isBoolean\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isBoolean } from '@universalweb/acid';\n * isBoolean(true);\n * // => true\n */\nexport const isBooleanCall = isConstructorNameFactory('Boolean');\nexport const isBoolean = isTypeFactory(isBooleanCall);\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a ArrayBuffer.\n *\n * @function isArrayBuffer\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isArrayBuffer, assert } from '@universalweb/acid';\n * assert(isArrayBuffer(new ArrayBuffer()), true);\n */\nexport const isArrayBufferCall = isConstructorNameFactory('ArrayBuffer');\nexport const isArrayBuffer = isTypeFactory(isArrayBufferCall);\n","/**\n * Checks if an object is the child of another. Typically used for classes.\n *\n * @function isChild\n * @category type\n * @param {*} sourceChild - Object to be checked as the child.\n * @param {*} targetParent - Object to be checked as the parent.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isChild, construct, assert } from '@universalweb/acid';\n * class Grandparent{}\n * class Parent extends Grandparent{}\n * class Child extends Parent{}\n * const child = construct(Child);\n * assert(isChild(Child, Grandparent), true);\n * assert(isChild(Child, Parent), false);\n * assert(isChild(Parent, Grandparent), false);\n * assert(isChild(child1, child3), false);\n */\nexport function isChild(sourceChild, targetParent) {\n\tif (!sourceChild || !targetParent) {\n\t\treturn false;\n\t}\n\treturn sourceChild instanceof targetParent;\n}\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if an object or objects are a structured-cloneable type.\n *\n * @function isCloneable\n * @category type\n * @param {...*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isCloneable, assert } from '@universalweb/acid';\n * assert(isCloneable(function (){}), false);\n */\nconst constructorNames = RegExp('Array|ArrayBuffer|Boolean|DataView|Date|Map|Object|Boolean|Number|BigInt|String|RegExp|Set|Error|EvalError|RangeError|ReferenceError|SyntaxError|TypeError|URIError');\nexport function isCloneable(source) {\n\tif (hasValue(source)) {\n\t\tconst constructorName = source?.constructor?.name;\n\t\treturn constructorNames.test(constructorName);\n\t}\n\treturn false;\n}\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if the value is a Date.\n *\n * @function isDate\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isDate, assert } from '@universalweb/acid';\n * assert(isDate(new Date()), true);\n */\nexport const isDateCall = isConstructorNameFactory('Date');\nexport const isDate = isTypeFactory(isDateCall);\n","import { isString } from './isString.js';\nimport { isArray } from './isArray.js';\nimport { isPlainObject } from './isPlainObject.js';\nimport { hasLength } from '../utilities/hasLength.js';\nimport { objectSize } from '../objects/size.js';\nimport { hasValue } from './hasValue.js';\n/**\n * Checks if the value is empty.\n *\n * @function isEmpty\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isEmpty, assert } from '@universalweb/acid';\n * assert(isEmpty([]), true);\n */\nexport function isEmpty(source) {\n\tif (isString(source) || isArray(source)) {\n\t\treturn !hasLength(source);\n\t} else if (isPlainObject(source)) {\n\t\treturn !objectSize(source);\n\t}\n\treturn !hasValue(source);\n}\n","/**\n * Check if a value equals false using strict comparison.\n *\n * @function isFalse\n * @category Utility\n * @type {Function}\n * @param {Boolean} source - Item to compare.\n * @returns {Boolean} - Returns true if the item equals false.\n *\n * @example\n * import { isFalse, assert } from '@universalweb/acid';\n * assert(isFalse(1), false);\n * assert(isFalse(true), false);\n * assert(isFalse(false), true);\n */\nexport function isFalse(source) {\n\treturn source === false;\n}\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Float32Array.\n *\n * @function isF32\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isF32, assert } from '@universalweb/acid';\n * assert(isF32(new Float32Array()), true);\n */\nexport const isF32Call = isConstructorNameFactory('Float32Array');\nexport const isF32 = isTypeFactory(isF32Call);\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Float64Array.\n *\n * @function isF64\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isF64 } from '@universalweb/acid';\n * isF64(new Float64Array());\n * // => true\n */\nexport const isF64Call = isConstructorNameFactory('Float64Array');\nexport const isF64 = isTypeFactory(isF64Call);\n","const { isInteger } = Number;\n/**\n * Checks if the value (typically a number) as a string has a decimal point. Alias of Number.isInteger.\n *\n * @function isFloat\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isFloat } from '@universalweb/acid';\n * isFloat(1.01);\n * // => true\n */\nexport const isFloat = isInteger;\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Int16Array.\n *\n * @function isI16\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isI16 } from '@universalweb/acid';\n * isI16(new Int16Array());\n * // => true\n */\nexport const isI16Call = isConstructorNameFactory('Int16Array');\nexport const isI16 = isTypeFactory(isI16Call);\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Int32Array.\n *\n * @function isI32\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * import { isI32, assert } from '@universalweb/acid';\n * assert(isI32(new Int32Array()), true);.\n */\nexport const isI32Call = isConstructorNameFactory('Int32Array');\nexport const isI32 = isTypeFactory(isI32Call);\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Int8Array.\n *\n * @function isI8\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isInt8 } from '@universalweb/acid';\n * isInt8(new Int8Array());\n * // => true\n */\nexport const isI8Call = isConstructorNameFactory('Int8Array');\nexport const isI8 = isTypeFactory(isI8Call);\n","import { hasValue } from './hasValue.js';\n/**\n * Checks if the object has inherited properties from the built-in Iterator class and which implements the Symbol.iterator interface. Built-in Iterators: String, Array, TypedArray, Map, Set, and Segments.\n *\n * @function isIterable\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isIterable, assert } from '@universalweb/acid';\n * assert(isIterable([]), true);\n * assert(isIterable(new Int8Array()), true);\n * assert(isIterable('test'), false);\n */\nexport function isIterable(source) {\n\treturn hasValue(source) && typeof source[Symbol.iterator] === 'function';\n}\n","/**\n * Checks if an object is a promise.\n *\n * @function isPromise\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - True or false.\n *\n * @example\n * import { isPromise } from '@universalweb/acid';\n * isPromise(new Promise(() => {}));\n * // => true\n */\nexport function isPromise(source) {\n\tif (source) {\n\t\treturn source instanceof Promise;\n\t}\n\treturn false;\n}\n","import { isPromise } from './isPromise.js';\nimport { isGenerator } from './isGenerator.js';\nimport { isAsync } from './isAsync.js';\n/**\n * Checks if an object is a kind of async object such as async function, promise, or generator.\n *\n * @function isKindAsync\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - True or false.\n *\n * @example\n * import { isKindAsync, assert } from '@universalweb/acid';\n * assert(isKindAsync(async() => {}), true);\n */\nexport function isKindAsync(source) {\n\tif (source) {\n\t\treturn isPromise(source) || isAsync(source) || isGenerator(source);\n\t}\n\treturn false;\n}\n","/**\n * Checks if an object is the child of another. Typically used for classes.\n *\n * @function isParent\n * @category type\n * @param {*} sourceParent - Object to be checked as the child.\n * @param {*} targetChild - Object to be checked as the parent.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isParent, construct, assert } from '@universalweb/acid';\n * class parentClass{}\n * class otherClass{}\n * const child1 = construct(parentClass);\n * const child2 = construct(otherClass);\n * assert(isParent(child1, parentClass), true);\n * assert(isParent(child3, parentClass), false);\n * assert(isParent(parentClass, child1), false);\n * assert(isParent(child1, child3), false);\n */\nexport function isParent(sourceParent, targetChild) {\n\tif (!sourceParent || !targetChild || !targetChild.call) {\n\t\treturn false;\n\t}\n\treturn sourceParent instanceof targetChild;\n}\n","/**\n * Checks if an object is a primitive.\n *\n * @function isPrimitive\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - True or false.\n *\n * @example\n * import { isPrimitive, assert } from '@universalweb/acid';\n * assert(isPrimitive(1), true);\n * assert(isPrimitive(() => {}), false);\n */\nexport function isPrimitive(source) {\n\tconst type = typeof value;\n\treturn source === null || source === undefined || (type !== 'object' && type !== 'function');\n}\n","import { noValue } from './noValue.js';\n/**\n * Checks if objects are related to each other using instanceof. There is no required order for arguments given it will check all available ways.\n *\n * @function isRelated\n * @category type\n * @param {*} targetOne - Object to be checked.\n * @param {*} targetTwo - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isRelated, construct, assert } from '@universalweb/acid';\n * class parentClass{}\n * class otherClass{}\n * const child1 = construct(parentClass);\n * const child2 = construct(parentClass);\n * const child3 = construct(otherClass);\n * assert(isRelated(child1, child2), true);\n * assert(isRelated(child1, parentClass), true);\n * assert(isRelated(parentClass, child2), true);\n * assert(isRelated(child1, child3), false);\n */\nexport function isRelated(targetOne, targetTwo) {\n\tif (noValue(targetOne) || noValue(targetTwo)) {\n\t\treturn false;\n\t}\n\tif (targetOne.call) {\n\t\treturn targetTwo instanceof targetOne;\n\t}\n\tif (targetTwo.call) {\n\t\treturn targetOne instanceof targetTwo;\n\t}\n\treturn targetTwo.constructor === targetOne.constructor;\n}\n","const { isSafeInteger } = Number;\n/**\n * Checks if the value (typically a number) as a string has a decimal point. Alias of Number.isInteger.\n *\n * @function isSafeInt\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isSafeInt } from '@universalweb/acid';\n * isSafeInt(1.01);\n * // => true\n */\nexport const isSafeInt = isSafeInteger;\n","import { getType } from './getType.js';\nexport function isSameType(source, other) {\n\tconst sourceType = getType(source);\n\tconst otherType = getType(other);\n\tif (sourceType === otherType) {\n\t\tif (sourceType.name === otherType.name) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n","/**\n * Check if a value equals true using strict comparison.\n *\n * @function isTrue\n * @category Utility\n * @type {Function}\n * @param {Boolean} source - Item to check.\n * @returns {Boolean} - Returns true if the item is true.\n *\n * @example\n * import { isTrue, assert } from '@universalweb/acid';\n * assert(isTrue(1), false);\n * assert(isTrue(true), true);\n * assert(isTrue(false), false);\n */\nexport function isTrue(source) {\n\treturn source === true;\n}\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Uint16Array.\n *\n * @function isU16\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isU16 } from '@universalweb/acid';\n * isU16(new Uint16Array());\n * // => true\n */\nexport const isU16Call = isConstructorNameFactory('Uint16Array');\nexport const isU16 = isTypeFactory(isU16Call);\n","import { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Uint32Array.\n *\n * @function isU32\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isU32 } from '@universalweb/acid';\n * isU32(new Uint32Array());\n * // => true\n */\nexport const isU32Call = isConstructorNameFactory('Uint32Array');\nexport const isU32 = isTypeFactory(isU32Call);\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Uint8Array.\n *\n * @function isU8\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isU8 } from '@universalweb/acid';\n * isU8(new Uint8Array());\n * // => true\n */\nexport const isU8Call = isConstructorNameFactory('Uint8Array');\nexport const isU8 = isTypeFactory(isU8Call);\n","import { isConstructorFactory, isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a Uint8ClampedArray.\n *\n * @function isU8C\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isU8C } from '@universalweb/acid';\n * isU8C(new Uint8ClampedArray());\n * // => true\n */\nexport const isU8CCall = isConstructorNameFactory('Uint8ClampedArray');\nexport const isU8C = isTypeFactory(isU8CCall);\n","import { hasValue } from './hasValue.js';\nimport { isConstructorNameFactory } from './isConstructor.js';\nimport { isTypeFactory } from './isTypeFactory.js';\n/**\n * Checks if an object or objects are a WeakMap.\n *\n * @function isWeakMap\n * @category type\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isWeakMap } from '@universalweb/acid';\n * assert(isWeakMap(new WeakMap()), true);\n */\nexport const isWeakMapCall = isConstructorNameFactory('WeakMap');\nexport const isWeakMap = isTypeFactory(isWeakMapCall);\n","export const isDeno = typeof globalThis.Deno !== 'undefined';\n","export const isNodejs = typeof globalThis.process !== 'undefined' && process.versions && process.versions.node;\n","/**\n * Check if a value is isTruthy which is anything but false, null, 0, \"\", undefined, and NaN.\n *\n * @function isTruthy\n * @category type\n * @type {Function}\n * @param {*} source - Item to be isTruthy checked.\n * @param {*} [returnIfTrue = true] - Item to be returned if item is isTruthy.\n * @returns {Boolean|*} - Returns true if the item is isTruthy or returnIfTrue if provided otherwise returns false.\n *\n * @example\n * import { isTruthy, assert } from '@universalweb/acid';\n * assert(isTruthy(1), true);\n * assert(isTruthy(0), false);\n */\nexport function isTruthy(source, returnIfTrue = true) {\n\treturn Boolean(source) && returnIfTrue;\n}\n","/**\n * Check if a value is isFalsy which are false, null, 0, \"\", undefined, and NaN.\n *\n * @function isFalsy\n * @category type\n * @type {Function}\n * @param {*} source - Item to be isFalsy checked.\n * @param {*} [returnIfTrue = true] - Item to be returned if item is isFalsy.\n * @returns {Boolean|*} - Returns true if the item is isFalsy or returnIfTrue if provided otherwise returns false.\n *\n * @example\n * import { isFalsy, assert } from '@universalweb/acid';\n * assert(isFalsy(0), true);\n * assert(isFalsy(1), false);\n */\nexport function isFalsy(source, returnIfTrue = true) {\n\treturn Boolean(source) === false && returnIfTrue;\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { apply } from '../internal/apply.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\n/**\n * If source has a value then assign it to an object or call a function.\n *\n * @function ifValue\n * @category utility\n * @param {*} source - The source object to be hasValue checked.\n * @param {Function|Object} target - The target which is either a function or object.\n * @param {*|String} optional - If target is a plain object then it must be a string and is used to assign the property name. Else it's used as the this for the provided function (target).\n * @param {Array} args - The args that would be used if the target is a function and is the params that is applied to the function.\n * @returns {source} The source object if it passes the hasValue check.\n *\n * @example\n * import { ifValue, assert } from '@universalweb/acid';\n * assert(ifValue(1, {}, 'a'), {a:1});\n */\nexport function ifValue(source, target, optional, args) {\n\tif (hasValue(source)) {\n\t\tif (isFunction(target)) {\n\t\t\tif (optional) {\n\t\t\t\treturn apply(target, optional, args);\n\t\t\t}\n\t\t\treturn target(...args);\n\t\t} else if (isPlainObject(target)) {\n\t\t\ttarget[optional] = source;\n\t\t\treturn target;\n\t\t}\n\t}\n}\n","import { isEqual } from './isEqual.js';\nimport { isFalse } from '../types/isFalse.js';\n/**\n * Performs a deep comparison between two objects & determines if they're different using strict comparison.\n *\n * @function notEqual\n * @type {Function}\n * @category utility\n * @param {*} source - Source object.\n * @param {*} target - Object to be compared.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { notEqual, assert } from '@universalweb/acid';\n * assert(notEqual({a: [1,2,3]}, {a: [1,3,3]}), true);\n */\nexport function notEqual(source, target) {\n\treturn isFalse(isEqual(source, target));\n}\n\n","const jsonNative = JSON;\n/**\n * Parses JSON string with safety check for undefined.\n *\n * @function jsonParse\n * @category utility\n * @type {Function}\n * @param {String} source - String to be parsed.\n * @param {Function} reviver - A function that prescribes how each value originally produced by parsing is transformed before being returned.\n * @returns {Object} - Returns the parsed object.\n *\n * @example\n * import { jsonParse, assert } from '@universalweb/acid';\n * assert(jsonParse('{a:1}'), {a:1});\n */\nexport function jsonParse(source, reviver) {\n\tif (source) {\n\t\treturn jsonNative.parse(source, reviver);\n\t}\n}\n/**\n * Stringify an object into a JSON string.\n *\n * @function stringify\n * @category utility\n * @type {Function}\n * @param {Object} object - Object to Stringify.\n * @returns {String} - Returns the object as a valid JSON string.\n *\n * @example\n * import { stringify, assert } from '@universalweb/acid';\n * assert(stringify({a:1}), '{a:1}');\n */\nexport const stringify = jsonNative.stringify;\n\n","import { isFunction } from '../types/isFunction.js';\nimport { notEqual } from './notEqual.js';\nimport { stringify } from './json.js';\nfunction createAssertError(source, expected, localOptions) {\n\tconst options = globalThis.options || localOptions;\n\tlet errorTitle;\n\tif (isFunction(options)) {\n\t\terrorTitle = `${options.name} : ${options.constructor.name}`;\n\t} else if (options) {\n\t\terrorTitle = `${options.title || options.method.name} -> ${options.file}`;\n\t}\n\treturn new Error(`Test Failed: ${errorTitle}\n\t\tResult: ${stringify(source)}\n\t\tExpected: ${stringify(expected)}`, options);\n}\n/**\n * Check if source value matches the expected value.\n *\n * @function assert\n * @category utility\n * @type {Function}\n * @param {*} source - The source object to compare to.\n * @param {*} expected - The expected result that's compared to the source.\n * @param {*} options - Additional options for the Error instance & unit test information.\n * @returns {Object} - Returns a deep clone of an object.\n *\n * @example\n * import { assert } from '@universalweb/acid';\n * if (!assert(1,1)) {\n * \tnew Error('Assert Method Failed');\n * }\n */\nexport function assert(source, expected, options) {\n\tconst expectedFunction = isFunction(expected) && expected(source, options) === false;\n\tif (expectedFunction || notEqual(source, expected)) {\n\t\treturn createAssertError(source, expected, options);\n\t}\n\treturn true;\n}\n","import { isFunction } from '../types/isFunction.js';\nimport { assign } from '../objects/assign.js';\nimport { map } from './map.js';\nimport { assert } from './assert.js';\n/**\n * Loops through an object or an array and binds the given object to all functions encountered. Optionally accepts an object which to assign the newly bound functions to.\n *\n * @function bindAll\n * @category utility\n * @type {Function}\n * @param {Object|Function|Array} collection - The functions to bind.\n * @param {*} bindThis - Object to be bound to functions.\n * @param {Object|Function|Array} targetAssign - Object to assign newly bound functions to.\n * @returns {Object|Function|Array} - Returns the collection of bound functions or the assign target provided.\n *\n * @example\n * import { assert, bindAll } from '@universalweb/acid';\n * const bounded = bindAll([function () { return this;}], 'Bounded');\n * assert(bounded[0](), 'Bounded');\n */\nexport function bindAll(collection, bindThis, targetAssign) {\n\tconst results = map(collection, (item) => {\n\t\treturn isFunction(item) ? item.bind(bindThis) : item;\n\t});\n\treturn (targetAssign) ? assign(targetAssign, results) : results;\n}\n\n","import { isBuffer } from '../types/isBuffer.js';\nimport { isArray } from '../types/isArray.js';\nimport { clearBuffer } from '../buffers/clear.js';\nimport { clearArray } from '../arrays/clear.js';\n/**\n * Clears the values out of an array, buffer, and objects like Map that have a clear method.\n *\n * @function clear\n * @category utility\n * @type {Function}\n * @param {Array} source - Takes an array to be emptied.\n * @returns {Array} - The originally given array.\n *\n * @example\n * import { clear, assert } from '@universalweb/acid';\n * assert(clear(Buffer.from([1,'B', 'Cat'])), []);\n */\nexport function clear(source) {\n\tif (source) {\n\t\tif (isBuffer(source)) {\n\t\t\treturn clearBuffer(source);\n\t\t} else if (isArray(source)) {\n\t\t\treturn clearArray(source);\n\t\t} else if (source.clear) {\n\t\t\tsource.clear();\n\t\t} else if (source.length) {\n\t\t\tsource.length = 0;\n\t\t}\n\t}\n\treturn source;\n}\n\n","/**\n * Creates a structured clone of an object which is a \"structured-cloneable type\".\n *\n * @function clone\n * @category utility\n * @type {Function}\n * @param {Object} source - Any structured-cloneable type object.\n * @returns {Object} - Returns a deep clone of an object.\n *\n * @example\n * import { clone, assert } from '@universalweb/acid';\n * assert(clone({a:{b:[2]}}), {a:{b:[2]}});\n */\nconst structuredCloneSafe = globalThis.structuredClone;\nexport function clone(source) {\n\treturn structuredCloneSafe(source);\n}\n\n","import { isPlainObject } from '../types/isPlainObject.js';\nimport { keys } from '../objects/keys.js';\nimport { isTruthy } from '../types/isTruthy.js';\n/**\n * Creates an array with all isFalsy values removed. The values false, null, 0, \"\", undefined, and NaN are isFalsy.\n *\n * @function compact\n * @category Utility\n * @type {Function}\n * @param {Array|Object} source - Array or Object to be compacted.\n * @returns {Array|Object} - A new object or array containing the filtered values.\n *\n * @example\n * import { compact, assert } from '@universalweb/acid';\n * assert(compact([1,'B', 'Cat', false, null, 0 , '', undefined, NaN]), [1, 'B', 'Cat']);\n */\nexport function compact(source) {\n\tif (isPlainObject(source)) {\n\t\tconst sourceKeys = keys(source);\n\t\tconst sourceKeysLength = sourceKeys.length;\n\t\tconst targetObject = {};\n\t\tfor (let i = 0; i < sourceKeysLength; i++) {\n\t\t\tconst keyName = sourceKeys[i];\n\t\t\tconst item = source[keyName];\n\t\t\tconst isisTruthy = isTruthy(item);\n\t\t\tif (isisTruthy) {\n\t\t\t\ttargetObject[keyName] = item;\n\t\t\t}\n\t\t}\n\t\treturn targetObject;\n\t}\n\treturn source.filter((item) => {\n\t\treturn isTruthy(item);\n\t});\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\nimport { cloneType } from '../types/cloneType.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\nimport { isGenerator } from '../types/isGenerator.js';\n/**\n * Asynchronously iterates (for of) through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function forOfCompactMapAsync\n * @category utility\n * @type {Function}\n * @param {Object|Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results else source is type cloned.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * import { assert,forOfCompactMapAsync } from '@universalweb/acid';\n * const source = {a: undefined, b: 2, c: 3};\n * const temp = await forOfCompactMapAsync(source, async (item) => {\n *   return item;\n * });\n * assert(temp, {b: 2, c: 3});\n */\nexport async function forOfCompactMapAsync(source, iteratee = returnValue, resultsObject, generatorArgs) {\n\tif (isGenerator(source)) {\n\t\tconst resultsGenerator = [];\n\t\tfor await (const item of source(...generatorArgs)) {\n\t\t\tconst result = await iteratee(item, resultsGenerator, source);\n\t\t\tif (hasValue(result)) {\n\t\t\t\tresultsGenerator.push(result);\n\t\t\t}\n\t\t}\n\t\treturn resultsGenerator;\n\t}\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = await iteratee(value, results, source);\n\t\t\tif (hasValue(result)) {\n\t\t\t\tmethodPushBound(result);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\tconst methodSet = isFunction(results.set);\n\tfor await (const [key, value] of source) {\n\t\tconst result = await iteratee(value, key, results, source);\n\t\tif (hasValue(result)) {\n\t\t\tif (methodSet) {\n\t\t\t\tresults.set(key, result);\n\t\t\t} else {\n\t\t\t\tresults[key] = result;\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n","import { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\nimport { forOfCompactMapAsync } from './forOfCompactMapAsync.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\n/**\n * Iterates (for of) through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function forOfCompactMap\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results else source is type cloned.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties that are not null or undefined.\n *\n * @example\n * import { assert,forOfCompactMap } from '@universalweb/acid';\n * const source = {a: undefined, b: 2, c: 3};\n * const temp = forOfCompactMap(source, (item) => {\n *   return item;\n * });\n * assert(temp, {b: 2, c: 3});\n */\nexport function forOfCompactMap(source, iteratee = returnValue, resultsObject) {\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = iteratee(value, results, source);\n\t\t\tif (hasValue(result)) {\n\t\t\t\tmethodPushBound(result);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\tconst methodSet = isFunction(results.set);\n\tfor (const [key, value] of source) {\n\t\tconst result = iteratee(value, key, results, source);\n\t\tif (hasValue(result)) {\n\t\t\tif (methodSet) {\n\t\t\t\tresults.set(key, result);\n\t\t\t} else {\n\t\t\t\tresults[key] = result;\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n","import { compactMapArray } from '../arrays/compactMap.js';\nimport { compactMapAsyncArray } from '../arrays/compactMapAsync.js';\nimport { compactMapObject } from '../objects/compactMap.js';\nimport { compactMapAsyncObject } from '../objects/compactMapAsync.js';\nimport { generateLoop } from './generateLoop.js';\nimport { forOfCompactMap } from './forOfCompactMap.js';\nimport { forOfCompactMapAsync } from './forOfCompactMapAsync.js';\n/**\n * Iterates through the calling object and creates a new object based on the calling object's type with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n *\n * @function compactMap\n * @category utility\n * @type {Function}\n * @param {Array | object | Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n * @param {Object | Function} [results = {}] - Object that will be used to assign results.\n * @returns {Array | object | Function} - A new object of the same calling object's type.\n *\n * @example\n * import { compactMap, assert } from '@universalweb/acid';\n * assert(compactMap({a: null, b: 2, c: 3}, (item) => {\n *   return item;\n * }), {b: 2, c: 3});\n */\nexport const compactMap = generateLoop(compactMapArray, compactMapAsyncArray,\n\tcompactMapObject, compactMapAsyncObject, forOfCompactMap, forOfCompactMapAsync);\n","import { every } from './every.js';\nimport { isAsync } from '../types/isAsync.js';\nexport function everyArg(...methods) {\n\tif (isAsync(methods[0])) {\n\t\treturn async function(...args) {\n\t\t\treturn every(methods, async (method) => {\n\t\t\t\treturn every(args, async (item) => {\n\t\t\t\t\treturn method(item);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\treturn function(...args) {\n\t\treturn every(methods, (method) => {\n\t\t\treturn every(args, (item) => {\n\t\t\t\treturn method(item);\n\t\t\t});\n\t\t});\n\t};\n}\n","import { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\n/**\n * Iterates (for of) through the calling object and creates a new object of the same calling object's type with all elements that pass the test implemented by the iteratee.\n *\n * @function forOfFilter\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results else source is type cloned.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties.\n *\n * @example\n * import { assert, forOfFilter } from '@universalweb/acid';\n * const source = {a: undefined, b: 2, c: 3};\n * const temp = forOfFilter(source, (item) => {\n *   return Boolean(item);\n * });\n * assert(temp, {b: 2, c: 3});\n */\nexport function forOfFilter(source, iteratee = returnValue, resultsObject) {\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = iteratee(value, results, source);\n\t\t\tif (result === true) {\n\t\t\t\tmethodPushBound(value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst methodSet = isFunction(results.set);\n\t\tfor (const [key, value] of source) {\n\t\t\tconst result = iteratee(value, key, results, source);\n\t\t\tif (result === true) {\n\t\t\t\tif (methodSet) {\n\t\t\t\t\tresults.set(key, value);\n\t\t\t\t} else {\n\t\t\t\t\tresults[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n","import { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isSet } from '../types/isSet.js';\nimport { isArray } from '../types/isArray.js';\nimport { isGenerator } from '../types/isGenerator.js';\n/**\n * Asynchronously iterates (for of)through the calling object and creates a new object of the same calling object's type with all elements that pass the test implemented by the iteratee.\n *\n * @function forOfFilterAsync\n * @category utility\n * @type {Function}\n * @param {Object|Function|Class|Map|Set|Array} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n * @param {Object|Function|Class|Map|Set|Array} resultsObject - Object that will be used to assign results else source is type cloned.\n * @returns {Object|Function|Class|Map|Set|Array} - An object with mapped properties.\n *\n * @example\n * import { assert, forOfFilterAsync } from '@universalweb/acid';\n * const source = {a: undefined, b: 2, c: 3};\n * const temp = forOfFilterAsync(source, (item) => {\n *   return Boolean(item);\n * });\n * assert(temp, {b: 2, c: 3});\n */\nexport async function forOfFilterAsync(source, iteratee = returnValue, resultsObject, generatorArgs) {\n\tif (isGenerator(source)) {\n\t\tconst resultsGenerator = [];\n\t\tfor await (const item of source(...generatorArgs)) {\n\t\t\tif (await iteratee(item, resultsGenerator, source) === true) {\n\t\t\t\tresultsGenerator.push(item);\n\t\t\t}\n\t\t}\n\t\treturn resultsGenerator;\n\t}\n\tconst results = resultsObject || cloneType(source);\n\tif (isArray(source) || isSet(source)) {\n\t\tconst methodPush = results.push || results.add;\n\t\tconst methodPushBound = methodPush && methodPush.bind(results);\n\t\tfor (const value of source) {\n\t\t\tconst result = await iteratee(value, results, source);\n\t\t\tif (result === true) {\n\t\t\t\tmethodPushBound(value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst methodSet = isFunction(results.set);\n\t\tfor await (const [key, value] of source) {\n\t\t\tconst result = await iteratee(value, key, results, source);\n\t\t\tif (result === true) {\n\t\t\t\tif (methodSet) {\n\t\t\t\t\tresults.set(key, value);\n\t\t\t\t} else {\n\t\t\t\t\tresults[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n","import { filterArray } from '../arrays/filter.js';\nimport { filterAsyncArray } from '../arrays/filterAsync.js';\nimport { filterAsyncObject } from '../objects/filterAsync.js';\nimport { filterObject } from '../objects/filter.js';\nimport { generateLoop } from './generateLoop.js';\nimport { forOfFilter } from './forOfFilter.js';\nimport { forOfFilterAsync } from './forOfFilterAsync.js';\n/**\n * Iterates through the calling object and creates a new object of the same calling object's type with all elements that pass the test implemented by the iteratee.\n *\n * @function filter\n * @category utility\n * @type {Function}\n * @param {Array | object | Function} source - Object that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n * @param {Object | Function} [results = {}] - Object that will be used to assign results.\n * @returns {Array | object | Function} - A new object of the same calling object's type.\n *\n * @example\n * import { filter, assert } from '@universalweb/acid';\n * assert(filter({a: false, b: true, c: true}, (item) => {\n *   return item;\n * }), {b: true, c: true});\n */\nexport const filter = generateLoop(filterArray, filterAsyncArray, filterObject, filterAsyncObject, forOfFilter, forOfFilterAsync);\n\n","import { eachArray } from '../arrays/each.js';\nimport { eachRight } from '../arrays/eachRight.js';\nfunction returnFlow(callable) {\n\treturn (...methods) => {\n\t\treturn (arg) => {\n\t\t\tlet value = arg;\n\t\t\tcallable(methods, (item) => {\n\t\t\t\tvalue = item(value);\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n}\n/**\n * Creates a function that returns the result of invoking the given functions, where each successive invocation is supplied the return value of the previous.\n *\n * @function flow\n * @category utility\n * @type {Function}\n * @param {Array} collection - Methods to invoke.\n * @returns {Function} - Returns the new composite function.\n *\n * @example\n * flow(increment, increment, deduct)(0);\n * // => 1\n */\nexport const flow = returnFlow(eachArray);\n/**\n * This method is like flow except that it creates a function that invokes the given functions from right to left.\n *\n * @function flowRight\n * @category utility\n * @type {Function}\n * @param {Array} collection - Methods to invoke.\n * @returns {Function} - Returns the new composite function.\n *\n * @example\n * flowRight(increment, increment, deduct)(0);\n * // => 1\n */\nexport const flowRight = returnFlow(eachRight);\n\n","import { eachAsyncArray } from '../arrays/eachAsync.js';\nimport { eachRightAsync } from '../arrays/eachRightAsync.js';\nfunction returnFlow(callable) {\n\treturn (...methods) => {\n\t\treturn async (arg) => {\n\t\t\tlet value = arg;\n\t\t\tawait callable(methods, async (item) => {\n\t\t\t\tvalue = await item(value);\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n}\n/**\n * Creates a function that returns the result of invoking the given functions, where each successive invocation is supplied the return value of the previous.\n *\n * @function flowAsync\n * @category utility\n * @type {Function}\n * @async\n * @param {Array} collection - Methods to invoke.\n * @returns {Function} - Returns the new composite function.\n *\n * @example\n * flowAsync(async (item) => {return increment(item);}, async (item) => {return increment(item);})(0);\n * // => 2\n */\nexport const flowAsync = returnFlow(eachAsyncArray);\n/**\n * This method is like flow except that it creates a function that invokes the given functions from right to left.\n *\n * @function flowAsyncRight\n * @category utility\n * @type {Function}\n * @async\n * @param {Array} collection - Methods to invoke.\n * @returns {Function} - Returns the new composite function.\n *\n * @example\n * flowAsyncRight(async (item) => {return increment(item);}, async (item) => {return increment(item);})(0);\n * // => 2\n */\nexport const flowAsyncRight = returnFlow(eachRightAsync);\n\n","import { isFunction } from '../types/isFunction.js';\nimport { cloneType } from '../types/cloneType.js';\nimport { hasValue } from '../types/hasValue.js';\nexport function forMap(source, callback) {\n\tconst cloned = cloneType(source);\n\tconst method = cloned.push || cloned.add;\n\tif (method && isFunction(method)) {\n\t\tconst methodBound = method.bind(cloned);\n\t\tsource.forEach((item) => {\n\t\t\tconst result = callback(item, cloned);\n\t\t\tmethodBound(result);\n\t\t});\n\t} else if (isFunction(cloned.set)) {\n\t\tsource.forEach((item, key) => {\n\t\t\tconst result = callback(item, key, cloned);\n\t\t\tcloned.set(key, result);\n\t\t});\n\t} else {\n\t\tsource.forEach((item, key) => {\n\t\t\tconst result = callback(item, key, cloned);\n\t\t\tcloned[key] = result;\n\t\t});\n\t}\n\treturn cloned;\n}\n","import { every } from './every.js';\nimport { isFunction } from '../types/isFunction.js';\nimport { isRegex } from '../types/isRegex.js';\nimport { isString } from '../types/isString.js';\nimport { noValue } from '../types/noValue.js';\nimport { isArray } from '../types/isArray.js';\n/**\n * Checks if an object contains something.\n *\n * @function has\n * @category utility\n * @param {Array|String|Object} source - Object to be checked.\n * @param {String|Array|Function|RegExp} search - Object that is being searched for.\n * @param {Number} fromIndex - Index at which to start searching.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { has, assert } from '@universalweb/acid';\n * assert(has('Hello World', 'Hello'), true);\n * assert(has(['Hello', 'World'], 'hello'), true);\n */\nexport function has(source, search, position) {\n\tif (noValue(source) || noValue(search)) {\n\t\treturn false;\n\t}\n\tif (isString(source)) {\n\t\tif (isString(search)) {\n\t\t\treturn source.includes(search, position);\n\t\t}\n\t\tif (isRegex(search)) {\n\t\t\treturn search.test(source);\n\t\t}\n\t\tif (isFunction(search)) {\n\t\t\treturn Boolean(search(source));\n\t\t}\n\t\treturn every(search, (item) => {\n\t\t\treturn Boolean(has(source, item));\n\t\t});\n\t}\n\tif (isArray(source)) {\n\t\tif (isString(search)) {\n\t\t\treturn source.includes(search, position);\n\t\t}\n\t\tif (isRegex(search)) {\n\t\t\treturn every(source, (item) => {\n\t\t\t\treturn item.test(search);\n\t\t\t});\n\t\t}\n\t\tif (isArray(search)) {\n\t\t\treturn every(search, (item) => {\n\t\t\t\treturn Boolean(has(source, item));\n\t\t\t});\n\t\t}\n\t}\n\treturn false;\n}\n","import { regexTestFactory } from '../internal/regexTestFactory.js';\n/**\n * Checks if the string has a '.'.\n *\n * @function hasDot\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { hasDot, assert } from '@universalweb/acid';\n * assert(hasDot('test.js'), true);\n */\nexport const hasDot = regexTestFactory(/\\./);\n","import { hasValue } from '../types/hasValue.js';\n/**\n * Checks if a property on an object has a value. If not, it will assign a value.\n *\n * @function ifNotAssign\n * @category utility\n * @type {Function}\n * @param {Object} rootObject - The object to check.\n * @param {String} property - The property name which is to be checked.\n * @param {*} equalThis - The reassignment value for the property being checked.\n * @returns {Object} - Returns the provided rootObject.\n *\n * @example\n * import { ifNotAssign, assert } from '@universalweb/acid';\n * assert(ifNotAssign({}, 'a', 1), {a:1});\n */\nexport const ifNotAssign = (rootObject, property, equalThis) => {\n\tif (property && !hasValue(rootObject[property])) {\n\t\trootObject[property] = equalThis;\n\t}\n\treturn rootObject;\n};\n\n","import { construct } from '../classes/construct.js';\nimport { truth } from './stubTrue.js';\nimport { falsy } from './stubFalse.js';\nimport { noop } from './noop.js';\nimport { times } from './times.js';\nexport class Intervals {\n\tlist = construct(Map);\n\tconstruct() {\n\t}\n\t/**\n\t * Remove a setInterval that was created using the intervals function.\n\t *\n\t * @param {Number} id - The id of the setInterval to remove.\n\t * @returns {undefined} - Returns nothing.\n\t *\n\t * @example\n\t * timer(() => {}, 100);\n\t * // => 0\n\t */\n\tremove(id) {\n\t\tclearInterval(id);\n\t\tthis.list.delete(id);\n\t}\n\thas(id) {\n\t\treturn this.list.has(id);\n\t}\n\tget(id) {\n\t\treturn this.list.get(id);\n\t}\n\t/**\n\t * Create a setInterval & add it to the list of interval timers.\n\t *\n\t * @type {Function}\n\t * @param {Function} callable - The function to be invoked.\n\t * @param {Number} time - The time in milliseconds.\n\t * @returns {Object} - Returns setTimeoutId ID.\n\t *\n\t * @example\n\t * timers.set(() => {}, 100);\n\t * // => 0\n\t */\n\tset(callable, time) {\n\t\tconst currentThis = this;\n\t\tconst id = setInterval(() => {\n\t\t\tcallable();\n\t\t}, time);\n\t\tthis.list.set(id, truth);\n\t\treturn id;\n\t}\n\t/**\n\t * Clear all active setIntervals.\n\t *\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * intervals.clear();\n\t * // => undefined\n\t */\n\tclear() {\n\t\tconst currentThis = this;\n\t\tcurrentThis.list.forEach((id) => {\n\t\t\tcurrentThis.remove(id);\n\t\t});\n\t}\n}\nexport const intervals = construct(Intervals);\n/**\n * Create an interval timer.\n *\n * @function interval\n * @category function\n * @type {Function}\n * @param {Function} callable - The function to be invoked.\n * @param {Number} time - The time in milliseconds.\n * @returns {Object} - Returns setInterval ID.\n *\n * @example\n * interval(() => {}, 100);\n * // => 0\n */\nexport function interval(callable, time) {\n\treturn intervals.set(callable, time);\n}\n/**\n * Clear all active interval timers.\n *\n * @function clearIntervals\n * @category function\n * @returns {undefined} - Returns undefined.\n *\n * @example\n * clearIntervals();\n * // => undefined\n */\nexport function clearIntervals() {\n\tconst id = setTimeout(noop, 0);\n\ttimes(id, (index) => {\n\t\tintervals.remove(index);\n\t});\n}\n","import { isArray } from '../types/isArray.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { each } from './each.js';\n/**\n * Recursively deep assign a target object with a source object. The source objects values are assigned onto the target object's matching properties.\n *\n * @function merge\n * @category utility\n * @type {Function}\n * @param {Object} target - The object which will be modified.\n * @param {Object} source - Source object to merge into the target object.\n * @returns {Object} - Returns target.\n *\n * @example\n * import { merge, assert } from '@universalweb/acid';\n * assert(merge([1,2,4],[3]), [3, 2, 4]);\n */\nconst structuredCloneSafe = globalThis.structuredClone;\nexport function merge(target, ...sources) {\n\teach(sources, (currentSource) => {\n\t\teach(currentSource, (sourceItem, sourceKey) => {\n\t\t\tif (target[sourceKey]) {\n\t\t\t\tif (isPlainObject(sourceItem) || isArray(sourceItem) || sourceItem.forEach) {\n\t\t\t\t\treturn merge(target[sourceKey], sourceItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[sourceKey] = sourceItem;\n\t\t});\n\t});\n\treturn target;\n}\n\n","import { get } from './get.js';\nimport { hasValue } from '../types/hasValue.js';\nimport { assign } from '../objects/assign.js';\nimport { construct } from '../classes/construct.js';\n/**\n * Set & Get a model.\n *\n * @function model\n * @type {Function}\n * @category utility\n * @param {String} modelName - Name of the model.\n * @param {Object} modelValue - The model object.\n * @returns {*} - Returns the associated model.\n * @example\n * model('test', {a: 1}) && model('test');\n * // => {a: 1}\n */\nexport class Model {\n\tstatic models = {};\n\tconstructor(modelName, modelValue) {\n\t\tif (hasValue(modelValue)) {\n\t\t\tassign(this, modelValue);\n\t\t\tthis.modelName = modelName;\n\t\t\tModel.models.set(modelName, modelValue);\n\t\t} else {\n\t\t\tassign(this, modelName);\n\t\t}\n\t}\n}\n/**\n * Returns the model with the given name.\n *\n * @param {String} modelName - The name of the model to return.\n * @param {any} [modelValue] - The value of the model to return.\n * @returns {Model} - The model with the given name.\n */\nexport function model(modelName, modelValue) {\n\tif (hasValue(modelValue)) {\n\t\treturn construct(Model, [modelName, modelValue]);\n\t}\n\treturn get(modelName, Model.models);\n}\n\n","import { eachRight } from '../arrays/eachRight.js';\n/**\n * Takes the first two arguments given and returns them inside a new array.\n *\n * @function pair\n * @category utility\n * @param {*} source - The source object.\n * @param {*} source - The source object.\n * @returns {Array} The array which holds the pair.\n *\n * @example\n * import { pair, assert } from '@universalweb/acid';\n * assert(air(1, 2), [1, 2]);\n */\nexport function pair(argument1, argument2) {\n\treturn [argument1, argument2];\n}\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\n/**\n * Iterates through an array, invokes the async iteratee, and adds the promises to a queue. Then uses & returns the Promise.all on the queue returning the values from each promise. Does not await on the async iteratee.\n *\n * @function concurrent\n * @category utility\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The array from Promise.all.\n *\n * @example\n * import { concurrent, assert } from '@universalweb/acid';\n * const tempList = [];\n * await concurrent([1, 2], async (item) => {\n *   return item;\n * });\n * assert(tempList,  [1, 2]);\n */\nexport function concurrent(source, iteratee, thisBind) {\n\tconst arrayLength = source.length;\n\tconst queue = [];\n\tfor (let index = 0;index < arrayLength; index++) {\n\t\tqueue[index] = iteratee(source[index], index, source, arrayLength, thisBind);\n\t}\n\treturn Promise.all(queue);\n}\n\n","import { hasValue } from '../types/hasValue.js';\nimport { returnValue } from './returnValue.js';\n/**\n * Iterates through an array, invokes the async iteratee, and adds the promises to a queue. Then uses & returns the Promise.allSettled on the queue returning the values from each promise. Does not await on the async iteratee.\n *\n * @function concurrentStatus\n * @category utility\n * @type {Function}\n * @param {Array} source - Array that will be looped through.\n * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n * @param {*} thisBind - An object to be given each time to the iteratee.\n * @returns {Array} - The array from Promise.allSettled.\n *\n * @example\n * import { concurrentStatus, assert } from '@universalweb/acid';\n * const tempList = [];\n * await concurrentStatus([1, 2], async (item) => {\n *   return item;\n * });\n * assert(tempList,  [{status: 'fulfilled', value: 1}, {status: 'fulfilled', value: 2}]);\n */\nexport function concurrentStatus(source, iteratee, thisBind) {\n\tconst arrayLength = source.length;\n\tconst queue = [];\n\tfor (let index = 0;index < arrayLength; index++) {\n\t\tqueue[index] = iteratee(source[index], index, source, arrayLength, thisBind);\n\t}\n\treturn Promise.allSettled(queue);\n}\n\n","/**\n * A wrapper around the promise constructor.\n *\n * @function promise\n * @type {Function}\n * @category utility\n * @param {Function} callback - Function to be called back.\n * @returns {Promise} - A constructor with a callback function.\n * @test\n * (async () => {\n *   const result = await promise((accept) => {\n *     accept(true);\n *   });\n *   return assert(result, true);\n * });\n * @example\n * promise((a) => {});\n * // => Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n */\nexport function promise(callback) {\n\treturn new Promise(callback);\n}\n\n","import { isEqual } from './isEqual.js';\nimport { everyArray } from '../arrays/every.js';\nimport { keys } from '../objects/keys.js';\n/**\n * Using a deep comparison it checks if properties of two objects using an array are equal.\n *\n * @function propertyMatch\n * @type {Function}\n * @category utility\n * @param {Object} source - The source object to compare.\n * @param {Object} compared - Object to be compared to source.\n * @param {Array} properties - List of properties to compare defaults to keys(source).\n * @returns {Array} - Returns an array of properties.\n *\n * @example\n * import { propertyMatch, assert } from '@universalweb/acid';\n * assert(propertyMatch({\n *   a: 1,\n *   b: 2\n * }, {\n *   a: 1,\n *   b: 2\n * }, ['a', 'b']), true);\n */\nexport const propertyMatch = (source, compared, properties = keys(source)) => {\n\treturn everyArray(properties, (property) => {\n\t\treturn isEqual(source[property], compared[property]);\n\t});\n};\n\n","import { isFunction } from '../types/isFunction.js';\nimport { isArray } from '../types/isArray.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isNumber } from '../types/isNumber.js';\nexport function setKey(source, key, value) {\n\tif (key && isPlainObject(source)) {\n\t\tsource[key] = value;\n\t} else if (isNumber(key) && isArray(source)) {\n\t\tsource[key] = value;\n\t} else if (source.set) {\n\t\tsource.set(key, value);\n\t} else if (source.push) {\n\t\tsource.push(value);\n\t} else if (source.add) {\n\t\tsource.add(value);\n\t} else {\n\t\tsource[key] = value;\n\t}\n\treturn source;\n}\n","import { isFunction } from '../types/isFunction.js';\nimport { isArray } from '../types/isArray.js';\nimport { isPlainObject } from '../types/isPlainObject.js';\nimport { isNumber } from '../types/isNumber.js';\nexport function setValue(source, value, key) {\n\tif (isNumber(key) && isArray(source)) {\n\t\tsource[key] = value;\n\t} else if (source.push) {\n\t\tsource.push(value);\n\t} else if (source.add) {\n\t\tsource.add(value);\n\t} else {\n\t\tsource[key] = value;\n\t}\n\treturn source;\n}\n","import { eachObject } from '../objects/each.js';\nexport class Store {\n\tsource;\n\tconstructor(source = {}) {\n\t\tthis.source = source;\n\t\tif (source === null || typeof source !== 'object') {\n\t\t\treturn source;\n\t\t}\n\t\teachObject(source, (property) => {\n\t\t\tsource[property] = new Store(source[property]);\n\t\t});\n\t\tthis.data = new Proxy(source, {\n\t\t\tget(proxySource, property) {\n\t\t\t\tconsole.log(proxySource, property, proxySource[property]);\n\t\t\t\treturn proxySource[property];\n\t\t\t},\n\t\t\tset(proxySource, property, value) {\n\t\t\t\tconsole.log(proxySource, property, proxySource[property]);\n\t\t\t\tproxySource[property] = new Store(value);\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n}\n","/**\n * This method returns a new empty array.\n *\n * @function stubArray\n * @category utility\n * @type {Function}\n * @returns {Array} - Returns the new empty array.\n * @example\n * import { stubArray } from '@universalweb/acid';\n * stubArray();\n * // => []\n */\nexport const stubArray = () => {\n\treturn [];\n};\n\n","/**\n * This method returns a new empty object.\n *\n * @function stubObject\n * @category utility\n * @type {Function}\n * @returns {Object} - Returns the new empty object.\n *\n * @example\n * import { stubObject } from '@universalweb/acid';\n * stubObject();\n * // => {}\n */\nexport const stubObject = () => {\n\treturn {};\n};\n\n","/**\n * This method returns a new empty string.\n *\n * @function stubString\n * @category utility\n * @type {Function}\n * @returns {String} - Returns the new empty string.\n *\n * @example\n * import { stubString } from '@universalweb/acid';\n * stubString();\n * // => ''\n */\nexport const stubString = () => {\n\treturn '';\n};\n","/**\n * Asynchronously iterates based on the amount given awaiting on the iteratee with the current index as an argument.\n *\n * @async\n * @function timesAsync\n * @category utility\n * @type {Function}\n * @param {Number} amount - The amount of times to loop invoking the iteratee.\n * @param {Function} iteratee - Transformation function which is passed index and amount.\n * @returns {undefined} - Nothing.\n *\n * @example\n * import { timesAsync } from '@universalweb/acid';\n * await timesAsync(3, async (item) => {\n *   console.log(item);\n * });\n * // 0\n * // 1\n * // 2\n * // => undefined\n */\nexport async function timesAsync(amount, iteratee) {\n\tfor (let index = 0; index < amount; index++) {\n\t\tawait iteratee(amount);\n\t}\n}\n/**\n * Asynchronously iterates based on the amount given and maps the results awaited on by the iteratee each time to an array.\n *\n * @async\n * @function timesMapAsync\n * @category array\n * @type {Function}\n * @param {Number} amount - The amount of times to loop invoking the iteratee.\n * @param {Function} iteratee - Transformation function which is passed index and amount.\n * @param {Array} [results = []] - Array that will have iteratee return pushed to.\n * @returns {Array} - An array with iteratee's returned values.\n *\n * @example\n * import { timesMapAsync } from '@universalweb/acid';\n * await timesMapAsync(3, (item) => {\n *   return item;\n * });\n * // => [0, 1, 2]\n */\nexport async function timesMapAsync(amount, iteratee, results = []) {\n\tfor (let index = 0; index < amount; index++) {\n\t\tresults[index] = await iteratee(amount);\n\t}\n\treturn results;\n}\n","import { isEqual } from './isEqual.js';\n/**\n * Performs a toggle between 2 values using a deep or strict comparison.\n *\n * @function toggle\n * @type {Function}\n * @category utility\n * @param {(string|number|Object|Array)} value - Strictly compared against on & off arguments.\n * @param {(string|number|Object|Array)} on - The first object to be compared to.\n * @param {(string|number|Object|Array)} off - The second object to be compared to.\n * @returns {(string|number|Object|Array)} - The opposing value to the current.\n *\n * @example\n * import { toggle } from '@universalweb/acid';\n * let toggleMe = true;\n * toggleMe = toggle(toggleMe, true, false);\n * // => false\n */\nexport function toggle(value, on = true, off = false) {\n\treturn (isEqual(on, value)) ? off : on;\n}\n\n","/**\n * Unique ID Generator Module.\n *\n * @module utility/uid\n */\nimport { hasValue } from '../types/hasValue.js';\nimport { construct } from '../classes/construct.js';\n/**\n * Creates a unique numerical recyclable ID generator. The IDs are numerically ascending however freed ids are recycled when available.\n *\n * @class UniqID\n * @type {Class}\n * @category utility\n * @returns {UniqID} - Returns a new instance of UniqID.\n *\n * @example\n * import { UniqID, construct, assert } from '@universalweb/acid';\n * const gen = construct(UniqID);\n * assert(gen.get(), 0);\n * assert(gen.get(), 1);\n * gen.free(0);\n * assert(gen.get(), 0);\n */\nexport class UniqID {\n\ttotalActive = 0;\n\tfreed = [];\n\ttotalFree = 0;\n\t/**\n\t * Generates a new ID or recycle one that is no longer used.\n\t *\n\t * @function get\n\t * @class UniqID\n\t * @category utility\n\t * @type {Function}\n\t * @returns {Number} - Returns a unique id.\n\t *\n\t * @example\n\t * import { UniqID, construct, assert } from '@universalweb/acid';\n\t * const gen = construct(UniqID);\n\t * assert(gen.get(), 0);\n\t */\n\tget() {\n\t\tlet result = this.freed.shift();\n\t\tif (hasValue(result)) {\n\t\t\tthis.totalFree--;\n\t\t} else {\n\t\t\tresult = this.totalActive;\n\t\t\tthis.totalActive++;\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * Frees an UID so that it may be recycled for later use.\n\t *\n\t * @function free\n\t * @class UniqID\n\t * @category utility\n\t * @type {Function}\n\t * @param {Number} id - Number to be freed.\n\t * @returns {undefined} - Nothing is returned.\n\t *\n\t * @example\n\t * import { UniqID, construct, assert } from '@universalweb/acid';\n\t * const gen = construct(UniqID);\n\t * assert(gen.get(), 0);\n\t * gen.free(0);\n\t * assert(gen.get(), 0);\n\t */\n\tfree(id) {\n\t\tthis.freed.push(id);\n\t\tthis.totalFree++;\n\t\tconst isActive = this.totalActive > 0;\n\t\tconst shouldReset = this.totalActive === this.totalFree;\n\t\tif (isActive && shouldReset) {\n\t\t\tthis.reset();\n\t\t}\n\t}\n\treset() {\n\t\tthis.totalActive = 0;\n\t\tthis.freed.length = 0;\n\t\tthis.totalFree = 0;\n\t}\n}\n/**\n * A built in constructed instance of UniqID. Creates a unique numerical recyclable ID. The IDs are numerically ascending however freed ids are recycled when available.\n *\n * @function uniqID\n * @category utility\n *\n * @example\n * import { uniqID, assert } from '@universalweb/acid';\n * assert(uniqID.get(), 0);\n * assert(uniqID.get(), 1);\n * uniqID.free(0);\n * assert(uniqID.get(), 0);\n */\nexport const uniqID = construct(UniqID);\n","/**\n * Class representing a virtual storage. A drop in replacement for localStorage.\n * The virtualStorage function is a factory which wraps the VirtualStorage constructor & returns it.\n * Direct class/constructor access is named VirtualStorage.\n *\n * @category utility\n * @returns {*} - Returns a new VirtualStorage Object.\n *\n * @example\n * import { virtualStorage } from '@universalweb/acid';\n * const myVirtualStorage = virtualStorage();\n * // => New Crate Object\n */\nexport class VirtualStorage {\n\tconstructor(initialObject = {}) {\n\t\tthis.items = initialObject;\n\t}\n\t/**\n\t * Get an item from a virtual storage object.\n\t *\n\t * @param {String} key - The key used to store the data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { VirtualStorage } from '@universalweb/acid';\n\t * const myVirtualStorage = virtualStorage();\n\t * myVirtualStorage.setItem('key', 'value');\n\t * myVirtualStorage.getItem('key');\n\t * // => 'value'\n\t */\n\tgetItem(key) {\n\t\treturn this.items[key];\n\t}\n\t/**\n\t * Save an item to a virtual storage object.\n\t *\n\t * @param {String} key - The key used to store the data.\n\t * @param {*} value - If saving to localStorage, & the object isn't a string it will be converted to a string using JSON.stringify.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { VirtualStorage, assert } from '@universalweb/acid';\n\t * const vStorage = new VirtualStorage();\n\t * vStorage.setItem('title', 'value');\n\t * assert(vStorage.getItem('title'), 'value');\n\t */\n\tsetItem(key, value) {\n\t\tthis.items[key] = value;\n\t}\n\t/**\n\t * Clears all data from the virtual storage object by replacing with a new object.\n\t *\n\t * @param {String} key - The key used to remove data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { virtualStorage } from '@universalweb/acid';\n\t * const myVirtualStorage = virtualStorage();\n\t * myVirtualStorage.setItem('key', 'value');\n\t * myVirtualStorage.clear();\n\t * myVirtualStorage.getItem('key');\n\t * // => undefined\n\t */\n\tclear() {\n\t\tthis.items = {};\n\t}\n\t/**\n\t * Remove an item from a virtual storage object.\n\t *\n\t * @param {String} key - The key used to remove data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { virtualStorage } from '@universalweb/acid';\n\t * const myVirtualStorage = virtualStorage();\n\t * myVirtualStorage.setItem('key', 'value');\n\t * myVirtualStorage.removeItem('key');\n\t * myVirtualStorage.getItem('key');\n\t * // => undefined\n\t */\n\tremoveItem(key) {\n\t\tthis.items[key] = null;\n\t}\n}\n/**\n *  The virtualStorage function is a factory which wraps the VirtualStorage class constructor.\n *\n * @function virtualStorage\n * @category browser\n * @type {Function}\n * @returns {*} - Returns a new VirtualStorage Object.\n *\n * @example\n * import { virtualStorage, assert } from '@universalweb/acid';\n * const vStorage = virtualStorage();\n * vStorage.setItem('title', 'value');\n * assert(vStorage.getItem('title'), 'value');\n */\nexport function virtualStorage(initialObject) {\n\treturn new VirtualStorage(initialObject);\n}\n\n","import { eachArray } from '../arrays/each.js';\nimport { eachObject } from '../objects/each.js';\nimport { isBoolean } from '../types/isBoolean.js';\nimport { keys } from '../objects/keys.js';\n/**\n * Checks to see of the browser agent has a string.\n *\n * @function isAgent\n * @category browser\n * @type {Function}\n * @param {String} source - The string to search for.\n * @returns {Boolean} - Returns true or false.\n * @example\n * isAgent('mobile');\n * // => false\n */\nexport function isAgent(source) {\n\treturn (source) ? isAgent[source] : keys(isAgent);\n}\nconst userAgent = globalThis.navigator?.userAgentData;\nif (userAgent) {\n\teachObject(userAgent, (value, key) => {\n\t\tif (isBoolean(value) && value) {\n\t\t\tisAgent[key] = value;\n\t\t}\n\t});\n\teachArray(userAgent.brands, (value) => {\n\t\tisAgent[value.brand] = value.version;\n\t});\n} else if (navigator.userAgent) {\n\tlet userAgentNormalized = navigator.userAgent.toLowerCase();\n\tuserAgentNormalized = userAgentNormalized.replace(/_/g, '.');\n\tuserAgentNormalized = userAgentNormalized.replace(/[#_,;()]/g, '');\n\tconst userAgentSplit = userAgentNormalized.split(/ |\\//);\n\teachArray(userAgentSplit, (item) => {\n\t\tisAgent[item] = true;\n\t});\n}\n\n","/**\n * Attaches an event listener to a node.\n *\n * @function eventAdd\n * @category browser\n * @type {Function}\n * @param {Node} node - Given node.\n * @param {String} eventName - A string representing the event type.\n * @param {Object|Function} callback - The object which receives a notification when an event of the specified type occurs.\n * @param {Boolean} useCapture - The default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n * @returns {Node} - Returns given node.\n *\n * @example\n * eventAdd(document.body, 'click', () => {console.log('CLICKED');});\n * // = > document.body\n */\nexport function eventAdd(node, eventName, callback, useCapture) {\n\tnode.addEventListener(eventName, callback, useCapture);\n\treturn node;\n}\n/**\n * Attaches an event listener to a node.\n *\n * @function eventRemove\n * @category browser\n * @type {Function}\n * @param {Node} node - Given node.\n * @param {String} eventName - A string representing the event type.\n * @param {Object|Function} callback - The object which receives a notification when an event of the specified type occurs.\n * @param {Boolean} useCapture - The default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n * @returns {Node} - Returns given node.\n *\n * @example\n * eventRemove(document.body, () => {console.log('CLICKED');});\n * // = > Undefined\n */\nexport function eventRemove(node, eventName, callback, useCapture) {\n\tnode.removeEventListener(eventName, callback, useCapture);\n\treturn node;\n}\n\n","/**\n * Checks if the keycode of the event is strictly equal to 13.\n *\n * @function isEnter\n * @category browser\n * @type {Function}\n * @param {Object} eventObject - Object to be checked.\n * @returns {Boolean} - Returns true if the keycode property of the object equals 13.\n *\n * @example\n * isEnter('click');\n * // => false\n */\nexport function isEnter(eventObject) {\n\treturn eventObject.keyCode === 13;\n}\n\n","/**\n  * Create a document fragment.\n  *\n  * @function createFragment\n  * @category browser\n  * @type {Function}\n  * @ignore\n  * @returns {Fragment} - Returns a new document fragment.\n*/\nexport const createFragment = document.createDocumentFragment.bind(document);\n","/**\n * Append a DOM node.\n *\n * @function append\n * @category browser\n * @ignoreTest\n * @type {Function}\n * @ignore\n * @param {Node} parentNode - The parent node.\n * @param {Node} child - The node to be appended.\n * @returns {undefined} - Returns the child.\n */\nexport function append(parentNode, child) {\n\tparentNode.appendChild(child);\n\treturn child;\n}\n","import { eachObject } from '../objects/each.js';\nimport { isArray } from '../types/isArray.js';\nimport { mapArray } from '../arrays/map.js';\nimport { zipObject } from '../objects/zip.js';\n/**\n * Assign attributes to a DOM node.\n *\n * @function nodeAttribute\n * @category browser\n * @ignoreTest\n * @type {Function}\n * @async\n * @param {Node} node - The DOM node.\n * @param {Object|Array} object - Object with key being the attribute name and the value being the attribute value. If an array is given it will get the values corresponding to the array items.\n * @returns {Object|Node} - If using an array this returns an object of attribute names as keys and their values as the property value. If using an object this will return the provided node.\n *\n * @example\n * nodeAttribute(document.body, { 'data-example': 'test'});\n */\nexport function nodeAttribute(node, object) {\n\tif (isArray(object)) {\n\t\treturn zipObject(object, mapArray(object, (item) => {\n\t\t\treturn node.getAttribute(item);\n\t\t}));\n\t}\n\teachObject(object, (item, key) => {\n\t\tnode.setAttribute(key, item);\n\t});\n\treturn node;\n}\n\n","import { restString } from '../strings/range.js';\nconst dotString = '.';\nconst poundString = '#';\nconst classTest = /^.[\\w_-]+$/;\nconst tagTest = /^[A-Za-z]+$/;\nconst regexSpace = /\\s/;\n/**\n * Wrapper around getElementsByClassName.\n *\n * @function getByClass\n * @category browser\n * @ignoreTest\n * @type {Function}\n */\nexport const getByClass = document.getElementsByClassName.bind(document);\n/**\n * Wrapper around getElementsByTagName.\n *\n * @function getByTag\n * @category browser\n * @ignoreTest\n * @type {Function}\n */\nexport const getByTag = document.getElementsByTagName.bind(document);\n/**\n * Wrapper around getElementsByIdName.\n *\n * @function getById\n * @category browser\n * @ignoreTest\n * @type {Function}\n */\nexport const getById = document.getElementById.bind(document);\n/**\n * Wrapper around querySelector.\n *\n * @function querySelector\n * @category browser\n * @ignoreTest\n * @type {Function}\n */\nexport const querySelector = document.querySelector.bind(document);\n/**\n * Wrapper around querySelectorAll.\n *\n * @function querySelectorAll\n * @category browser\n * @ignoreTest\n * @type {Function}\n */\nexport const querySelectorAll = document.querySelectorAll.bind(document);\n/**\n * Returns relevant DOM node.\n *\n * @function selector\n * @category browser\n * @ignoreTest\n * @param {String} select - String to be evaluated.\n * @type {Function}\n * @returns {Node} - Returns a DOM node.\n *\n * @example\n * selector('#node');\n * // => <div id=\"node\"></div>\n */\nexport function selector(select) {\n\tconst firstLetter = select[0];\n\tswitch (firstLetter) {\n\tcase poundString:\n\t\tif (!regexSpace.test(select)) {\n\t\t\treturn getById(restString(select));\n\t\t}\n\t\tbreak;\n\tcase dotString:\n\t\tif (classTest.test(select)) {\n\t\t\treturn getByClass(restString(select));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (tagTest.test(select)) {\n\t\t\treturn getByTag(select);\n\t\t}\n\t}\n\treturn querySelectorAll(select);\n}\n\n","import { append } from './append.js';\nimport { hasDot } from '../utilities/hasDot.js';\nimport { eventAdd } from './event.js';\nimport { nodeAttribute } from './attribute.js';\nimport { promise } from '../utilities/promise.js';\nimport { querySelector } from './selector.js';\nconst createElementCache = document.createElement.bind(document);\nconst nodeAttachLoadingEvents = (node) => {\n\treturn promise((accept) => {\n\t\teventAdd(node, 'load', accept, true);\n\t\teventAdd(node, 'error', accept, true);\n\t\tappend(querySelector('head'), node);\n\t});\n};\n/**\n * Asynchronously import a js file and append it to the head node.\n * If a script fails to load importjs won't reject the promise rather it'll return the error event to limit further complications & reduce code complexity.\n *\n * @function importjs\n * @category browser\n * @type {Function}\n * @async\n * @param {*} url - URL of the script to import. If not \".\" is found in the file name \".js\" will be appended.\n * @returns {Promise} - Returns a promise which returns a \"load\" or \"error\" event associated with the script.\n *\n * @example\n * importjs('core.js');\n * importjs('core');\n */\nexport function importjs(url) {\n\tconst src = hasDot(url) && url || `${url}.js`;\n\tconst node = nodeAttribute(createElementCache('script'), {\n\t\tasync: '',\n\t\tsrc\n\t});\n\treturn nodeAttachLoadingEvents(node);\n}\n\n","import { eventAdd } from './event.js';\nimport { importjs } from './importScript.js';\nimport { getById } from './selector.js';\n/**\n * Runs a function if the document has finished loading. If not, add an eventlistener.\n *\n * @function isDocumentReady\n * @category browser\n * @ignoreTest\n * @type {Function}\n * @param {Function} callable - Function to be run.\n * @returns {Boolean|Function} - If the document is ready, returns a function. If not, return false.\n *\n * @example\n * isDocumentReady(() => {return 1});\n * // => 1\n */\nexport function isDocumentReady(callable) {\n\tconst state = document.readyState;\n\tconst checkStatus = state === 'interactive' || state === 'completed' || state === 'complete';\n\tif (checkStatus) {\n\t\treturn (callable) ? callable() : true;\n\t}\n\tif (callable) {\n\t\teventAdd(document, 'DOMContentLoaded', callable);\n\t}\n\treturn false;\n}\nisDocumentReady(() => {\n\tconst scriptTag = getById('AcidLib');\n\tconst scriptName = (scriptTag && scriptTag.getAttribute('data-index')) || '/index';\n\timportjs(scriptName);\n});\n","const protocol = location.protocol;\nconst protocolSocket = (protocol === 'http:') ? 'ws' : 'wss';\nconst hostname = location.hostname;\n/**\n * Holds client hardware, browser, and host info.\n *\n * @memberof $\n * @category browser\n * @ignoreTest\n * @property {Object} info - Client hardware & host info.\n * @type {Object}\n */\nexport const info = {\n\thardware: {\n\t\tcores: navigator.hardwareConcurrency\n\t},\n\thost: {\n\t\tname: hostname,\n\t\tprotocol,\n\t\tprotocolSocket,\n\t}\n};\n\n","import { assign } from '../objects/assign.js';\nimport { eventAdd } from './event.js';\nimport { info } from './info.js';\nimport { isDocumentReady } from './ready.js';\nexport function saveDimensions() {\n\tassign(info, {\n\t\tbodyHeight: document.body.offsetHeight,\n\t\tbodyWidth: document.body.offsetWidth,\n\t\twindowHeight: window.innerHeight,\n\t\twindowWidth: window.innerWidth,\n\t});\n}\n/**\n * Save current document & window dimensions to the info property.\n *\n * @function updateDimensions\n * @category browser\n * @ignoreTest\n * @type {Function}\n * @returns {undefined} - Returns undefined.\n *\n * @example\n * updateDimensions();\n */\nexport function updateDimensions() {\n\tsaveDimensions();\n}\nisDocumentReady(updateDimensions);\neventAdd(window, 'load', updateDimensions, true);\neventAdd(window, 'resize', updateDimensions, true);\n\n","/**\n * LocalStorage Module..\n *\n * @module browser/storage\n */\nimport { hasValue } from '../types/hasValue.js';\nimport { isString } from '../types/isString.js';\nimport { stringify } from '../utilities/json.js';\nimport { virtualStorage } from '../utilities/virtualStorage.js';\nexport let hasLocal;\nfunction hasStorage(storeCheck) {\n\ttry {\n\t\tstoreCheck().removeItem('TESTING');\n\t\thasLocal = true;\n\t} catch (e) {\n\t\thasLocal = false;\n\t}\n}\nhasStorage(() => {\n\treturn localStorage;\n});\n/**\n * Constructs a virtual storage container with localStorage support.\n * Crate will fallback to strictly virtual storage if localStorage isn't supported.\n * If localStorage is supported virtual storage will be used first & only fallback to localStorage when needed.\n * Crate is ideal as a seemless drop in replacement for localStorage when not supported or allowed.\n *\n * @class Crate\n * @category browser\n * @returns {Crate} - Returns a new instance of Crate.\n *\n * @example\n * import { Crate, construct, assert } from '@universalweb/acid';\n * const storageCrate = construct(Crate);\n * storageCrate.setItem('key', 'value');\n * assert(storageCrate.getItem('key'), 'value');\n */\nexport class Crate {\n\tconstructor(initialObject) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local = localStorage;\n\t\t}\n\t\tthis.storage = virtualStorage(initialObject);\n\t}\n\thasLocal = hasLocal;\n\t/**\n\t * Save an item to a crate.\n\t *\n\t * @function setItem\n\t * @class Crate\n\t * @category browser\n\t * @param {String} key - The key used to store the data.\n\t * @param {*} value - If saving to localStorage, & the object isn't a string it will be converted to a string using JSON.stringify.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { Crate, construct, assert } from '@universalweb/acid';\n\t * const storageCrate = construct(Crate);\n\t * storageCrate.setItem('key', 'value');\n\t * assert(storageCrate.getItem('key'), 'value');\n\t */\n\tsetItem(key, value) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.setItem(key, (isString(value)) ? value : stringify(value));\n\t\t}\n\t\treturn this.storage.setItem(key, value);\n\t}\n\t/**\n\t * Get an item from a crate.\n\t *\n\t * @function getItem\n\t * @class Crate\n\t * @category browser\n\t * @param {String} key - The key used to store the data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { Crate, construct, assert } from '@universalweb/acid';\n\t * const storageCrate = construct(Crate);\n\t * storageCrate.setItem('key', 'value');\n\t * assert(storageCrate.getItem('key'), 'value');\n\t */\n\tgetItem(key) {\n\t\tconst item = this.storage.getItem(key);\n\t\tif (hasValue(item)) {\n\t\t\treturn item;\n\t\t}\n\t\tif (!hasValue(item) && this.hasLocal) {\n\t\t\treturn this.local.getItem(key);\n\t\t}\n\t}\n\t/**\n\t * Clears all data for the crate including all of localStorage if supported.\n\t *\n\t * @function clear\n\t * @class Crate\n\t * @category browser\n\t * @param {String} key - The key used to remove data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { Crate, construct, assert } from '@universalweb/acid';\n\t * const storageCrate = construct(Crate);\n\t * storageCrate.setItem('key', 'value');\n\t * assert(storageCrate.getItem('key'), 'value');\n\t * storageCrate.clear();\n\t * assert(storageCrate.getItem('key'), undefined);\n\t */\n\tclear() {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.clear();\n\t\t}\n\t\tthis.storage.clear();\n\t}\n\t/**\n\t * Remove an item from a crate.\n\t *\n\t * @class Crate\n\t * @category browser\n\t * @function removeItem\n\t * @param {String} key - The key used to remove data.\n\t * @returns {undefined} - Returns undefined.\n\t *\n\t * @example\n\t * import { Crate, construct, assert } from '@universalweb/acid';\n\t * const storageCrate = construct(Crate);\n\t * storageCrate.setItem('key', 'value');\n\t * assert(storageCrate.getItem('key'), 'value');\n\t * storageCrate.removeItem('key');\n\t * assert(storageCrate.getItem('key'), undefined);\n\t */\n\tremoveItem(key) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.removeItem(key);\n\t\t}\n\t\tthis.storage.removeItem(key);\n\t}\n}\n/**\n *  The crate function is a factory which wraps the Crate class constructor.\n *\n * @function crate\n * @category browser\n * @type {Function}\n * @returns {*} - Returns a new Crate Object.\n *\n * @example\n * const storageCrate = crate();\n * // => New Crate Object\n */\nexport function crate(virtualFlag) {\n\treturn new Crate(virtualFlag);\n}\n\n","import { isString } from '../types/isString.js';\nimport { stringify } from '../utilities/json.js';\nconst generateTheme = (color, bg) => {\n\treturn `color:${color};background:${bg};`;\n};\nexport const themes = {\n\talert: generateTheme('#fff', '#f44336'),\n\timportant: generateTheme('#fff', '#E91E63'),\n\tnotify: generateTheme('#fff', '#651FFF'),\n\twarning: generateTheme('#000', '#FFEA00'),\n};\n/**\n  * Console.trace wrapper with theme support.\n  *\n  * @function cnsl\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @param {Object} value - The value to be logged.\n  * @param {String} themeName - The name of the theme to be used.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * cnsl('Lucy', 'notify');\n  * // 'Lucy'\n*/\nexport const cnsl = (value, themeName) => {\n\tconst data = isString(value) ? value : stringify(value);\n\tif (themeName === 'alert' || themeName === 'warning') {\n\t\treturn console.trace(`%c${data}`, `${themes[themeName]}font-size:13px;padding:2px 5px;border-radius:2px;`);\n\t}\n\tconsole.log(`%c${data}`, `${themes[themeName]}font-size:13px;padding:2px 5px;border-radius:2px;`);\n};\n/**\n  * Create color themes for cnsl method.\n  *\n  * @function cnslTheme\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @param {String} themeName - The name of the theme.\n  * @param {String} color - The text color.\n  * @param {String} background - The background color of the block.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * cnslTheme('BlackNWhite', '#fff', '#000');\n*/\nexport const cnslTheme = (themeName, color, background) => {\n\tthemes[themeName] = generateTheme(color, background);\n};\n\n","import { hasValue } from '../types/hasValue.js';\nimport { difference } from '../arrays/difference.js';\n/**\n * Checks if value is a plain DOM Node.\n *\n * @function isDom\n * @category browser\n * @ignoreTest\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isDom, assert } from '@universalweb/acid';\n * assert(isDom(document.querySelectorAll('head')), true);\n */\nexport function isDom(source) {\n\treturn source && source.nodeType !== 9;\n}\n/**\n * Checks if the value is a HTMLCollection.\n *\n * @function isHTMLCollection\n * @category browser\n * @ignoreTest\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isHTMLCollection, assert } from '@universalweb/acid';\n * document.body.innerHTML = '<div class=\"test\"></div>';\n * assert(isHTMLCollection(document.getElementsByClassName('test')), true);\n */\nconst objectHTMLCollection = '[object HTMLCollection]';\nexport function isHTMLCollection(source) {\n\treturn (hasValue(source)) ? source.toString() === objectHTMLCollection : false;\n}\n/**\n * Checks if the value is a NodeList.\n *\n * @function isNodeList\n * @category browser\n * @ignoreTest\n * @param {*} source - Object to be checked.\n * @returns {Boolean} - Returns true or false.\n *\n * @example\n * import { isNodeList, assert } from '@universalweb/acid';\n * document.body.innerHTML = '<div class=\"test\"></div>';\n * assert(isNodeList(document.querySelectorAll('.test')), true);\n */\nconst objectNodeList = '[object NodeList]';\nexport function isNodeList(source) {\n\treturn (hasValue(source)) ? source.toString() === objectNodeList : false;\n}\n"],"names":["chunk","array","size","chunked","index","forEach","item","key","push","clearArray","source","length","cloneArray","slice","isUndefined","undefined","hasLength","Boolean","isNull","hasValue","returnValue","eachArray","iteratee","thisBind","arrayLength","compactMapArray","results","arrayOriginal","returned","async","eachAsyncArray","compactMapAsyncArray","result","sign","Math","isNegative","rangeUp","start","end","step","sourceArray","position","rangeDown","range","callback","isArray","Array","ensureArray","flattenDeep","flat","Infinity","reflectConstruct","Reflect","construct","target","argumentsList","newTarget","args","difference","sources","differencesMap","Map","differences","currentArray","parentIndex","child","childIndex","childRoot","get","count","set","drop","amount","upTo","splice","dropRight","eachRight","eachRightAsync","everyArray","sourceLength","everyAsyncArray","filterArray","filterAsyncArray","first","flatten","level","i","reduce","previousValue","currentValue","concat","initial","intersection","arrays","otherItem","includes","objectKeys","Object","keys","regexToPath","regexCloseBracket","emptyString","toPath","replace","split","propertyString","link","hasOwn","hasKeys","properties","pathArray","lastPath","pop","initialPathObject","hasAnyKeys","find","isPlainObject","value","constructor","toString","trim","isConstructor","isConstructorFactory","constructorName","name","isConstructorNameFactory","isTypeFactory","method","primarySource","otherSources","isBufferCall","isBuffer","isEqual","equals","sourceProperties","isMatchArray","compareArray","mathNativeMax","max","largest","last","indexFrom","mapArray","mapAsyncArray","mapRightArray","trueIndex","mapWhile","subtract","minuend","subtrahend","sortNumberAscending","numberList","sort","arrayToObject","sortedObject","partition","predicate","rejected","subtractReverse","sortNumberDescening","remove","removeThese","removeBy","rest","right","floor","random","randomInt","min","toArray","from","isNumberEqual","shuffle","shuffleArray","sample","sampleArray","used","mathNativeMin","smallest","getNumberInsertIndex","insertIndex","take","endIndex","takeRight","indexRight","onlyUnique","indexOf","sortUnique","unique","isSorted","filter","union","untilFalseArray","untilTrueArray","whileCompactMap","whileEachArray","whileMapArray","without","sourcesSet","Set","has","xor","xorMap","xored","zip","map","unZip","arraySet","ensureBuffer","Buffer","alloc","clearBuffer","fill","countBy","collection","object","countKey","propertyName","countWithoutKey","findIndexCache","element","indexMatch","findIndex","id","findItem","sortCollectionDescendingFilter","previous","next","ifMatch","previousKey","nextKey","sortCollectionDescending","sortObjectsAlphabetically","localeCompare","sortCollectionAlphabetically","sortCollectionAscendingFilter","sortCollectionAscending","getHighest","getLowest","groupBy","indexBy","invoke","property","invokeAsync","isString","String","pluckObject","targets","pluck","sortObjectsAlphabeticallyReverse","sortCollectionAlphabeticallyReverse","getFileExtension","substring","lastIndexOf","getFilename","regexTestFactory","regexType","test","isFileCSS","isFileHTML","isFileJS","isFileJSON","after","callable","point","ary","before","objectAssign","assign","eachAsyncObject","propertyCount","eachObject","original","forEachAsync","values","valuesLength","isSetCall","isSet","forOf","isGeneratorCall","isGenerator","forOfAsync","generatorArgs","isFunction","Function","isAsyncCall","isAsync","generateLoop","arrayLoop","arrayLoopAsync","objectLoop","objectLoopAsync","forOfLoop","forOfLoopAsync","isIterateeAsync","each","Chain","methods","this","addChainMethod","thisChain","methodName","call","setValue","done","chain","config","curry","arity","curries","curried","curryArgs","curryRight","unshift","truth","stubTrue","falsy","stubFalse","noop","times","timesMap","Timers","list","clearTimeout","delete","time","currentThis","setTimeout","clear","timers","timer","clearTimers","apply","debounce","debounced","bind","ifInvoke","inAsync","firstArgument","inSync","negate","nthArg","once","mapAsyncObject","thisObject","mapObject","getType","cloneType","sourceType","forOfMap","resultsObject","methodPush","add","methodPushBound","methodSet","forOfMapAsync","resultsGenerator","over","iteratees","everyAsyncObject","everyObject","forOfEvery","forOfEveryAsync","every","overEvery","predicates","arg","reArg","indexes","throttle","throttled","shouldThrottle","wrap","wrapper","isSame","is","functionPrototype","prototype","cacheNativeMethod","getPropNames","getOwnPropertyNames","getPropDesc","getOwnPropertyDescriptor","defProp","defineProperty","hasProp","hasOwnProperty","augend","addend","deduct","divide","increment","multiply","calcProgress","total","currentAmount","randomFloat","remainder","subtractAll","a","b","sumAll","isNumberInRange","isNumberNotInRange","isPositive","isZero","compactKeys","compactedKeys","compactMapAsyncObject","compactMapObject","filterObject","filterAsyncObject","invert","isMatchObject","sourceKeys","targetKeys","isNumberCall","isNumber","isRegexCall","isRegex","escapeRegexRegex","escapeRegex","arrayToRegex","makeSafe","RegExp","join","omit","blacklist","blacklistRegex","numberToString","pick","whitelist","objectSize","zipObject","zipedObject","unZipObject","unZippedKeys","normalizeCase","camelCase","toLowerCase","toUpperCase","space","kebabCase","snakeCase","upperCase","lowerCase","insertInRange","string","text","rightString","chunkString","match","initialString","restString","substr","replaceList","words","rawURLDecodeRegex","andRegex","lessThanRegex","moreThanRegex","doubleQuoteRegex","rawURLDecode","decodeURIComponent","htmlEntities","sanitize","tokenizeRegEx","wordsRegEx","tokenize","truncate","maxLength","stringLength","breakAll","breakAllLength","truncateDown","truncateRight","truncateUp","spaceFirstLetter","upperFirstLetter","upperFirst","upperFirstAll","upperFirstOnly","upperFirstOnlyAll","getTypeName","isArguments","noValue","isMapCall","isMap","typedArrayRegex","arrayConstructorName","isTypedArray","isArrayLike","strictFlag","isBigIntCall","isBigInt","isBooleanCall","isBoolean","isArrayBufferCall","isArrayBuffer","isChild","sourceChild","targetParent","constructorNames","isCloneable","isDateCall","isDate","isEmpty","isFalse","isF32Call","isF32","isF64Call","isF64","isInteger","Number","isFloat","isI16Call","isI16","isI32Call","isI32","isI8Call","isI8","isIterable","Symbol","iterator","isPromise","Promise","isKindAsync","isParent","sourceParent","targetChild","isPrimitive","type","isRelated","targetOne","targetTwo","isSafeInteger","isSafeInt","isSameType","other","otherType","isTrue","isU16Call","isU16","isU32Call","isU32","isU8Call","isU8","isU8CCall","isU8C","isWeakMapCall","isWeakMap","isDeno","globalThis","Deno","isNodejs","process","versions","node","isTruthy","returnIfTrue","isFalsy","ifValue","optional","notEqual","jsonNative","JSON","jsonParse","reviver","parse","stringify","assert","expected","options","localOptions","errorTitle","title","file","Error","createAssertError","bindAll","bindThis","targetAssign","structuredCloneSafe","structuredClone","clone","compact","sourceKeysLength","targetObject","keyName","forOfCompactMapAsync","forOfCompactMap","compactMap","everyArg","forOfFilter","forOfFilterAsync","returnFlow","flow","flowRight","flowAsync","flowAsyncRight","forMap","cloned","methodBound","search","hasDot","ifNotAssign","rootObject","equalThis","Intervals","clearInterval","setInterval","intervals","interval","clearIntervals","merge","currentSource","sourceItem","sourceKey","Model","static","modelName","modelValue","models","model","pair","argument1","argument2","concurrent","queue","all","concurrentStatus","allSettled","promise","propertyMatch","compared","setKey","Store","data","Proxy","proxySource","console","log","stubArray","stubObject","stubString","timesAsync","timesMapAsync","toggle","on","off","UniqID","totalActive","freed","totalFree","shift","free","isActive","shouldReset","reset","uniqID","VirtualStorage","initialObject","items","getItem","setItem","removeItem","virtualStorage","isAgent","userAgent","navigator","userAgentData","brands","brand","version","userAgentNormalized","eventAdd","eventName","useCapture","addEventListener","eventRemove","removeEventListener","isEnter","eventObject","keyCode","createFragment","document","createDocumentFragment","append","parentNode","appendChild","nodeAttribute","getAttribute","setAttribute","classTest","tagTest","regexSpace","getByClass","getElementsByClassName","getByTag","getElementsByTagName","getById","getElementById","querySelector","querySelectorAll","selector","select","createElementCache","createElement","importjs","url","src","accept","nodeAttachLoadingEvents","isDocumentReady","state","readyState","scriptTag","protocol","location","protocolSocket","hostname","info","hardware","cores","hardwareConcurrency","host","saveDimensions","bodyHeight","body","offsetHeight","bodyWidth","offsetWidth","windowHeight","window","innerHeight","windowWidth","innerWidth","updateDimensions","hasLocal","storeCheck","e","hasStorage","localStorage","Crate","local","storage","crate","virtualFlag","generateTheme","color","bg","themes","alert","important","notify","warning","cnsl","themeName","trace","cnslTheme","background","isDom","nodeType","isHTMLCollection","isNodeList"],"mappings":"AAcO,SAASA,EAAMC,EAAOC,EAAO,GACnC,MAAMC,EAAU,GAChB,IAAIC,EAAQ,EAUZ,OATAH,EAAMI,SAAQ,CAACC,EAAMC,KACdA,EAAML,IACXC,EAAQK,KAAK,IACTD,GACHH,KAGFD,EAAQC,GAAOI,KAAKF,EAAK,IAEnBH,CACR,CCdO,SAASM,EAAWC,GAE1B,OADAA,EAAOC,OAAS,EACTD,CACR,CCHO,SAASE,EAAWF,GAC1B,OAAOA,EAAOG,OACf,CCJO,SAASC,EAAYJ,GAC3B,YAAkBK,IAAXL,CACR,CCAO,SAASM,EAAUN,GACzB,OAAOO,QAAQP,EAAOC,OACvB,CCFO,SAASO,EAAOR,GACtB,OAAkB,OAAXA,CACR,CCDO,SAASS,EAAST,GACxB,OAAQI,EAAYJ,KAAYQ,EAAOR,EACxC,CCRO,SAASU,EAAYV,GAC3B,OAAOA,CACR,CCWO,SAASW,EAAUX,EAAQY,EAAUC,GAC3C,IAAKb,EACJ,OAED,MAAMc,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQ,EAAEA,EAAQoB,EAAYpB,IACtCkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,EAAaD,GAErD,OAAOb,CACR,CCTO,SAASe,EAAgBf,EAAQY,EAAWF,EAAaM,EAAU,GAAIH,GAO7E,OANAF,EAAUX,GAAQ,CAACJ,EAAMF,EAAOuB,EAAeH,KAC9C,MAAMI,EAAWN,EAAShB,EAAMF,EAAOsB,EAASC,EAAeH,EAAaD,GACxEJ,EAASS,IACZF,EAAQlB,KAAKoB,EACb,IAEKF,CACR,CCVOG,eAAeC,EAAepB,EAAQY,GAC5C,IAAKZ,EACJ,OAED,MAAMc,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQ,EAAGA,EAAQoB,EAAapB,UAClCkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,GAE9C,OAAOd,CACR,CCROmB,eAAeE,EAAqBrB,EAAQY,EAAWF,GAC7D,MAAMM,EAAU,GAOhB,aANMI,EAAepB,GAAQmB,MAAOvB,EAAMF,EAAOoB,KAChD,MAAMQ,QAAeV,EAAShB,EAAMF,EAAOsB,EAASF,GAChDL,EAASa,IACZN,EAAQlB,KAAKwB,EACb,IAEKN,CACR,CChBA,MAAQO,KAAAA,GAASC,KACV,SAASC,EAAWzB,GAC1B,OAAyB,IAAlBuB,EAAKvB,EACb,CCfO,SAAS0B,EAAQC,EAAOC,EAAKC,EAAMC,GACzC,IAAIC,EAAWJ,EACf,KAAOI,EAAWH,GACjBE,EAAYhC,KAAKiC,GACjBA,GAAYF,EAEb,OAAOC,CACR,CACO,SAASE,EAAUL,EAAOC,EAAKC,EAAMC,GAC3C,IAAIC,EAAWJ,EACf,KAAOI,EAAWH,GACjBE,EAAYhC,KAAKiC,GACjBA,GAAYF,EAEb,OAAOC,CACR,CAgBO,SAASG,EAAMN,EAAOC,EAAKC,EAAO,EAAGC,EAAc,IACzD,OAAIL,EAAWI,GACPC,EAEJH,EAAQC,EACJF,EAAQC,EAAOC,EAAKC,EAAMC,GAE1BE,EAAUL,EAAOC,EAAKC,EAAMC,EAErC,CCzCO,SAASnC,EAAQK,EAAQkC,GAE/B,OADAlC,EAAOL,QAAQuC,GACRlC,CACR,CCUY,MAACmC,EAAUC,MAAMD,QCEtB,SAASE,EAAYrC,GAC3B,OAAQmC,EAAQnC,IAAWA,GAAYS,EAAST,IAAW,CAACA,IAAY,EACzE,CCHO,SAASsC,EAAYtC,GAC3B,OAAOA,EAAOuC,KAAKC,IACpB,CCKA,MAAMC,EAAmBC,QAAQC,UAE1B,SAASA,EAAUC,EAAQC,EAAgB,GAAIC,GACrD,MAAMC,EAAQZ,EAAQU,GAAkBA,EAAgB,CAACA,GACzD,OAAIC,EACIL,EAAiBG,EAAQG,EAAMD,GAEhCL,EAAiBG,EAAQG,EACjC,CCXO,SAASC,KAAcC,GAC7B,MAAMC,EAAiBP,EAAUQ,KAC3BC,EAAc,GAuBpB,OAtBAzC,EAAUsC,GAAS,CAACI,EAAcC,KACjC3C,EAAU0C,GAAc,CAACE,EAAOC,KAC/B,IAAIC,EAAYP,EAAeQ,IAAIH,GACnC,GAAKE,EAOE,IAAIA,EAAUH,cAAgBA,EACpC,OAEAG,EAAUE,OACV,MAVAF,EAAY,CACXE,MAAO,EACPL,cACAC,SAEDL,EAAeU,IAAIL,EAAOE,EAK1B,GACA,IAEH9D,EAAQuD,GAAiBtD,IACL,IAAfA,EAAK+D,OAAoC,IAArB/D,EAAK0D,aAC5BF,EAAYtD,KAAKF,EAAK2D,MACtB,IAEKH,CACR,CC5BO,SAASS,EAAKtE,EAAOuE,EAAS,EAAGC,EAAOxE,EAAMU,QACpD,OAAOV,EAAMyE,OAAOF,EAAQC,EAC7B,CCDY,MAACE,EAAY,CAAC1E,EAAOuE,EAAS,EAAGC,EAAOxE,EAAMU,SAClD4D,EAAKtE,EAAO,EAAGwE,EAAOD,GCGvB,SAASI,EAAUlE,EAAQY,EAAUC,GAC3C,IAAKb,EACJ,OAED,MAAMc,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQoB,EAAc,EAAEpB,GAAS,EAAEA,IAC3CkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,EAAaD,GAErD,OAAOb,CACR,CCXOmB,eAAegD,EAAenE,EAAQY,GAC5C,IAAKZ,EACJ,OAED,MAAMc,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQoB,EAAc,EAAGpB,GAAS,EAAGA,UACvCkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,GAE9C,OAAOd,CACR,CCNO,SAASoE,EAAWpE,EAAQY,EAAUC,GAC5C,IAAKb,EACJ,OAED,MAAMqE,EAAerE,EAAOC,OAC5B,IAAK,IAAIP,EAAQ,EAAEA,EAAQ2E,EAAa3E,IACvC,IAAuE,IAAnEkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQqE,EAAcxD,GACxD,OAAO,EAGT,OAAO,CACR,CCXOM,eAAemD,EAAgBtE,EAAQY,EAAUC,GACvD,IAAKb,EACJ,OAED,MAAMqE,EAAerE,EAAOC,OAC5B,IAAK,IAAIP,EAAQ,EAAEA,EAAQ2E,EAAa3E,IACvC,IAA6E,UAAnEkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQqE,EAAcxD,GAC9D,OAAO,EAGT,OAAO,CACR,CCXO,SAAS0D,EAAYvE,EAAQY,EAAUI,EAAU,GAAIH,GAM3D,OALAF,EAAUX,GAAQ,CAACJ,EAAMF,EAAOuB,EAAeH,MAC+B,IAAzEF,EAAShB,EAAMF,EAAOsB,EAASC,EAAeH,EAAaD,IAC9DG,EAAQlB,KAAKF,EACb,IAEKoB,CACR,CCPOG,eAAeqD,EAAiBxE,EAAQY,EAAUI,EAAU,GAAIH,GAMtE,aALMO,EAAepB,GAAQmB,MAAOvB,EAAMF,EAAOuB,EAAeH,MACoB,UAAzEF,EAAShB,EAAMF,EAAOsB,EAASC,EAAeH,EAAaD,IACpEG,EAAQlB,KAAKF,EACb,IAEKoB,CACR,CCfO,SAASyD,EAAMlF,EAAOwE,GAC5B,OAAO,EAASxE,EAAMY,MAAM,EAAG4D,GAAQxE,EAAM,EAC9C,CCDO,SAASmF,EAAQ1E,EAAQ2E,EAAQ,GACvC,IAAK3E,EACJ,OAED,IAAI8B,EAAc9B,EAClB,IAAK,IAAI4E,EAAI,EAAGA,EAAID,EAAOC,IAC1B9C,EAAcA,EAAY+C,QAAO,CAACC,EAAeC,IACzCD,EAAcE,OAAO3C,EAAY0C,KACtC,IAEJ,OAAOjD,CACR,CCbO,SAASmD,EAAQ1F,GACvB,OAAOA,EAAMY,MAAM,EAAGZ,EAAMU,OAAS,EACtC,CCEO,SAASiF,EAAa3F,KAAU4F,GACtC,OAAOpE,EAAgBxB,GAAQK,IAI9B,GAHqBwE,EAAWe,GAASC,GACjCA,EAAUC,SAASzF,KAG1B,OAAOA,CACP,GAEH,CCdA,MAAM0F,EAAaC,OAAOC,KACnB,SAASA,EAAKxF,GACpB,GAAIA,EACH,OAAOsF,EAAWtF,EAEpB,CCjBA,MAAMyF,EAAc,QACdC,EAAoB,KACpBC,EAAc,GAcb,SAASC,EAAO5F,GACtB,OAAOA,EAAO6F,QAAQH,EAAmBC,GAAaG,MAAML,EAC7D,CCKO,SAAS/B,EAAIqC,EAAgBnD,GACnC,IAAKA,EACJ,OAAO,EAER,IAAIoD,EAAOpD,EAMX,OAJAwB,EADmBjC,EAAQ4D,GAAmBA,EAAiBH,EAAOG,IAC/CnG,IACtBoG,EAAOA,EAAKpG,GACLa,EAASuF,MAEVA,CACR,CC9BA,MAAMC,EAASV,OAAOU,OAef,SAASC,EAAQlG,KAAWmG,GAClC,GAAKnG,EAGL,OAAOoE,EAAW+B,GAAavG,IAC9B,MAAMwG,EAAYR,EAAOhG,GACzB,GAAyB,IAArBwG,EAAUnG,OACb,OAAOgG,EAAOjG,EAAQJ,GAChB,CACN,MAAMyG,EAAWD,EAAUE,MACrBC,EAAoB7C,EAAI0C,EAAWpG,GACzC,QAAIuG,GACIN,EAAOM,EAAmBF,EAGlC,IAEH,CAgBO,SAASG,EAAWxG,KAAWmG,GACrC,GAAKnG,EAGL,OAAOO,QAAQ4F,EAAWM,MAAM7G,IAC/B,MAAMwG,EAAYR,EAAOhG,GACzB,GAAyB,IAArBwG,EAAUnG,OACb,OAAOgG,EAAOjG,EAAQJ,GAChB,CACN,MAAMyG,EAAWD,EAAUE,MACrBC,EAAoB7C,EAAI0C,EAAWpG,GACzC,QAAIuG,GACIN,EAAOM,EAAmBF,EAGlC,KAEH,CCvDY,MAACK,EAAiBC,KACzBlG,EAASkG,IAEO,YADZA,EAAMC,YAAYC,WAAWC,OAClC3G,MAAM,EAAG,ICHN,SAAS4G,EAAcnE,EAAQ5C,GACrC,OAAO4C,GAAQgE,cAAgB5G,IAAU,CAC1C,CACO,SAASgH,EAAqBhH,GACpC,OAAQ4C,GACAmE,EAAcnE,EAAQ5C,EAE/B,CACO,SAASiH,EAAgBjH,GAC/B,OAAOA,GAAQ4G,aAAaM,IAC7B,CACO,SAASC,EAAyBnH,GACxC,OAAQ4C,GACAqE,EAAgBrE,KAAY5C,IAAU,CAE/C,CC5BO,SAASoH,EAAcC,GAC7B,OAAO,SAASC,KAAkBC,GACjC,OAAIA,EACIF,EAAOC,IAAkBlD,EAAWmD,EAAcF,GAEnDA,EAAOC,EAChB,CACA,CCMY,MAACE,EAAeL,EAAyB,UACxCM,EAAWL,EAAcI,GCMzBE,GAAU,CAAC1H,EAAQ4C,KAC/B,GAAI5C,IAAW4C,EACd,OAAO,EACD,GAAI6E,EAASzH,GACnB,OAAOA,EAAO2H,OAAO/E,GACf,GAAI5C,EAAO6G,aAAejE,EAAOiE,WACvC,GAAIH,EAAc1G,GAAS,CAC1B,MAAM4H,EAAmBpC,EAAKxF,GAC9B,GAAIkG,EAAQtD,EAAQgF,GACnB,OAAOxD,EAAWwD,GAAmB/H,GAC7B6H,GAAQ1H,EAAOH,GAAM+C,EAAO/C,KAGxC,MAAS,GAAIsC,EAAQnC,IACdA,EAAOC,SAAW2C,EAAO3C,OAC5B,OAAOmE,EAAWpE,GAAQ,CAACJ,EAAMF,IACzBgI,GAAQ9H,EAAMgD,EAAOlD,MAKhC,OAAO,CAAK,EC1BN,SAASmI,GAAa7H,EAAQ8H,GACpC,OAAI9H,EAAOC,SAAW6H,EAAa7H,QAC3BmE,EAAWpE,GAAQ,CAACJ,EAAMF,IACzBgI,GAAQI,EAAapI,GAAQE,IAIvC,CCvBA,MAAMmI,GAAgBvG,KAAKwG,IAcpB,SAASC,GAAQ1I,GACvB,OAAOwI,MAAiBxI,EACzB,CCFO,SAAS2I,GAAK3I,EAAO4I,GAC3B,MAAMrH,EAAcvB,EAAMU,OAC1B,OAAO,EAAcV,EAAMY,MAAMW,EAAcqH,EAAWrH,GAAevB,EAAMuB,EAAc,EAC9F,CCIO,SAASsH,GAASpI,EAAQY,EAAUI,EAAU,GAAIH,GAIxD,OAHAF,EAAUX,GAAQ,CAACJ,EAAMF,EAAOuB,EAAeH,KAC9CE,EAAQtB,GAASkB,EAAShB,EAAMF,EAAOsB,EAASC,EAAeH,EAAaD,EAAS,IAE/EG,CACR,CCROG,eAAekH,GAAcrI,EAAQY,GAC3C,MAAMI,EAAU,GAIhB,aAHMI,EAAepB,GAAQmB,MAAOvB,EAAMF,EAAOoB,KAChDE,EAAQtB,SAAekB,EAAShB,EAAMF,EAAOoB,EAAY,IAEnDE,CACR,CCHO,SAASsH,GAActI,EAAQY,EAAUI,EAAU,GAAIH,GAC7D,IAAI0H,EAAY,EAChB,MAAMzH,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQoB,EAAc,EAAEpB,GAAS,EAAEA,IAC3CsB,EAAQuH,GAAa3H,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,EAAaD,GACzE0H,IAED,OAAOvH,CACR,CCRO,SAASwH,GAASxI,EAAQY,EAAUI,EAAU,GAAIH,GACxD,MAAMC,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQ,EAAEA,EAAQoB,EAAYpB,IAAS,CAC/C,MAAME,EAAOI,EAAON,GAEpB,IAAiB,IADAkB,EAAShB,EAAMF,EAAOsB,EAAShB,EAAQc,EAAaD,GAEpE,MAEDG,EAAQtB,GAASE,CACjB,CACD,OAAOoB,CACR,CClBO,SAASyH,GAASC,EAASC,GACjC,OAAOD,EAAUC,CAClB,CCHO,SAASC,GAAoBC,GACnC,OAAOA,EAAWC,KAAKL,GACxB,CCAO,SAASM,GAAc/I,EAAQmG,GACrC,MAAM6C,EAAe,CAAA,EAIrB,OAHArI,EAAUX,GAAQ,CAACJ,EAAMC,KACxBmJ,EAAa7C,EAAWtG,IAAQD,CAAI,IAE9BoJ,CACR,CCCO,SAASC,GAAU1J,EAAO2J,GAChC,MAAMC,EAAW,GACjB,MAAO,CACNpI,EAAgBxB,GAAO,CAACK,EAAMF,KAC7B,GAAIwJ,EAAUtJ,EAAMF,GACnB,OAAOE,EAERuJ,EAASrJ,KAAKF,EAAK,IAEpBuJ,EAEF,CCnBO,SAASC,GAAgBT,EAAYD,GAC3C,OAAOA,EAAUC,CAClB,CCHO,SAASU,GAAoBR,GACnC,OAAOA,EAAWC,KAAKM,GACxB,CCCO,SAASE,GAAO/J,EAAOgK,GAC7B,IAAIzI,EAAcvB,EAAMU,OACxB,IAAK,IAAIP,EAAQ,EAAGA,EAAQoB,EAAapB,IAAS,CACjD,MAAME,EAAOL,EAAMG,GACf6J,EAAYlE,SAASzF,KACxBL,EAAMyE,OAAOtE,EAAO,GACpBA,IACAoB,IAED,CACD,OAAOvB,CACR,CAcO,SAASiK,GAASxJ,EAAQY,GAChC,IAAIE,EAAcd,EAAOC,OACzB,IAAK,IAAIP,EAAQ,EAAGA,EAAQoB,EAAapB,IAAS,CAE7CkB,EADSZ,EAAON,GACDA,KAClBM,EAAOgE,OAAOtE,EAAO,GACrBA,IACAoB,IAED,CACD,OAAOd,CACR,CCvCO,SAASyJ,GAAKlK,GACpB,OAAOA,EAAMY,MAAM,EAAGZ,EAAMU,OAC7B,CCDO,SAASyJ,GAAM1J,EAAQ8D,GAC7B,OAAO9D,EAAOA,EAAOC,OAAS,EAAI6D,EACnC,CChBA,MAAM6F,MACLA,GACDC,OAACA,IACGpI,KAeG,SAASqI,GAAU7B,EAAK8B,EAAM,GACpC,OAAOH,GAAMC,MAAY5B,EAAM8B,IAAQA,CACxC,CCpBA,MAaaC,GAbO3H,MAae4H,KCC5B,SAASC,GAAcjK,EAAQ4C,GACrC,OAAO5C,IAAW4C,CACnB,CCAO,SAASsH,GAAQtH,EAAQkB,EAASlB,EAAO3C,QAC/C,GAAI2C,EAAO3C,QAAU,EACpB,OAAO8J,GAAQnH,GAEhB,MAAMuH,EAAeJ,GAAQnH,GAC7B,IACIlD,EACAiH,EAFAhD,EAAQ,EAGZ,KAAOA,EAAQG,GACdpE,EAAQmK,GAAUM,EAAalK,OAAS,EAAG,GAC3C0G,EAAQwD,EAAaxG,GACrBwG,EAAaxG,GAASwG,EAAazK,GACnCyK,EAAazK,GAASiH,EACtBhD,IAED,OAAOwG,CACR,CCXO,SAASC,GAAOpK,EAAQ8D,GAC9B,IAAK9D,EACJ,OAAO,EAER,MAAMc,EAAcd,EAAOC,OAC3B,GAAIa,IAAgBgD,GAAUA,EAAShD,EACtC,OAAOoJ,GAAQlK,GAEhB,GAAe,IAAX8D,EACH,MAAO,CAAC9D,EAAO6J,GAAU/I,EAAc,EAAG,KAE3C,MAAMuJ,EAAc,GACdC,EAAO,CAAA,EACb,IACI5K,EADAiE,EAAQ,EAEZ,KAAOA,EAAQG,GACdpE,EAAQmK,GAAU7J,EAAOC,OAAS,EAAG,GAChCqK,EAAK5K,KACT2K,EAAYvK,KAAKE,EAAON,IACxB4K,EAAK5K,IAAS,EACdiE,KAGF,OAAO0G,CACR,CC7CA,MAAME,GAAgB/I,KAAKsI,IAcpB,SAASU,GAASjL,GACxB,OAAOgL,MAAiBhL,EACzB,CCDO,SAASkL,GAAqBzK,EAAQ4C,GAC5C,IAAI8H,EAAc,EAUlB,OATAtG,EAAWpE,GAAQ,CAACJ,EAAMF,KACzBgL,EAAchL,EACVkD,GAAUhD,IACb8K,EAAchL,EAAQ,GACf,MAKFgL,CACR,CCbO,SAASC,GAAK3K,EAAQ4K,EAAW,GACvC,OAAO5K,EAAOG,MAAM,EAAGyK,EACxB,CCFO,SAASC,GAAU7K,EAAQ8K,EAAa,GAC9C,MAAMhK,EAAcd,EAAOC,OAC3B,OAAOD,EAAOG,MAAMW,EAAcgK,EAAYhK,EAC/C,CCjBO,SAASiK,GAAWpE,EAAOjH,EAAOH,GACxC,OAAOA,EAAMyL,QAAQrE,KAAWjH,CACjC,CACO,SAASuL,GAAWrL,EAAMF,EAAOH,GACvC,OAAOK,IAASL,EAAMG,EAAQ,EAC/B,CAeO,SAASwL,GAAOlL,EAAQmL,GAC9B,OAAIA,EACInL,EAAOoL,OAAOH,IAEfjL,EAAOoL,OAAOL,GACtB,CCVO,SAASM,MAASlG,GACxB,OAAO+F,GAAO5I,EAAY6C,GAC3B,CCKO,SAASmG,GAAgBtL,EAAQY,GACvC,MAAMyD,EAAerE,EAAOC,OAC5B,IAAK,IAAIP,EAAQ,EAAEA,EAAQ2E,EAAa3E,IACvC,IAAuC,IAAnCkB,EAASZ,EAAON,GAAQA,GAC3B,OAAO,EAGT,OAAO,CACR,CCRO,SAAS6L,GAAevL,EAAQY,GACtC,MAAMyD,EAAerE,EAAOC,OAC5B,IAAK,IAAIP,EAAQ,EAAEA,EAAQ2E,EAAa3E,IACvC,IAAuC,IAAnCkB,EAASZ,EAAON,GAAQA,GAC3B,OAAO,EAGT,OAAO,CACR,CCRO,SAAS8L,GAAgBxL,EAAQY,EAAUI,EAAU,GAAIH,GAC/D,IAAInB,EAAQ,EACZ,KAAOA,EAAQM,EAAOC,QAAQ,CAC7B,MAAMqB,EAASN,EAAQlB,KAAKc,EAASZ,EAAON,GAAQA,EAAOM,EAAQA,EAAOC,OAAQY,IAClFnB,IACIe,EAASa,IACZN,EAAQlB,KAAKwB,EAEd,CACD,OAAOtB,CACR,CCXO,SAASyL,GAAezL,EAAQY,EAAUC,GAChD,IAAInB,EAAQ,EACZ,KAAOA,EAAQM,EAAOC,QACrBW,EAASZ,EAAON,GAAQA,EAAOM,EAAQA,EAAOC,OAAQY,GACtDnB,IAED,OAAOM,CACR,CCJO,SAAS0L,GAAc1L,EAAQY,EAAUI,EAAU,GAAIH,GAC7D,IAAInB,EAAQ,EACZ,KAAOA,EAAQM,EAAOC,QACrBe,EAAQlB,KAAKc,EAASZ,EAAON,GAAQA,EAAOM,EAAQA,EAAOC,OAAQY,IACnEnB,IAED,OAAOM,CACR,CChBO,SAAS2L,GAAQ/I,EAAQK,GAC/B,IAAKA,EACJ,OAAOL,EAER,MAAMgJ,EAAajJ,EAAUkJ,IAAK5I,GAClC,OAAOL,EAAOwI,QAAQxL,IACbgM,EAAWE,IAAIlM,IAEzB,CCNO,SAASmM,MAAO9I,GACtB,MAAM+I,EAASrJ,EAAUQ,KACnB8I,EAAQ,GAEd,OAAsB,IADAhJ,EAAQhD,OAEtB+C,EAAWC,EAAQ,GAAIA,EAAQ,KAEvCtC,EAAUsC,GAAS,CAACI,EAAcC,KACjC3C,EAAU0C,GAAc,CAACE,EAAOC,KAC/B,IAAIC,EAAYuI,EAAOtI,IAAIH,GAC3B,GAAKE,EAOE,IAAIA,EAAUH,cAAgBA,EACpC,OAEAG,EAAUE,OACV,MAVAF,EAAY,CACXE,MAAO,EACPL,cACAC,SAEDyI,EAAOpI,IAAIL,EAAOE,EAKlB,GACA,IAEH9D,EAAQqM,GAASpM,IACG,IAAfA,EAAK+D,OACRsI,EAAMnM,KAAKF,EAAK2D,MAChB,IAEK0I,EACR,CClCO,SAASC,MAAO/G,GACtB,OAAOA,EAAO,GAAGgH,KAAI,CAACvM,EAAMF,IACpByF,EAAOgH,KAAK5M,GACXA,EAAMG,MAGhB,CAcO,SAAS0M,GAAMpM,GACrB,OAAOA,EAAO,GAAGmM,KAAI,CAACvM,EAAMF,IACpBM,EAAOmM,KAAKE,GACXA,EAAS3M,MAGnB,CCxBO,SAAS4M,GAAatM,GAC5B,OAAQyH,EAASzH,IAAWA,GAAYS,EAAST,IAAWuM,OAAOvC,KAAKhK,IAAYuM,OAAOC,MAAM,EAClG,CCJO,SAASC,GAAYzM,GAE3B,OADAA,EAAO0M,KAAK,GACL1M,CACR,CCAO,SAAS2M,GAAQC,EAAYhM,GACnC,MAAMiM,EAAS,CAAA,EACf,IAAIvL,EAQJ,OAPAX,EAAUiM,GAAahN,IACtB0B,EAASV,EAAShB,GACbiN,EAAOvL,KACXuL,EAAOvL,GAAU,GAElBuL,EAAOvL,IAAS,IAEVuL,CACR,CCZO,SAASC,GAASF,EAAYG,GACpC,IAAIpJ,EAAQ,EAMZ,OALAhD,EAAUiM,GAAahN,IAClBA,EAAKmN,IACRpJ,GACA,IAEKA,CACR,CCRO,SAASqJ,GAAgBJ,EAAYG,GAC3C,IAAIpJ,EAAQ,EAMZ,OALAhD,EAAUiM,GAAahN,IACjBA,EAAKmN,IACTpJ,GACA,IAEKA,CACR,CCvBO,SAASsJ,GAAeC,EAASxN,EAAOH,EAAO4N,EAAYJ,GACjE,GAAIG,EAAQH,KAAkBI,EAC7B,OAAO,CAET,CCYO,SAASC,GAAUR,EAAYS,EAAIN,EAAe,MACxD,MAAMzL,EAASsL,EAAWQ,WAAU,CAACF,EAASxN,IACtCuN,GAAeC,EAASxN,EAAOkN,EAAYS,EAAIN,KAEvD,OAAoB,IAAZzL,GAAyBA,CAClC,CCLO,SAASgM,GAASV,EAAYS,EAAIN,EAAe,MACvD,MAAMzL,EAASsL,EAAWnG,MAAK,CAACyG,EAASxN,IACjCuN,GAAeC,EAASxN,EAAOkN,EAAYS,EAAIN,KAEvD,OAAoB,IAAZzL,GAAyBA,CAClC,CCHO,SAASiM,GAA+BC,EAAUC,EAAMV,EAAcW,GAC5E,MAAMC,EAAcH,EAAST,GACvBa,EAAUH,EAAKV,GACrB,OAAIY,IAAgBC,GAAWF,EACvBA,EAAQF,EAAUC,EAAMV,GAE3Ba,EAEOD,EAEDA,EAAcC,EACjB,EACGD,EAAcC,GAChB,EAEF,EANC,GAFC,CASV,CACO,SAASC,GAAyBjB,EAAYG,EAAe,KAAMW,GACzE,OAAOd,EAAW9D,MAAK,CAAC0E,EAAUC,IAC1BF,GAA+BC,EAAUC,EAAMV,EAAcW,IAEtE,CCbO,SAASI,GAA0BN,EAAUC,EAAMV,EAAcW,GACvE,MAAMC,EAAcH,EAAST,GACvBa,EAAUH,EAAKV,GACrB,OAAIY,IAAgBC,GAAWF,EACvBA,EAAQF,EAAUC,EAAMV,GAEzBY,EAAYI,cAAcH,EAClC,CACO,SAASI,GAA6BpB,EAAYG,EAAe,KAAMW,GAC7E,OAAOd,EAAW9D,MAAK,CAAC0E,EAAUC,IAC1BK,GAA0BN,EAAUC,EAAMV,EAAcW,IAEjE,CCpBO,SAASO,GAA8BT,EAAUC,EAAMV,EAAcW,GAC3E,MAAMC,EAAcH,EAAST,GACvBa,EAAUH,EAAKV,GACrB,OAAIY,IAAgBC,GAAWF,EACvBA,EAAQF,EAAUC,EAAMV,GAE3Ba,EAEOD,EAEDA,EAAcC,GAChB,EACED,EAAcC,EACjB,EAED,GANE,EAFD,CAST,CACO,SAASM,GAAwBtB,EAAYG,EAAe,KAAMW,GACxE,OAAOd,EAAW9D,MAAK,CAAC0E,EAAUC,IAC1BQ,GAA8BT,EAAUC,EAAMV,EAAcW,IAErE,CCvBO,SAASS,GAAWvB,EAAYG,EAAe,MACrD,OAAOmB,GAAwBtB,EAAYG,GAAc,EAC1D,CCDO,SAASqB,GAAUxB,EAAYG,GACrC,OAAOc,GAAyBjB,EAAYG,GAAc,GAAO,EAClE,CCFO,SAASsB,GAAQzB,EAAYhM,GACnC,MAAMoI,EAAe,CAAA,EAQrB,OAPArI,EAAUiM,GAAahN,IACtB,MAAMoB,EAAUJ,EAAShB,GACpBoJ,EAAahI,KACjBgI,EAAahI,GAAW,IAEzBgI,EAAahI,GAASlB,KAAKF,EAAK,IAE1BoJ,CACR,CCVO,SAASsF,GAAQ1B,EAAYG,EAAe,MAClD,MAAM/D,EAAe,CAAA,EAIrB,OAHArI,EAAUiM,GAAahN,IACtBoJ,EAAapJ,EAAKmN,IAAiBnN,CAAI,IAEjCoJ,CACR,CCPO,SAASuF,GAAO3B,EAAY4B,EAAU7H,GAC5C,OAAOyB,GAASwE,GAAY,CAAChN,EAAMF,IAC3BE,EAAK4O,GAAU7H,EAAOjH,IAE/B,CCGO,SAAS+O,GAAY7B,EAAY4B,EAAU7H,GACjD,OAAO0B,GAAcuE,GAAYzL,MAAOvB,EAAMF,IACtCE,EAAK4O,GAAU7H,EAAOjH,IAE/B,CCbY,MAACgP,GAAW1H,EAAqB2H,QCEtC,SAASC,GAAY5O,EAAQ6O,GACnC,GAAK7O,EAEE,OAAI0O,GAASG,GACZ7O,EAAO6O,GAERzG,GAASyG,GAAUjP,GAClBI,EAAOJ,IAEhB,CCRO,SAASkP,GAAMlC,EAAYiC,GACjC,OAAOzG,GAASwE,GAAahN,GACrBgP,GAAYhP,EAAMiP,IAE3B,CCHO,SAASE,GAAiCvB,EAAUC,EAAMV,EAAcW,GAC9E,MAAMC,EAAcH,EAAST,GACvBa,EAAUH,EAAKV,GACrB,OAAIY,IAAgBC,GAAWF,EACvBA,EAAQF,EAAUC,EAAMV,GAEzBa,EAAQG,cAAcJ,EAC9B,CACO,SAASqB,GAAoCpC,EAAYG,EAAe,KAAMW,GACpF,OAAOd,EAAW9D,MAAK,CAAC0E,EAAUC,IAC1BsB,GAAiCvB,EAAUC,EAAMV,EAAcW,IAExE,CClBO,SAASuB,GAAiBjP,GAChC,GAAIA,EACH,OAAOA,EAAOkP,UAAUlP,EAAOmP,YAAY,KAAO,EAEpD,CCJO,SAASC,GAAYpP,GAC3B,GAAIA,EACH,OAAOA,EAAOkP,UAAUlP,EAAOmP,YAAY,KAAO,EAEpD,CCfO,SAASE,GAAiBC,GAChC,OAAQ1P,KACCa,EAASb,IAAS0P,EAAUC,KAAK3P,EAE3C,CCQY,MAAC4P,GAAYH,GAAiB,UCA7BI,GAAaJ,GAAiB,WCA9BK,GAAWL,GAAiB,SCA5BM,GAAaN,GAAiB,WCSpC,SAASO,GAAM9L,EAAQ+L,GAC7B,IACIlJ,EADAmJ,EAAQhM,EAYZ,MAVkB,IAAIf,KACP,OAAV+M,GACHA,IAEGA,GAAS,IACZnJ,EAAQkJ,KAAY9M,GACpB+M,EAAQ,MAEFnJ,EAGT,CCtBO,SAASoJ,GAAIF,EAAU/L,GAC7B,MAAO,IAAIf,IACH8M,KAAY9M,EAAKiB,OAAO,EAAGF,GAEpC,CCHO,SAASkM,GAAOlM,EAAQ+L,GAC9B,IACIlJ,EADAmJ,EAAQhM,EAaZ,MAXmB,IAAIf,KACR,OAAV+M,GACHA,IAEGA,GAAS,EACZnJ,EAAQkJ,KAAY9M,GAEpB+M,EAAQ,KAEFnJ,EAGT,CC9BA,MAAMsJ,GAAe1K,OAAO2K,OAcrB,SAASA,GAAOtN,KAAWK,GACjC,GAAIL,EACH,OAAOqN,GAAarN,KAAWK,EAEjC,CCEY,MAACkN,GAAkBhP,MAAOnB,EAAQY,KAC7C,IAAKZ,EACJ,OAED,MAAMsF,EAAaE,EAAKxF,GAIxB,aAHMoB,EAAekE,GAAY,CAACzF,EAAKH,EAAOH,EAAO6Q,IAC7CxP,EAASZ,EAAOH,GAAMA,EAAKG,EAAQoQ,EAAe9K,KAEnDtF,CAAM,ECVP,SAASqQ,GAAWrQ,EAAQY,GAClC,IAAKZ,EACJ,OAGD,OAAOW,EADY6E,EAAKxF,IACK,CAACH,EAAKH,EAAO4Q,EAAUF,KACnDxP,EAASZ,EAAOH,GAAMA,EAAKG,EAAQoQ,EAAeE,EAAS,GAE7D,CC1BOnP,eAAeoP,GAAavQ,EAAQkC,GAC1C,MAAMsO,EAAS,GACTrK,EAAa,GACnB,IAAIsK,EAAe,EACnBzQ,EAAOL,SAAQ,CAACC,EAAMC,KACrB2Q,EAAOC,GAAgB7Q,EACvBuG,EAAWsK,GAAgB7Q,EAC3B6Q,GAAc,IAEf,IAAK,IAAI/Q,EAAQ,EAAGA,EAAQ+Q,EAAc/Q,UACnCwC,EAASsO,EAAO9Q,GAAQyG,EAAWzG,IAE1C,OAAOM,CACR,CCEY,MAAC0Q,GAAYvJ,EAAyB,OACrCwJ,GAAQvJ,EAAcsJ,ICf5B,SAASE,GAAM5Q,EAAQY,GAC7B,GAAI+P,GAAM3Q,GAAS,CAClB,IAAK,MAAM2G,KAAS3G,EACnBY,EAAS+F,EAAO3G,GAEjB,OAAOA,CACP,CACD,IAAK,MAAOH,EAAK8G,KAAU3G,EAC1BY,EAAS+F,EAAO9G,EAAKG,GAEtB,OAAOA,CACR,CCGY,MAAC6Q,GAAkB1J,EAAyB,qBAC3C2J,GAAc1J,EAAcyJ,ICdlC1P,eAAe4P,GAAW/Q,EAAQY,EAAUoQ,GAClD,GAAIL,GAAM3Q,GAAS,CAClB,IAAK,MAAM2G,KAAS3G,QACbY,EAAS+F,EAAO3G,GAEvB,OAAOA,CACP,CACD,GAAI8Q,GAAY9Q,GACf,UAAW,MAAMJ,KAAQI,KAAUgR,SAC5BpQ,EAAShB,EAAMI,GAGvB,IAAK,MAAOH,EAAK8G,KAAU3G,QACpBY,EAAS+F,EAAO9G,EAAKG,GAE5B,OAAOA,CACR,CCJY,MAACiR,GAAcjR,KAClBS,EAAST,IAAWA,aAAkBkR,SCDlCC,GAAchK,EAAyB,iBACvCiK,GAAUhK,EAAc+J,ICT9B,SAASE,GAAaC,EAAWC,EAAgBC,EAAYC,EAAiBC,EAAWC,GAC/F,MAAO,CAAC3R,EAAQY,EAAUI,KACzB,IAAIE,EACJ,MAAM0Q,EAAkBR,GAAQxQ,GAChC,GAAKH,EAAST,IAAYY,EAa1B,OAVCM,EADUiB,EAAQnC,GACP,EAAoBuR,EAAiBD,EACtC5K,EAAc1G,IAAWiR,GAAWjR,GACnC,EAAoByR,EAAkBD,EACvCE,EACC,EAAoBC,EAAiBD,EACtCZ,GAAY9Q,GACX2R,EAEA,EAAoBF,EAAkBD,EAE3CtQ,EAASlB,EAAQY,EAAUI,EAAQ,CAE5C,CCEY,MAAC6Q,GAAOR,GAAa1Q,EAAWS,EAAgBiP,GAAYF,GAAiBS,GAAOG,ICrBzF,MAAMe,GACZ,WAAAlL,CAAYmL,GACXC,KAAKC,eAAeF,EACpB,CACD,cAAAE,CAAeF,GACd,MAAMG,EAAYF,KAClBH,GAAKE,GAAS,CAAC1K,EAAQ8K,KACtBD,EAAUC,GAAc,YAAYpP,GAEnC,OADAiP,KAAKrL,MAAQU,EAAO+K,KAAKF,EAAWA,EAAUvL,SAAU5D,GACjDmP,CACX,CAAI,GAEF,CACD,QAAAG,CAAS1L,GAER,OADAqL,KAAKrL,MAAQA,EACNqL,IACP,CACD,IAAAM,GACC,MAAM3L,EAAQqL,KAAKrL,MAEnB,OADAqL,KAAKrL,MAAQ,KACNA,CACP,CACDA,MAAQ,KAoBF,SAAS4L,GAAMC,GACrB,OAAO7P,EAAUmP,GAAO,CAACU,GAC1B,CChCO,SAASC,GAAM5C,EAAU6C,EAAQ7C,EAAS5P,QAChD,MAAM0S,EAAU,GACVC,EAAU,IAAIC,KAEnB,GADAF,EAAQ7S,QAAQ+S,GACZF,EAAQ1S,SAAWyS,EAAO,CAC7B,MAAMpR,EAASuO,KAAY8C,GAE3B,OADA5S,EAAW4S,GACJrR,CACP,CACD,OAAOsR,CAAO,EAEf,OAAOA,CACR,CCbO,SAASE,GAAWjD,EAAU6C,EAAQ7C,EAAS5P,QACrD,MAAM0S,EAAU,GACVC,EAAU,IAAIC,KAEnB,GADAF,EAAQI,WAAWF,GACfF,EAAQ1S,SAAWyS,EAAO,CAC7B,MAAMpR,EAASuO,KAAY8C,GAE3B,OADA5S,EAAW4S,GACJrR,CACP,CACD,OAAOsR,CAAO,EAEf,OAAOA,CACR,CChBY,MAACI,IAAQ,EACRC,GAAW,IAChBD,GCFKE,IAAQ,EACRC,GAAY,IACjBD,GCJKE,GAAO,KACZ,ECQD,SAASC,GAAMvP,EAAQlD,GAC7B,IAAK,IAAIlB,EAAQ,EAAGA,EAAQoE,EAAQpE,IACnCkB,EAASlB,EAEX,CAmBO,SAAS4T,GAASxP,EAAQlD,EAAUI,EAAU,IACpD,IAAK,IAAItB,EAAQ,EAAGA,EAAQoE,EAAQpE,IACnCsB,EAAQtB,GAASkB,EAASkD,GAE3B,OAAO9C,CACR,CC3CO,MAAMuS,GACZC,KAAO7Q,EAAUQ,KACjB,SAAAR,GACC,CAYD,MAAA2G,CAAO+D,GACNoG,aAAapG,GACb2E,KAAKwB,KAAKE,OAAOrG,EACjB,CACD,GAAAvB,CAAIuB,GACH,OAAO2E,KAAKwB,KAAK1H,IAAIuB,EACrB,CACD,GAAA3J,CAAI2J,GACH,OAAO2E,KAAKwB,KAAK9P,IAAI2J,EACrB,CAcD,GAAAzJ,CAAIiM,EAAU8D,GACb,MAAMC,EAAc5B,KACd3E,EAAKwG,YAAW,KACrBhE,IACA+D,EAAYtK,OAAO+D,EAAG,GACpBsG,GAEH,OADA3B,KAAKwB,KAAK5P,IAAIyJ,EAAI2F,IACX3F,CACP,CAWD,KAAAyG,GACC,MAAMF,EAAc5B,KACpB4B,EAAYJ,KAAK7T,SAAS0N,IACzBuG,EAAYtK,OAAO+D,EAAG,GAEvB,EAEU,MAAC0G,GAASpR,EAAU4Q,IAgBzB,SAASS,GAAMnE,EAAU8D,GAC/B,OAAOI,GAAOnQ,IAAIiM,EAAU8D,EAC7B,CAaO,SAASM,KAEfZ,GADWQ,WAAWT,GAAM,IACjB1T,IACVqU,GAAOzK,OAAO5J,EAAM,GAEtB,CC3FY,MAACwU,GAAQxR,QAAQwR,MCOtB,SAASC,GAAStE,EAAU8D,GAClC,SAASS,KAAarR,GACjBqR,EAAU/G,KAAO6F,IACpBa,GAAOzK,OAAO8K,EAAU/G,IAEzB+G,EAAU/G,GAAK2G,IAAM,KACpBI,EAAUvE,YAAY9M,GACtBqR,EAAU/G,GAAK6F,EAAK,GAClBS,EACH,CASD,OARAS,EAAU/G,GAAK6F,GACfkB,EAAUvE,SAAWA,EAASwE,KAAKD,GACnCA,EAAUN,MAAQ,KACbM,EAAU/G,KAAO6F,KACpBa,GAAOzK,OAAO8K,EAAU/G,IACxB+G,EAAU/G,GAAK6F,GACf,EAEKkB,CACR,CCzBO,SAASE,GAASzE,KAAa9M,GACrC,GAAIkO,GAAWpB,GACd,OAAOA,KAAY9M,EAErB,CCGO5B,eAAeoT,GAAQvU,EAAQwU,GACrC,MAAM1T,EAAcd,EAAOC,OAC3B,IAAK,IAAIP,EAAQ,EAAGA,EAAQoB,EAAapB,IAAS,CACjD,MAAM2H,EAASrH,EAAON,SAChB2H,EAAOmN,EAAe9U,EAAOM,EAAQc,EAC3C,CACD,OAAOd,CACR,CCLY,MAACyU,GAAS,CAAC7H,EAAYjG,IAC3BkL,GAAKjF,GAAahN,IACxBA,EAAK+G,EAAM,ICbN,SAAS+N,GAAO7E,GACtB,MAAO,IAAI9M,KACF8M,KAAY9M,EAEtB,CCJO,SAAS4R,GAAOjV,EAAQ,GAC9B,MAAO,IAAIqD,IACHA,EAAKrD,EAEd,CCKY,MAACkV,GAAQ/E,IACpB,IAAIlJ,EAOJ,MANiB,IAAI5D,KACftC,EAASkG,KACbA,EAAQkJ,KAAY9M,IAEd4D,EAEO,ECXTxF,eAAe0T,GAAe7U,EAAQY,EAAUI,EAAU,CAAA,GAChE,GAAKhB,EAML,aAHMmQ,GAAgBnQ,GAAQmB,MAAOvB,EAAMC,EAAKiV,EAAY1E,EAAe9K,KAC1EtE,EAAQnB,SAAae,EAAShB,EAAMC,EAAKmB,EAAS8T,EAAY1E,EAAe9K,EAAW,IAElFtE,CACR,CCRO,SAAS+T,GAAU/U,EAAQY,EAAUI,EAAU,CAAA,GACrD,GAAKhB,EAML,OAHAqQ,GAAWrQ,GAAQ,CAACJ,EAAMC,EAAKyQ,EAAUF,EAAe9K,KACvDtE,EAAQnB,GAAOe,EAAShB,EAAMC,EAAKmB,EAASsP,EAAUF,EAAe9K,EAAW,IAE1EtE,CACR,CCfO,SAASgU,GAAQhV,GACvB,OAAOA,GAAQ4G,WAChB,CCAO,SAASqO,GAAUjV,EAAQ+C,EAAO,IACxC,MAAMmS,EAAaF,GAAQhV,GAC3B,OAAIkV,IAAehE,UACM,aAApBgE,EAAWhO,KACP,WAAW,EAGbvE,EAAUuS,EAAYnS,EAC9B,CCEO,SAASoS,GAASnV,EAAQY,EAAWF,EAAa0U,GACxD,MAAMpU,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,CAE3BuV,EADe3U,EAAS+F,EAAO3F,EAAShB,GAExC,CACD,OAAOgB,CACP,CACD,MAAMwU,EAAYvE,GAAWjQ,EAAQ4C,KACrC,IAAK,MAAO/D,EAAK8G,KAAU3G,EAAQ,CAClC,MAAMsB,EAASV,EAAS+F,EAAO9G,EAAKmB,EAAShB,GACzCwV,EACHxU,EAAQ4C,IAAI/D,EAAKyB,GAEjBN,EAAQnB,GAAOyB,CAEhB,CACD,OAAON,CACR,CCrBOG,eAAesU,GAAczV,EAAQY,EAAWF,EAAa0U,EAAepE,GAClF,GAAIF,GAAY9Q,GAAS,CACxB,MAAM0V,EAAmB,GACzB,UAAW,MAAM9V,KAAQI,KAAUgR,GAClC0E,EAAiB5V,WAAWc,EAAShB,EAAM8V,EAAkB1V,IAE9D,OAAO0V,CACP,CACD,MAAM1U,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,CAE3BuV,QADqB3U,EAAS+F,EAAO3F,EAAShB,GAE9C,CACD,OAAOgB,CACP,CACD,MAAMwU,EAAYvE,GAAWjQ,EAAQ4C,KACrC,UAAW,MAAO/D,EAAK8G,KAAU3G,EAAQ,CACxC,MAAMsB,QAAeV,EAAS+F,EAAO9G,EAAKmB,EAAShB,GAC/CwV,EACHxU,EAAQ4C,IAAI/D,EAAKyB,GAEjBN,EAAQnB,GAAOyB,CAEhB,CACD,OAAON,CACR,CC5BY,MAACmL,GAAMkF,GAAajJ,GAAUC,GAAe0M,GAAWF,GAAgBM,GAAUM,ICVvF,SAASE,GAAKC,GACpB,MAAO,IAAI7S,IACHoJ,GAAIyJ,GAAYhW,GACfA,KAAQmD,IAGlB,CCAO5B,eAAe0U,GAAiB7V,EAAQY,GAC9C,IAAKZ,EACJ,OAGD,OAAOsE,EADYkB,EAAKxF,IACW,CAACH,EAAKH,EAAO4Q,EAAUF,IAClDxP,EAASZ,EAAOH,GAAMA,EAAKG,EAAQoQ,EAAeE,IAE3D,CCTO,SAASwF,GAAY9V,EAAQY,GACnC,IAAKZ,EACJ,OAGD,OAAOoE,EADYoB,EAAKxF,IACM,CAACH,EAAKH,EAAO4Q,EAAUF,IAC7CxP,EAASZ,EAAOH,GAAMA,EAAKG,EAAQoQ,EAAeE,IAE3D,CCNO,SAASyF,GAAW/V,EAAQY,EAAWF,GAC7C,GAAIyB,EAAQnC,IAAW2Q,GAAM3Q,GAC5B,IAAK,MAAM2G,KAAS3G,EAAQ,CAE3B,IAAe,IADAY,EAAS+F,EAAO3G,GAE9B,OAAO,CAER,MAED,IAAK,MAAOH,EAAK8G,KAAU3G,EAAQ,CAElC,IAAe,IADAY,EAAS+F,EAAO9G,EAAKG,GAEnC,OAAO,CAER,CAEF,OAAO,CACR,CChBOmB,eAAe6U,GAAgBhW,EAAQY,EAAWF,EAAasQ,GACrE,GAAIF,GAAY9Q,GACf,UAAW,MAAMJ,KAAQI,KAAUgR,GAAgB,CAElD,IAAe,UADMpQ,EAAShB,EAAMI,GAEnC,OAAO,CAER,MACK,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GACnC,IAAK,MAAM2G,KAAS3G,EAAQ,CAE3B,IAAe,UADMY,EAAS+F,EAAO3G,GAEpC,OAAO,CAER,MAED,IAAK,MAAOH,EAAK8G,KAAU3G,EAAQ,CAElC,IAAe,UADMY,EAAS+F,EAAO9G,EAAKG,GAEzC,OAAO,CAER,CAEF,OAAO,CACR,CCvBY,MAACiW,GAAQ5E,GAAajN,EAAYE,EAAiBwR,GAAaD,GAAkBE,GAAYC,ICTnG,SAASE,GAAUC,GACzB,OAAQC,GACAH,GAAME,GAAajN,GAClBA,EAAUkN,IAGpB,CCJO,SAASC,GAAMxG,EAAUyG,GAC/B,MAAO,IAAIvT,IACH8M,KAAYyG,EAAQnK,KAAKvM,GACxBmD,EAAKnD,KAGf,CCJO,SAAS2W,GAAS1G,EAAU8D,GAClC,SAAS6C,KAAazT,GACjByT,EAAUnJ,GACbmJ,EAAUC,eAAiBzD,IAG5BwD,EAAU3G,YAAY9M,GACtByT,EAAUnJ,GAAK2G,IAAM,KAChBwC,EAAUC,gBACbD,EAAU3G,YAAY9M,GAEvByT,EAAUnJ,GAAK6F,EAAK,GAClBS,GACH,CAOD,OANA6C,EAAUnJ,GAAK6F,GACfsD,EAAU3G,SAAWA,EAASwE,KAAKmC,GACnCA,EAAU1C,MAAQ,KACjBC,GAAOzK,OAAOkN,EAAUnJ,IACxBmJ,EAAUnJ,GAAK6F,EAAK,EAEdsD,CACR,CCvBO,SAASE,GAAK/P,EAAOgQ,GAC3B,MAAO,IAAIP,IACHO,EAAQhQ,KAAUyP,EAE3B,CCPY,MAACQ,GAASrR,OAAOsR,GCbvBC,GAAoB5F,SAAS6F,UAc5B,SAASC,GAAkB3P,GACjC,OAAOyP,GAAkB1E,KAAKiC,KAAKhN,EACpC,CCHY,MAAC4P,GAAe1R,OAAO2R,oBActBC,GAAc5R,OAAO6R,yBAoBrBC,GAAU9R,OAAO+R,eACjBC,GAAUP,GAAkBzR,OAAOiS,gBClCzC,SAASlC,GAAImC,EAAQC,GAC3B,OAAOD,EAASC,CACjB,CCDO,SAASC,GAAO3X,GACtB,OAAOA,EAAS,CACjB,CCHO,SAAS4X,GAAO5X,EAAQ2G,GAC9B,OAAO3G,EAAS2G,CACjB,CCDO,SAASkR,GAAU7X,GACzB,OAAOA,EAAS,CACjB,CCHO,SAAS8X,GAAS9X,EAAQ2G,GAChC,OAAO3G,EAAS2G,CACjB,CCFO,SAASoR,GAAaC,EAAOC,GACnC,OAAc,IAAVD,IAGkB,IAAlBC,EACI,EAEAA,EAAgBD,EAAS,IAClC,CCtBA,MAAMpO,OAAEA,IAAWpI,KAgBZ,SAAS0W,GAAYlQ,EAAK8B,EAAM,GACtC,OAAOF,MAAY5B,EAAM8B,GAAOA,CACjC,CCFO,SAASqO,GAAUnY,EAAQ2G,GACjC,OAAO3G,EAAS2G,CACjB,CCLO,SAASyR,GAAYpY,GAC3B,OAAOA,EAAO6E,QAAO,CAACwT,EAAGC,IACjBD,EAAIC,GACT,EACJ,CCJO,SAASC,GAAOvY,GACtB,OAAOA,EAAO6E,QAAO,CAACwT,EAAGC,IACjBD,EAAIC,GACT,EACJ,CCDO,SAASE,GAAgBxY,EAAQ2B,EAAOC,GAC9C,OAAO5B,EAAS2B,GAAS3B,EAAS4B,CACnC,CCFO,SAAS6W,GAAmBzY,EAAQ2B,EAAOC,GACjD,OAAO5B,EAAS2B,GAAS3B,EAAS4B,CACnC,CCLA,MAAML,KAAEA,IAASC,KACV,SAASkX,GAAW1Y,GAC1B,OAAwB,IAAjBuB,GAAKvB,EACb,CCHO,SAAS2Y,GAAO3Y,GACtB,OAAkB,IAAXA,CACR,CCCO,SAAS4Y,GAAY/L,GAC3B,MAAMgM,EAAgB,GAMtB,OALAxI,GAAWxD,GAAQ,CAACjN,EAAMC,KACrBY,EAASb,IACZiZ,EAAc/Y,KAAKD,EACnB,IAEKgZ,CACR,CCHO1X,eAAe2X,GAAsB9Y,EAAQY,EAAWF,EAAaM,EAAU,CAAA,GAOrF,aANMmP,GAAgBnQ,GAAQmB,MAAOvB,EAAMC,EAAKyQ,EAAUF,EAAe9K,KACxE,MAAMhE,QAAeV,EAAShB,EAAMC,EAAKmB,EAASsP,EAAUF,EAAe9K,GACvE7E,EAASa,KACZN,EAAQnB,GAAOyB,EACf,IAEKN,CACR,CCPO,SAAS+X,GAAiB/Y,EAAQY,EAAWF,EAAaM,EAAU,CAAA,GAO1E,OANAqP,GAAWrQ,GAAQ,CAACJ,EAAMC,EAAKyQ,EAAUF,EAAe9K,KACvD,MAAMhE,EAASV,EAAShB,EAAMC,EAAKmB,EAASsP,EAAUF,EAAe9K,GACjE7E,EAASa,KACZN,EAAQnB,GAAOyB,EACf,IAEKN,CACR,CCZO,SAASgY,GAAahZ,EAAQY,EAAUI,EAAU,CAAA,GAMxD,OALAqP,GAAWrQ,GAAQ,CAACJ,EAAMC,EAAKyQ,EAAUF,EAAe9K,MACmB,IAAtE1E,EAAShB,EAAMC,EAAKmB,EAASsP,EAAUF,EAAe9K,KACzDtE,EAAQnB,GAAOD,EACf,IAEKoB,CACR,CCPOG,eAAe8X,GAAkBjZ,EAAQY,EAAUI,EAAU,CAAA,GAMnE,aALMmP,GAAgBnQ,GAAQmB,MAAOvB,EAAMC,EAAKyQ,EAAUF,EAAe9K,MACQ,UAAtE1E,EAAShB,EAAMC,EAAKmB,EAASsP,EAAUF,EAAe9K,KAC/DtE,EAAQnB,GAAOD,EACf,IAEKoB,CACR,CCTO,SAASkY,GAAOlZ,EAAQ4C,EAAS,IACvC,GAAK5C,EAML,OAHAqQ,GAAWrQ,GAAQ,CAACJ,EAAMC,KACzB+C,EAAOhD,GAAQC,CAAG,IAEZ+C,CACR,CCPY,MAACuW,GAAgB,CAACnZ,EAAQ4C,KACrC,GAAI5C,IAAW4C,EACd,OAAO,EAER,MAAMwW,EAAa5T,EAAKxF,GAClBqZ,EAAa7T,EAAK5C,GACxB,OAAIwW,EAAWnZ,SAAWoZ,EAAWpZ,QAC7BmE,EAAWgV,GAAavZ,GACvBG,EAAOH,KAAS+C,EAAO/C,IAGpB,ECdAyZ,GAAenS,EAAyB,UACxCoS,GAAWnS,EAAckS,ICDzBE,GAAcrS,EAAyB,UACvCsS,GAAUrS,EAAcoS,ICFxBE,GAAmB,4BACzB,SAASC,GAAY3Z,GAC3B,OAAOA,EAAO6F,QAAQ6T,GAAkB,OACzC,CCDO,SAASE,GAAa5Z,EAAQ6Z,GACpC,OAAIA,EACID,GAAaxR,GAASpI,EAAQ2Z,KAE/BG,OAAO9Z,EAAO+Z,KAAK,KAC3B,CCGO,SAASC,GAAKha,EAAQia,GAC5B,GAAKja,EAAL,CAGA,GAAImC,EAAQ8X,GAAY,CACvB,MAAMC,EAAiBN,GAAaK,GACpC,OAAOjB,GAAahZ,GAAQ,CAACJ,EAAMC,KAC1Bqa,EAAe3K,KAAK1P,IAE7B,CACD,GAAI4Z,GAAQQ,GACX,OAAOjB,GAAahZ,GAAQ,CAACJ,EAAMC,KAC1Boa,EAAU1K,KAAK1P,KAGzB,GAAI6O,GAASuL,GACZ,OAAOjB,GAAahZ,GAAQ,CAACJ,EAAMC,IAC3BA,IAAQoa,IAGjB,GAAIV,GAASU,GAAY,CACxB,MAAME,EAAiBF,EAAUpT,WACjC,OAAOmS,GAAahZ,GAAQ,CAACJ,EAAMC,IAC3BA,IAAQsa,GAEhB,CACD,OAAIlJ,GAAWgJ,GACPjB,GAAahZ,GAAQ,CAACJ,EAAMC,KAC1Boa,EAAUra,EAAMC,UAF1B,CAvBC,CA4BF,CCtCY,MAACua,GAAO,CAACpa,EAAQqa,EAAWzX,EAAS,CAAA,KAChD,GAAK5C,EAML,OAHAW,EAAU0Z,GAAYza,IACrBgD,EAAOhD,GAAQI,EAAOJ,EAAK,IAErBgD,CAAM,ECVP,SAAS0X,GAAWta,GAC1B,GAAKA,EAGL,OAAOwF,EAAKxF,GAAQC,MACrB,CCFY,MAACsa,GAAY,CAACpU,EAAYqK,KACrC,MAAMgK,EAAc,CAAA,EAIpB,OAHA7Z,EAAUwF,GAAY,CAACvG,EAAMC,KAC5B2a,EAAY5a,GAAQ4Q,EAAO3Q,EAAI,IAEzB2a,CAAW,EAeNC,GAAe5N,IAC3B,MAAM6N,EAAe,GACflK,EAAS,GAKf,OAJAH,GAAWxD,GAAQ,CAACjN,EAAMC,KACzB6a,EAAa5a,KAAKD,GAClB2Q,EAAO1Q,KAAKF,EAAK,IAEX,CAAC8a,EAAclK,EAAO,EC3CxBmK,GAAgB,UAcf,SAASC,GAAU5a,GACzB,IAAIsB,EAAS,GAUb,OATAtB,EAAO6F,QAAQ8U,GAAe,KAAK7T,OACjChB,MAAM,KACNnG,SAAQ,CAACC,EAAMF,KAEd4B,GADa,IAAV5B,EACOE,EAAKib,cAELjb,EAAK,GAAGkb,cAAgBlb,EAAKO,MAAM,GAAG0a,aAChD,IAEIvZ,CACR,CC1BA,MAAMqZ,GAAgB,UAChBI,GAAQ,QAcP,SAASC,GAAUhb,GACzB,OAAOA,EAAO6F,QAAQ,YAAa,OACjCA,QAAQ8U,GAAe,KACvB7T,OACA+T,cACAhV,QAAQkV,GAAO,IAClB,CCrBA,MAAMJ,GAAgB,UAChBI,GAAQ,QAcP,SAASE,GAAUjb,GACzB,OAAOA,EAAO6F,QAAQ,YAAa,OACjCA,QAAQ8U,GAAe,KACvB7T,OACA+T,cACAhV,QAAQkV,GAAO,IAClB,CCrBA,MAAMJ,GAAgB,UAef,SAASO,GAAUlb,GACzB,OAAOA,EACL6F,QAAQ,YAAa,OACrBA,QAAQ8U,GAAe,KACvB7T,OACAgU,aACH,CCrBA,MAAMH,GAAgB,UAef,SAASQ,GAAUnb,GACzB,OAAOA,EACL6F,QAAQ,YAAa,OACrBA,QAAQ8U,GAAe,KACvB7T,OACA+T,aACH,CCLO,SAASO,GAAcC,EAAQ3b,EAAO4b,GAC5C,OAAOD,EAAOlb,MAAM,EAAGT,GAAS4b,EAAOD,EAAOlb,MAAMT,EAAO2b,EAAOpb,OACnE,CAkBO,SAASsb,GAAYF,EAAQ3b,EAAQ,GAC3C,OAAO2b,EAAOA,EAAOpb,OAASP,EAC/B,CAgBO,SAAS8b,GAAYH,EAAQ7b,GACnC,OAAO6b,EAAOI,MAAM,IAAI3B,OAAO,gBAAgBta,KAAS,KACzD,CAkBO,SAASkc,GAAcL,EAAQ3b,EAAQ,GAC7C,OAAO2b,EAAOlb,MAAM,GAAY,EAATT,EACxB,CAkBO,SAASic,GAAWN,EAAQ3b,EAAQ,GAC1C,OAAO2b,EAAOO,OAAOlc,EACtB,CChFO,SAASmc,GAAYR,EAAQS,EAAOnV,GAC1C,OAAO0U,EAAOxV,QAAQ,IAAIiU,OAAO,MAAMgC,EAAM/B,KAAK,UAAW,MAAOpT,EACrE,CClBA,MAAMoV,GAAoB,oBACpBC,GAAW,KACXC,GAAgB,KAChBC,GAAgB,KAChBC,GAAmB,KAelB,SAASC,GAAaf,GAC5B,OAAOgB,mBAAmBhB,EAAOxV,QAAQkW,IAAmB,IACpD,QAET,CAeO,SAASO,GAAajB,GAC5B,OAAOA,EAAOxV,QAAQmW,GAAU,SAC9BnW,QAAQoW,GAAe,QACvBpW,QAAQqW,GAAe,QACvBrW,QAAQsW,GAAkB,SAC7B,CAeO,SAASI,GAASlB,GACxB,OAAOiB,GAAaF,GAAaf,GAClC,CC5DA,MAAMmB,GAAgB,OAChBC,GAAa,OAeZ,SAASC,GAASrB,GACxB,OAAOA,EAAOI,MAAMe,KAAkB,EACvC,CAcO,SAASV,GAAMT,GACrB,OAAOA,EAAOI,MAAMgB,KAAe,EACpC,CCOO,SAASE,GAAStB,EAAQuB,GAChC,MAAMC,EAAexB,EAAOpb,OAC5B,OAAQ4c,EAAeD,EA3CH,EAACvB,EAAQuB,EAAWC,KACxC,MAAMC,EAAWzB,EAAOvV,MAAM,IACxBiX,EAAiBD,EAAS7c,OAChC,IAAIL,EACAF,EAAQmd,EAAeD,EAC3B,KAAOld,EAAQqd,GAAkBrd,GAAS,IACzCE,EAAOkd,EAASpd,GACH,MAATE,GAFwCF,KAM7C,OAAO2b,EAAOlb,MAAM,EAAGT,GAAOoH,MAAM,EAgCAkW,CAAa3B,EAAQuB,EAAWC,GAAgBxB,CACrF,CAgBO,SAAS4B,GAAc5B,EAAQuB,GACrC,MAAMC,EAAexB,EAAOpb,OAC5B,OAAQ4c,EAAeD,EAjDL,EAACvB,EAAQuB,EAAWC,KACtC,MAAMC,EAAWzB,EAAOvV,MAAM,IACxBiX,EAAiBD,EAAS7c,OAChC,IAAIL,EACAF,EAAQkd,EACZ,KAAOld,EAAQqd,GAAkBrd,EAAQ,IACxCE,EAAOkd,EAASpd,GACH,MAATE,GAFuCF,KAM5C,OAAO2b,EAAOO,OAAOlc,EAAOmd,GAAc/V,MAAM,EAsCZoW,CAAW7B,EAAQuB,EAAWC,GAAgBxB,CACnF,CC9DA,MAAM8B,GAAmB,QAelB,SAASC,GAAiB/B,GAChC,OAAOA,EAAO,GAAGP,aAClB,CAeO,SAASuC,GAAWhC,GAC1B,OAAO+B,GAAiB/B,GAAUM,GAAWN,EAC9C,CAeO,SAASiC,GAAcjC,GAC7B,OAAOA,EAAOxV,QAAQsX,IAAmB1B,GACjCA,EAAMX,eAEf,CAeO,SAASyC,GAAelC,GAC9B,OAAO+B,GAAiB/B,GAAUM,GAAWN,GAAQR,aACtD,CAeO,SAAS2C,GAAkBnC,GACjC,OAAOkC,GAAelC,EAAOR,eAAehV,QAAQsX,IAAmB1B,GAC/DA,EAAMX,eAEf,CC7EO,SAAS2C,GAAYzd,GAC3B,OAAOgV,GAAQhV,IAASkH,IACzB,CCAO,SAASwW,GAAY1d,GAC3B,QAAQS,EAAST,IAFM,uBAEKA,EAAO6G,UACpC,CCDO,SAAS8W,GAAQ3d,GACvB,OAAQS,EAAST,EAClB,CCFY,MAAC4d,GAAYzW,EAAyB,OACrC0W,GAAQzW,EAAcwW,ICH7BE,GAAkB,QAClBC,GAAuB,QACtB,SAASC,GAAahe,GAC5B,GAAIA,EAAQ,CACX,MAAMiH,EAAkBwW,GAAYzd,GACpC,GAAI8d,GAAgBvO,KAAKtI,IAAoBA,IAAoB8W,GAChE,OAAO,CAER,CACD,OAAO,CACR,CCDO,SAASE,GAAYje,EAAQke,GACnC,GAAIP,GAAQ3d,IAAWiR,GAAWjR,GACjC,OAAO,EAER,GAAImC,EAAQnC,IAAWge,GAAahe,GACnC,OAAO,EAER,MAAMqE,EAAerE,EAAOC,OAC5B,IAAK0d,GAAQtZ,KAAkBkV,GAASlV,IAAiBA,EAAe,EACvE,OAAO,EAER,GAAI6Z,EAAY,CACf,MAAM5H,EAAU9Q,EAAKxF,GACrB,QAAIsW,GACIL,GAAMK,GAAS,CAAC3P,EAAOjH,IACtBA,GAAS,GAAK6Z,GAAS7Z,IAIhC,CACD,OAAO,CACR,CC9BY,MAACye,GAAehX,EAAyB,UACxCiX,GAAWhX,EAAc+W,ICAzBE,GAAgBlX,EAAyB,WACzCmX,GAAYlX,EAAciX,ICF1BE,GAAoBpX,EAAyB,eAC7CqX,GAAgBpX,EAAcmX,ICKpC,SAASE,GAAQC,EAAaC,GACpC,SAAKD,IAAgBC,IAGdD,aAAuBC,CAC/B,CCZA,MAAMC,GAAmB9E,OAAO,uKACzB,SAAS+E,GAAY7e,GAC3B,GAAIS,EAAST,GAAS,CACrB,MAAMiH,EAAkBjH,GAAQ4G,aAAaM,KAC7C,OAAO0X,GAAiBrP,KAAKtI,EAC7B,CACD,OAAO,CACR,CCNY,MAAC6X,GAAa3X,EAAyB,QACtC4X,GAAS3X,EAAc0X,ICG7B,SAASE,GAAQhf,GACvB,OAAI0O,GAAS1O,IAAWmC,EAAQnC,IACvBM,EAAUN,GACR0G,EAAc1G,IAChBsa,GAAWta,IAEZS,EAAST,EAClB,CCVO,SAASif,GAAQjf,GACvB,OAAkB,IAAXA,CACR,CCHY,MAACkf,GAAY/X,EAAyB,gBACrCgY,GAAQ/X,EAAc8X,ICAtBE,GAAYjY,EAAyB,gBACrCkY,GAAQjY,EAAcgY,KChB7BE,UAAEA,IAAcC,OAcTC,GAAUF,GCCVG,GAAYtY,EAAyB,cACrCuY,GAAQtY,EAAcqY,ICHtBE,GAAYxY,EAAyB,cACrCyY,GAAQxY,EAAcuY,ICCtBE,GAAW1Y,EAAyB,aACpC2Y,GAAO1Y,EAAcyY,ICD3B,SAASE,GAAW/f,GAC1B,OAAOS,EAAST,IAA8C,mBAA5BA,EAAOggB,OAAOC,SACjD,CCJO,SAASC,GAAUlgB,GACzB,QAAIA,GACIA,aAAkBmgB,OAG3B,CCHO,SAASC,GAAYpgB,GAC3B,QAAIA,IACIkgB,GAAUlgB,IAAWoR,GAAQpR,IAAW8Q,GAAY9Q,GAG7D,CCAO,SAASqgB,GAASC,EAAcC,GACtC,SAAKD,GAAiBC,GAAgBA,EAAYnO,OAG3CkO,aAAwBC,CAChC,CCZO,SAASC,GAAYxgB,GAC3B,MAAMygB,SAAc9Z,MACpB,OAAO3G,SAAqD,WAATygB,GAA8B,aAATA,CACzE,CCMO,SAASC,GAAUC,EAAWC,GACpC,OAAIjD,GAAQgD,KAAchD,GAAQiD,KAG9BD,EAAUvO,KACNwO,aAAqBD,EAEzBC,EAAUxO,KACNuO,aAAqBC,EAEtBA,EAAUha,cAAgB+Z,EAAU/Z,YAC5C,CCjCA,MAAMia,cAAEA,IAAkBtB,OAcbuB,GAAYD,GCblB,SAASE,GAAW/gB,EAAQghB,GAClC,MAAM9L,EAAaF,GAAQhV,GACrBihB,EAAYjM,GAAQgM,GAC1B,OAAI9L,IAAe+L,GACd/L,EAAWhO,OAAS+Z,EAAU/Z,IAKpC,CCKO,SAASga,GAAOlhB,GACtB,OAAkB,IAAXA,CACR,CCFY,MAACmhB,GAAYha,EAAyB,eACrCia,GAAQha,EAAc+Z,ICDtBE,GAAYla,EAAyB,eACrCma,GAAQla,EAAcia,ICDtBE,GAAWpa,EAAyB,cACpCqa,GAAOpa,EAAcma,ICDrBE,GAAYta,EAAyB,qBACrCua,GAAQta,EAAcqa,ICDtBE,GAAgBxa,EAAyB,WACzCya,GAAYxa,EAAcua,IChB1BE,QAAoC,IAApBC,WAAWC,KCA3BC,QAAyC,IAAvBF,WAAWG,SAA2BA,QAAQC,UAAYD,QAAQC,SAASC,KCenG,SAASC,GAASpiB,EAAQqiB,GAAe,GAC/C,OAAO9hB,QAAQP,IAAWqiB,CAC3B,CCFO,SAASC,GAAQtiB,EAAQqiB,GAAe,GAC9C,OAA2B,IAApB9hB,QAAQP,IAAqBqiB,CACrC,CCEO,SAASE,GAAQviB,EAAQ4C,EAAQ4f,EAAUzf,GACjD,GAAItC,EAAST,GAAS,CACrB,GAAIiR,GAAWrO,GACd,OAAI4f,EACItO,GAAMtR,EAAQ4f,EAAUzf,GAEzBH,KAAUG,GACX,GAAI2D,EAAc9D,GAExB,OADAA,EAAO4f,GAAYxiB,EACZ4C,CAER,CACF,CCfO,SAAS6f,GAASziB,EAAQ4C,GAChC,OAAOqc,GAAQvX,GAAQ1H,EAAQ4C,GAChC,CClBA,MAAM8f,GAAaC,KAeZ,SAASC,GAAU5iB,EAAQ6iB,GACjC,GAAI7iB,EACH,OAAO0iB,GAAWI,MAAM9iB,EAAQ6iB,EAElC,CAcY,MAACE,GAAYL,GAAWK,UCD7B,SAASC,GAAOhjB,EAAQijB,EAAUC,GAExC,QADyBjS,GAAWgS,KAA2C,IAA9BA,EAASjjB,EAAQkjB,MAC1CT,GAASziB,EAAQijB,IA/B1C,SAA2BjjB,EAAQijB,EAAUE,GAC5C,MAAMD,EAAUpB,WAAWoB,SAAWC,EACtC,IAAIC,EAMJ,OALInS,GAAWiS,GACdE,EAAa,GAAGF,EAAQhc,UAAUgc,EAAQtc,YAAYM,OAC5Cgc,IACVE,EAAa,GAAGF,EAAQG,OAASH,EAAQ7b,OAAOH,WAAWgc,EAAQI,QAE7D,IAAIC,MAAM,gBAAgBH,kBACtBL,GAAU/iB,qBACR+iB,GAAUE,KAAaC,EACrC,CAqBSM,CAAkBxjB,EAAQijB,EAAUC,EAG7C,CClBO,SAASO,GAAQ7W,EAAY8W,EAAUC,GAC7C,MAAM3iB,EAAUmL,GAAIS,GAAahN,GACzBqR,GAAWrR,GAAQA,EAAKyU,KAAKqP,GAAY9jB,IAEjD,OAAO,EAAiBsQ,GAAOyT,EAAc3iB,GAAWA,CACzD,CCRO,SAAS8S,GAAM9T,GACrB,GAAIA,EAAQ,CACX,GAAIyH,EAASzH,GACZ,OAAOyM,GAAYzM,GACb,GAAImC,EAAQnC,GAClB,OAAOD,EAAWC,GACRA,EAAO8T,MACjB9T,EAAO8T,QACG9T,EAAOC,SACjBD,EAAOC,OAAS,EAEjB,CACD,OAAOD,CACR,CCjBA,MAAM4jB,GAAsB9B,WAAW+B,gBAChC,SAASC,GAAM9jB,GACrB,OAAO4jB,GAAoB5jB,EAC5B,CCAO,SAAS+jB,GAAQ/jB,GACvB,GAAI0G,EAAc1G,GAAS,CAC1B,MAAMoZ,EAAa5T,EAAKxF,GAClBgkB,EAAmB5K,EAAWnZ,OAC9BgkB,EAAe,CAAA,EACrB,IAAK,IAAIrf,EAAI,EAAGA,EAAIof,EAAkBpf,IAAK,CAC1C,MAAMsf,EAAU9K,EAAWxU,GACrBhF,EAAOI,EAAOkkB,GACD9B,GAASxiB,KAE3BqkB,EAAaC,GAAWtkB,EAEzB,CACD,OAAOqkB,CACP,CACD,OAAOjkB,EAAOoL,QAAQxL,GACdwiB,GAASxiB,IAElB,CCPOuB,eAAegjB,GAAqBnkB,EAAQY,EAAWF,EAAa0U,EAAepE,GACzF,GAAIF,GAAY9Q,GAAS,CACxB,MAAM0V,EAAmB,GACzB,UAAW,MAAM9V,KAAQI,KAAUgR,GAAgB,CAClD,MAAM1P,QAAeV,EAAShB,EAAM8V,EAAkB1V,GAClDS,EAASa,IACZoU,EAAiB5V,KAAKwB,EAEvB,CACD,OAAOoU,CACP,CACD,MAAM1U,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,CAC3B,MAAMsB,QAAeV,EAAS+F,EAAO3F,EAAShB,GAC1CS,EAASa,IACZiU,EAAgBjU,EAEjB,CACD,OAAON,CACP,CACD,MAAMwU,EAAYvE,GAAWjQ,EAAQ4C,KACrC,UAAW,MAAO/D,EAAK8G,KAAU3G,EAAQ,CACxC,MAAMsB,QAAeV,EAAS+F,EAAO9G,EAAKmB,EAAShB,GAC/CS,EAASa,KACRkU,EACHxU,EAAQ4C,IAAI/D,EAAKyB,GAEjBN,EAAQnB,GAAOyB,EAGjB,CACD,OAAON,CACR,CCnCO,SAASojB,GAAgBpkB,EAAQY,EAAWF,EAAa0U,GAC/D,MAAMpU,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,CAC3B,MAAMsB,EAASV,EAAS+F,EAAO3F,EAAShB,GACpCS,EAASa,IACZiU,EAAgBjU,EAEjB,CACD,OAAON,CACP,CACD,MAAMwU,EAAYvE,GAAWjQ,EAAQ4C,KACrC,IAAK,MAAO/D,EAAK8G,KAAU3G,EAAQ,CAClC,MAAMsB,EAASV,EAAS+F,EAAO9G,EAAKmB,EAAShB,GACzCS,EAASa,KACRkU,EACHxU,EAAQ4C,IAAI/D,EAAKyB,GAEjBN,EAAQnB,GAAOyB,EAGjB,CACD,OAAON,CACR,CC5BY,MAACqjB,GAAahT,GAAatQ,EAAiBM,EACvD0X,GAAkBD,GAAuBsL,GAAiBD,ICvBpD,SAASG,MAAYvS,GAC3B,OAAIX,GAAQW,EAAQ,IACZ5Q,kBAAkB4B,GACxB,OAAOkT,GAAMlE,GAAS5Q,MAAOkG,GACrB4O,GAAMlT,GAAM5B,MAAOvB,GAClByH,EAAOzH,MAGnB,EAEQ,YAAYmD,GAClB,OAAOkT,GAAMlE,GAAU1K,GACf4O,GAAMlT,GAAOnD,GACZyH,EAAOzH,MAGlB,CACA,CCOO,SAAS2kB,GAAYvkB,EAAQY,EAAWF,EAAa0U,GAC3D,MAAMpU,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,EAEZ,IADAY,EAAS+F,EAAO3F,EAAShB,IAEvCuV,EAAgB5O,EAEjB,CACH,KAAQ,CACN,MAAM6O,EAAYvE,GAAWjQ,EAAQ4C,KACrC,IAAK,MAAO/D,EAAK8G,KAAU3G,EAAQ,EAEnB,IADAY,EAAS+F,EAAO9G,EAAKmB,EAAShB,KAExCwV,EACHxU,EAAQ4C,IAAI/D,EAAK8G,GAEjB3F,EAAQnB,GAAO8G,EAGjB,CACD,CACD,OAAO3F,CACR,CCxBOG,eAAeqjB,GAAiBxkB,EAAQY,EAAWF,EAAa0U,EAAepE,GACrF,GAAIF,GAAY9Q,GAAS,CACxB,MAAM0V,EAAmB,GACzB,UAAW,MAAM9V,KAAQI,KAAUgR,IACqB,UAA7CpQ,EAAShB,EAAM8V,EAAkB1V,IAC1C0V,EAAiB5V,KAAKF,GAGxB,OAAO8V,CACP,CACD,MAAM1U,EAAUoU,GAAiBH,GAAUjV,GAC3C,GAAImC,EAAQnC,IAAW2Q,GAAM3Q,GAAS,CACrC,MAAMqV,EAAarU,EAAQlB,MAAQkB,EAAQsU,IACrCC,EAAkBF,GAAcA,EAAWhB,KAAKrT,GACtD,IAAK,MAAM2F,KAAS3G,EAAQ,EAEZ,UADMY,EAAS+F,EAAO3F,EAAShB,IAE7CuV,EAAgB5O,EAEjB,CACH,KAAQ,CACN,MAAM6O,EAAYvE,GAAWjQ,EAAQ4C,KACrC,UAAW,MAAO/D,EAAK8G,KAAU3G,EAAQ,EAEzB,UADMY,EAAS+F,EAAO9G,EAAKmB,EAAShB,KAE9CwV,EACHxU,EAAQ4C,IAAI/D,EAAK8G,GAEjB3F,EAAQnB,GAAO8G,EAGjB,CACD,CACD,OAAO3F,CACR,CCrCY,MAACoK,GAASiG,GAAa9M,EAAaC,EAAkBwU,GAAcC,GAAmBsL,GAAaC,ICtBhH,SAASC,GAAW5U,GACnB,MAAO,IAAIkC,IACFqE,IACP,IAAIzP,EAAQyP,EAIZ,OAHAvG,EAASkC,GAAUnS,IAClB+G,EAAQ/G,EAAK+G,EAAM,IAEbA,CAAK,CAGf,CAcY,MAAC+d,GAAOD,GAAW9jB,GAclBgkB,GAAYF,GAAWvgB,GCtCpC,SAASugB,GAAW5U,GACnB,MAAO,IAAIkC,IACH5Q,MAAOiV,IACb,IAAIzP,EAAQyP,EAIZ,aAHMvG,EAASkC,GAAS5Q,MAAOvB,IAC9B+G,QAAc/G,EAAK+G,EAAM,IAEnBA,CAAK,CAGf,CAeY,MAACie,GAAYH,GAAWrjB,GAevByjB,GAAiBJ,GAAWtgB,GCvClC,SAAS2gB,GAAO9kB,EAAQkC,GAC9B,MAAM6iB,EAAS9P,GAAUjV,GACnBqH,EAAS0d,EAAOjlB,MAAQilB,EAAOzP,IACrC,GAAIjO,GAAU4J,GAAW5J,GAAS,CACjC,MAAM2d,EAAc3d,EAAOgN,KAAK0Q,GAChC/kB,EAAOL,SAASC,IACf,MAAM0B,EAASY,EAAStC,EAAMmlB,GAC9BC,EAAY1jB,EAAO,GAEpB,MAAU2P,GAAW8T,EAAOnhB,KAC5B5D,EAAOL,SAAQ,CAACC,EAAMC,KACrB,MAAMyB,EAASY,EAAStC,EAAMC,EAAKklB,GACnCA,EAAOnhB,IAAI/D,EAAKyB,EAAO,IAGxBtB,EAAOL,SAAQ,CAACC,EAAMC,KACrB,MAAMyB,EAASY,EAAStC,EAAMC,EAAKklB,GACnCA,EAAOllB,GAAOyB,CAAM,IAGtB,OAAOyjB,CACR,CCHO,SAASjZ,GAAI9L,EAAQilB,EAAQljB,GACnC,GAAI4b,GAAQ3d,IAAW2d,GAAQsH,GAC9B,OAAO,EAER,GAAIvW,GAAS1O,GACZ,OAAI0O,GAASuW,GACLjlB,EAAOqF,SAAS4f,EAAQljB,GAE5B0X,GAAQwL,GACJA,EAAO1V,KAAKvP,GAEhBiR,GAAWgU,GACP1kB,QAAQ0kB,EAAOjlB,IAEhBiW,GAAMgP,GAASrlB,GACdW,QAAQuL,GAAI9L,EAAQJ,MAG7B,GAAIuC,EAAQnC,GAAS,CACpB,GAAI0O,GAASuW,GACZ,OAAOjlB,EAAOqF,SAAS4f,EAAQljB,GAEhC,GAAI0X,GAAQwL,GACX,OAAOhP,GAAMjW,GAASJ,GACdA,EAAK2P,KAAK0V,KAGnB,GAAI9iB,EAAQ8iB,GACX,OAAOhP,GAAMgP,GAASrlB,GACdW,QAAQuL,GAAI9L,EAAQJ,KAG7B,CACD,OAAO,CACR,CC1CY,MAACslB,GAAS7V,GAAiB,MCG1B8V,GAAc,CAACC,EAAY5W,EAAU6W,KAC7C7W,IAAa/N,EAAS2kB,EAAW5W,MACpC4W,EAAW5W,GAAY6W,GAEjBD,GCfD,MAAME,GACZ9R,KAAO7Q,EAAUQ,KACjB,SAAAR,GACC,CAWD,MAAA2G,CAAO+D,GACNkY,cAAclY,GACd2E,KAAKwB,KAAKE,OAAOrG,EACjB,CACD,GAAAvB,CAAIuB,GACH,OAAO2E,KAAKwB,KAAK1H,IAAIuB,EACrB,CACD,GAAA3J,CAAI2J,GACH,OAAO2E,KAAKwB,KAAK9P,IAAI2J,EACrB,CAaD,GAAAzJ,CAAIiM,EAAU8D,GAEb,MAAMtG,EAAKmY,aAAY,KACtB3V,GAAU,GACR8D,GAEH,OADA3B,KAAKwB,KAAK5P,IAAIyJ,EAAI2F,IACX3F,CACP,CAUD,KAAAyG,GACC,MAAMF,EAAc5B,KACpB4B,EAAYJ,KAAK7T,SAAS0N,IACzBuG,EAAYtK,OAAO+D,EAAG,GAEvB,EAEU,MAACoY,GAAY9iB,EAAU2iB,IAe5B,SAASI,GAAS7V,EAAU8D,GAClC,OAAO8R,GAAU7hB,IAAIiM,EAAU8D,EAChC,CAYO,SAASgS,KAEftS,GADWQ,WAAWT,GAAM,IACjB1T,IACV+lB,GAAUnc,OAAO5J,EAAM,GAEzB,CCjFO,SAASkmB,GAAMhjB,KAAWK,GAWhC,OAVA4O,GAAK5O,GAAU4iB,IACdhU,GAAKgU,GAAe,CAACC,EAAYC,KAChC,GAAInjB,EAAOmjB,KACNrf,EAAcof,IAAe3jB,EAAQ2jB,IAAeA,EAAWnmB,SAClE,OAAOimB,GAAMhjB,EAAOmjB,GAAYD,GAGlCljB,EAAOmjB,GAAaD,CAAU,GAC7B,IAEIljB,CACR,CCbO,MAAMojB,GACZC,cAAgB,CAAA,EAChB,WAAArf,CAAYsf,EAAWC,GAClB1lB,EAAS0lB,IACZjW,GAAO8B,KAAMmU,GACbnU,KAAKkU,UAAYA,EACjBF,GAAMI,OAAOxiB,IAAIsiB,EAAWC,IAE5BjW,GAAO8B,KAAMkU,EAEd,EASK,SAASG,GAAMH,EAAWC,GAChC,OAAI1lB,EAAS0lB,GACLxjB,EAAUqjB,GAAO,CAACE,EAAWC,IAE9BziB,EAAIwiB,EAAWF,GAAMI,OAC7B,CC3BO,SAASE,GAAKC,EAAWC,GAC/B,MAAO,CAACD,EAAWC,EACpB,CCKO,SAASC,GAAWzmB,EAAQY,EAAUC,GAC5C,MAAMC,EAAcd,EAAOC,OACrBymB,EAAQ,GACd,IAAK,IAAIhnB,EAAQ,EAAEA,EAAQoB,EAAapB,IACvCgnB,EAAMhnB,GAASkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,EAAaD,GAEpE,OAAOsf,QAAQwG,IAAID,EACpB,CCPO,SAASE,GAAiB5mB,EAAQY,EAAUC,GAClD,MAAMC,EAAcd,EAAOC,OACrBymB,EAAQ,GACd,IAAK,IAAIhnB,EAAQ,EAAEA,EAAQoB,EAAapB,IACvCgnB,EAAMhnB,GAASkB,EAASZ,EAAON,GAAQA,EAAOM,EAAQc,EAAaD,GAEpE,OAAOsf,QAAQ0G,WAAWH,EAC3B,CCTO,SAASI,GAAQ5kB,GACvB,OAAO,IAAIie,QAAQje,EACpB,CCGY,MAAC6kB,GAAgB,CAAC/mB,EAAQgnB,EAAU7gB,EAAaX,EAAKxF,KAC1DoE,EAAW+B,GAAaqI,GACvB9G,GAAQ1H,EAAOwO,GAAWwY,EAASxY,MCtBrC,SAASyY,GAAOjnB,EAAQH,EAAK8G,GAcnC,OAbI9G,GAAO6G,EAAc1G,IAEduZ,GAAS1Z,IAAQsC,EAAQnC,GADnCA,EAAOH,GAAO8G,EAGJ3G,EAAO4D,IACjB5D,EAAO4D,IAAI/D,EAAK8G,GACN3G,EAAOF,KACjBE,EAAOF,KAAK6G,GACF3G,EAAOsV,IACjBtV,EAAOsV,IAAI3O,GAEX3G,EAAOH,GAAO8G,EAER3G,CACR,CCfO,SAASqS,GAASrS,EAAQ2G,EAAO9G,GAUvC,OATI0Z,GAAS1Z,IAAQsC,EAAQnC,GAC5BA,EAAOH,GAAO8G,EACJ3G,EAAOF,KACjBE,EAAOF,KAAK6G,GACF3G,EAAOsV,IACjBtV,EAAOsV,IAAI3O,GAEX3G,EAAOH,GAAO8G,EAER3G,CACR,CCdO,MAAMknB,GACZlnB,OACA,WAAA4G,CAAY5G,EAAS,IAEpB,GADAgS,KAAKhS,OAASA,EACC,OAAXA,GAAqC,iBAAXA,EAC7B,OAAOA,EAERqQ,GAAWrQ,GAASwO,IACnBxO,EAAOwO,GAAY,IAAI0Y,GAAMlnB,EAAOwO,GAAU,IAE/CwD,KAAKmV,KAAO,IAAIC,MAAMpnB,EAAQ,CAC7B0D,IAAG,CAAC2jB,EAAa7Y,KAChB8Y,QAAQC,IAAIF,EAAa7Y,EAAU6Y,EAAY7Y,IACxC6Y,EAAY7Y,IAEpB5K,IAAG,CAACyjB,EAAa7Y,EAAU7H,KAC1B2gB,QAAQC,IAAIF,EAAa7Y,EAAU6Y,EAAY7Y,IAC/C6Y,EAAY7Y,GAAY,IAAI0Y,GAAMvgB,IAC3B,IAGT,ECVU,MAAC6gB,GAAY,IACjB,GCAKC,GAAa,KAClB,ICDKC,GAAa,IAClB,GCODvmB,eAAewmB,GAAW7jB,EAAQlD,GACxC,IAAK,IAAIlB,EAAQ,EAAGA,EAAQoE,EAAQpE,UAC7BkB,EAASkD,EAEjB,CAoBO3C,eAAeymB,GAAc9jB,EAAQlD,EAAUI,EAAU,IAC/D,IAAK,IAAItB,EAAQ,EAAGA,EAAQoE,EAAQpE,IACnCsB,EAAQtB,SAAekB,EAASkD,GAEjC,OAAO9C,CACR,CChCO,SAAS6mB,GAAOlhB,EAAOmhB,GAAK,EAAMC,GAAM,GAC9C,OAAQrgB,GAAQogB,EAAInhB,GAAUohB,EAAMD,CACrC,CCGO,MAAME,GACZC,YAAc,EACdC,MAAQ,GACRC,UAAY,EAeZ,GAAAzkB,GACC,IAAIpC,EAAS0Q,KAAKkW,MAAME,QAOxB,OANI3nB,EAASa,GACZ0Q,KAAKmW,aAEL7mB,EAAS0Q,KAAKiW,YACdjW,KAAKiW,eAEC3mB,CACP,CAkBD,IAAA+mB,CAAKhb,GACJ2E,KAAKkW,MAAMpoB,KAAKuN,GAChB2E,KAAKmW,YACL,MAAMG,EAAWtW,KAAKiW,YAAc,EAC9BM,EAAcvW,KAAKiW,cAAgBjW,KAAKmW,UAC1CG,GAAYC,GACfvW,KAAKwW,OAEN,CACD,KAAAA,GACCxW,KAAKiW,YAAc,EACnBjW,KAAKkW,MAAMjoB,OAAS,EACpB+R,KAAKmW,UAAY,CACjB,EAeU,MAACM,GAAS9lB,EAAUqlB,ICnFzB,MAAMU,GACZ,WAAA9hB,CAAY+hB,EAAgB,IAC3B3W,KAAK4W,MAAQD,CACb,CAcD,OAAAE,CAAQhpB,GACP,OAAOmS,KAAK4W,MAAM/oB,EAClB,CAcD,OAAAipB,CAAQjpB,EAAK8G,GACZqL,KAAK4W,MAAM/oB,GAAO8G,CAClB,CAeD,KAAAmN,GACC9B,KAAK4W,MAAQ,EACb,CAeD,UAAAG,CAAWlpB,GACVmS,KAAK4W,MAAM/oB,GAAO,IAClB,EAgBK,SAASmpB,GAAeL,GAC9B,OAAO,IAAID,GAAeC,EAC3B,CCpFO,SAASM,GAAQjpB,GACvB,OAAO,EAAWipB,GAAQjpB,GAAUwF,EAAKyjB,GAC1C,CACA,MAAMC,GAAYpH,WAAWqH,WAAWC,cACxC,GAAIF,GACH7Y,GAAW6Y,IAAW,CAACviB,EAAO9G,KACzBye,GAAU3X,IAAUA,IACvBsiB,GAAQppB,GAAO8G,EACf,IAEFhG,EAAUuoB,GAAUG,QAAS1iB,IAC5BsiB,GAAQtiB,EAAM2iB,OAAS3iB,EAAM4iB,OAAO,SAE/B,GAAIJ,UAAUD,UAAW,CAC/B,IAAIM,EAAsBL,UAAUD,UAAUrO,cAC9C2O,EAAsBA,EAAoB3jB,QAAQ,KAAM,KACxD2jB,EAAsBA,EAAoB3jB,QAAQ,YAAa,IAE/DlF,EADuB6oB,EAAoB1jB,MAAM,SACtBlG,IAC1BqpB,GAAQrpB,IAAQ,CAAI,GAEtB,CCrBO,SAAS6pB,GAAStH,EAAMuH,EAAWxnB,EAAUynB,GAEnD,OADAxH,EAAKyH,iBAAiBF,EAAWxnB,EAAUynB,GACpCxH,CACR,CAiBO,SAAS0H,GAAY1H,EAAMuH,EAAWxnB,EAAUynB,GAEtD,OADAxH,EAAK2H,oBAAoBJ,EAAWxnB,EAAUynB,GACvCxH,CACR,CC1BO,SAAS4H,GAAQC,GACvB,OAA+B,KAAxBA,EAAYC,OACpB,CCNY,MAACC,GAAiBC,SAASC,uBAAuB/V,KAAK8V,UCG5D,SAASE,GAAOC,EAAY/mB,GAElC,OADA+mB,EAAWC,YAAYhnB,GAChBA,CACR,CCIO,SAASinB,GAAcrI,EAAMtV,GACnC,OAAI1K,EAAQ0K,GACJ0N,GAAU1N,EAAQzE,GAASyE,GAASjN,GACnCuiB,EAAKsI,aAAa7qB,OAG3ByQ,GAAWxD,GAAQ,CAACjN,EAAMC,KACzBsiB,EAAKuI,aAAa7qB,EAAKD,EAAK,IAEtBuiB,EACR,CC5BA,MAEMwI,GAAY,aACZC,GAAU,cACVC,GAAa,KASNC,GAAaX,SAASY,uBAAuB1W,KAAK8V,UASlDa,GAAWb,SAASc,qBAAqB5W,KAAK8V,UAS9Ce,GAAUf,SAASgB,eAAe9W,KAAK8V,UASvCiB,GAAgBjB,SAASiB,cAAc/W,KAAK8V,UAS5CkB,GAAmBlB,SAASkB,iBAAiBhX,KAAK8V,UAexD,SAASmB,GAASC,GAExB,OADoBA,EAAO,IAE3B,IAlEmB,IAmElB,IAAKV,GAAWtb,KAAKgc,GACpB,OAAOL,GAAQvP,GAAW4P,IAE3B,MACD,IAxEiB,IAyEhB,GAAIZ,GAAUpb,KAAKgc,GAClB,OAAOT,GAAWnP,GAAW4P,IAE9B,MACD,QACC,GAAIX,GAAQrb,KAAKgc,GAChB,OAAOP,GAASO,GAGlB,OAAOF,GAAiBE,EACzB,CC9EA,MAAMC,GAAqBrB,SAASsB,cAAcpX,KAAK8V,UAuBhD,SAASuB,GAASC,GACxB,MAAMC,EAAM1G,GAAOyG,IAAQA,GAAO,GAAGA,OAKrC,MA5B+B,CAACxJ,GACzB2E,IAAS+E,IACfpC,GAAStH,EAAM,OAAQ0J,GAAQ,GAC/BpC,GAAStH,EAAM,QAAS0J,GAAQ,GAChCxB,GAAOe,GAAc,QAASjJ,EAAK,IAwB7B2J,CAJMtB,GAAcgB,GAAmB,UAAW,CACxDrqB,MAAO,GACPyqB,QAGF,CCnBO,SAASG,GAAgBlc,GAC/B,MAAMmc,EAAQ7B,SAAS8B,WAEvB,MAD8B,gBAAVD,GAAqC,cAAVA,GAAmC,aAAVA,GAEhE,GAAanc,KAEjBA,GACH4Z,GAASU,SAAU,mBAAoBta,IAEjC,EACR,CACAkc,IAAgB,KACf,MAAMG,EAAYhB,GAAQ,WAE1BQ,GADoBQ,GAAaA,EAAUzB,aAAa,eAAkB,SACtD,IC/BrB,MAAM0B,GAAWC,SAASD,SACpBE,GAA+B,UAAbF,GAAwB,KAAO,MACjDG,GAAWF,SAASE,SAUbC,GAAO,CACnBC,SAAU,CACTC,MAAOtD,UAAUuD,qBAElBC,KAAM,CACLzlB,KAAMolB,GACNH,YACAE,oBCfK,SAASO,KACf1c,GAAOqc,GAAM,CACZM,WAAY1C,SAAS2C,KAAKC,aAC1BC,UAAW7C,SAAS2C,KAAKG,YACzBC,aAAcC,OAAOC,YACrBC,YAAaF,OAAOG,YAEtB,CAaO,SAASC,KACfX,IACD,CCjBU,IAACY,GDkBXzB,GAAgBwB,IAChB9D,GAAS0D,OAAQ,OAAQI,IAAkB,GAC3C9D,GAAS0D,OAAQ,SAAUI,IAAkB,GCnB7C,SAAoBE,GACnB,IACCA,IAAa1E,WAAW,WACxByE,IAAW,CACX,CAAC,MAAOE,GACRF,IAAW,CACX,CACF,CACAG,EAAW,IACHC,eAkBD,MAAMC,GACZ,WAAAjnB,CAAY+hB,GACP3W,KAAKwb,WACRxb,KAAK8b,MAAQF,cAEd5b,KAAK+b,QAAU/E,GAAeL,EAC9B,CACD6E,SAAWA,GAiBX,OAAA1E,CAAQjpB,EAAK8G,GAIZ,OAHIqL,KAAKwb,UACRxb,KAAK8b,MAAMhF,QAAQjpB,EAAM6O,GAAS/H,GAAUA,EAAQoc,GAAUpc,IAExDqL,KAAK+b,QAAQjF,QAAQjpB,EAAK8G,EACjC,CAgBD,OAAAkiB,CAAQhpB,GACP,MAAMD,EAAOoS,KAAK+b,QAAQlF,QAAQhpB,GAClC,OAAIY,EAASb,GACLA,GAEHa,EAASb,IAASoS,KAAKwb,SACpBxb,KAAK8b,MAAMjF,QAAQhpB,QAD3B,CAGA,CAkBD,KAAAiU,GACK9B,KAAKwb,UACRxb,KAAK8b,MAAMha,QAEZ9B,KAAK+b,QAAQja,OACb,CAkBD,UAAAiV,CAAWlpB,GACNmS,KAAKwb,UACRxb,KAAK8b,MAAM/E,WAAWlpB,GAEvBmS,KAAK+b,QAAQhF,WAAWlpB,EACxB,EAcK,SAASmuB,GAAMC,GACrB,OAAO,IAAIJ,GAAMI,EAClB,CCtJA,MAAMC,GAAgB,CAACC,EAAOC,IACtB,SAASD,gBAAoBC,KAExBC,GAAS,CACrBC,MAAOJ,GAAc,OAAQ,WAC7BK,UAAWL,GAAc,OAAQ,WACjCM,OAAQN,GAAc,OAAQ,WAC9BO,QAASP,GAAc,OAAQ,YAiBnBQ,GAAO,CAAC/nB,EAAOgoB,KAC3B,MAAMxH,EAAOzY,GAAS/H,GAASA,EAAQoc,GAAUpc,GACjD,GAAkB,UAAdgoB,GAAuC,YAAdA,EAC5B,OAAOrH,QAAQsH,MAAM,KAAKzH,IAAQ,GAAGkH,GAAOM,uDAE7CrH,QAAQC,IAAI,KAAKJ,IAAQ,GAAGkH,GAAOM,sDAA8D,EAiBrFE,GAAY,CAACF,EAAWR,EAAOW,KAC3CT,GAAOM,GAAaT,GAAcC,EAAOW,EAAW,EClC9C,SAASC,GAAM/uB,GACrB,OAAOA,GAA8B,IAApBA,EAAOgvB,QACzB,CAgBO,SAASC,GAAiBjvB,GAChC,QAAQS,EAAST,IAFW,4BAEAA,EAAO6G,UACpC,CAgBO,SAASqoB,GAAWlvB,GAC1B,QAAQS,EAAST,IAFK,sBAEMA,EAAO6G,UACpC"}