{"version":3,"file":"index.js","sources":["../source/internal/array.js","../source/internal/function.js","../source/internal/object.js","../source/internal/is.js","../source/array/asyncEach.js","../source/array/ensure.js","../source/array/flatten.js","../source/array/clear.js","../source/number/math.js","../source/array/shuffle.js","../source/array/smallest.js","../source/array/each.js","../source/array/drop.js","../source/array/isMatch.js","../source/array/largest.js","../source/array/eachAsync.js","../source/array/mapAsync.js","../source/array/unique.js","../source/array/numSort.js","../source/array/rNumSort.js","../source/array/times.js","../source/object/each.js","../source/browser/agent.js","../source/browser/event.js","../source/browser/frag.js","../source/browser/append.js","../source/object/zip.js","../source/browser/attribute.js","../source/utility/promise.js","../source/string/range.js","../source/browser/selector.js","../source/browser/importScript.js","../source/browser/ready.js","../source/browser/info.js","../source/browser/dimensions.js","../source/utility/json.js","../source/browser/storage.js","../source/browser/console.js","../source/collection/sortNewest.js","../source/collection/sortOldest.js","../source/object/pluckObject.js","../source/collection/findIndex.js","../source/utility/each.js","../source/function/every.js","../source/function/timing.js","../source/object/hasKeys.js","../source/object/eachAsync.js","../source/string/case.js","../source/string/sanitize.js","../source/string/tokenize.js","../source/string/typography.js","../source/utility/assignDeep.js","../source/utility/cacheNativeMethod.js","../source/utility/ifNotEqual.js","../source/utility/isEqual.js","../source/utility/toPath.js","../source/utility/uid.js","../source/utility/get.js","../source/utility/model.js","../source/utility/flow.js","../source/utility/flowAsync.js","../source/function/ntimes.js","../source/array/object.js","../source/function/ary.js","../source/function/bind.js","../source/function/chain.js","../source/array/chunk.js","../source/array/clone.js","../source/array/compact.js","../source/object/compactKeys.js","../source/array/compactMapAsync.js","../source/object/mapAsync.js","../source/collection/countBy.js","../source/function/curry.js","../source/array/difference.js","../source/array/first.js","../source/collection/groupBy.js","../source/function/ifInvoke.js","../source/function/in.js","../source/collection/indexBy.js","../source/array/initial.js","../source/array/intersect.js","../source/object/invert.js","../source/collection/invoke.js","../source/collection/invokeAsync.js","../source/browser/is.js","../source/browser/isEnter.js","../source/object/isMatch.js","../source/number/is.js","../source/array/last.js","../source/function/negate.js","../source/function/stub.js","../source/function/nthArg.js","../source/object/omit.js","../source/function/over.js","../source/array/partition.js","../source/object/pick.js","../source/collection/pluck.js","../source/collection/pluckValues.js","../source/utility/propertyMatch.js","../source/array/createrange.js","../source/function/rearged.js","../source/array/remove.js","../source/string/replace.js","../source/array/rest.js","../source/array/right.js","../source/array/sample.js","../source/collection/sortAlphabet.js","../source/array/sortedIndex.js","../source/array/sum.js","../source/array/take.js","../source/utility/toggle.js","../source/string/truncate.js","../source/array/zip.js","../source/array/union.js","../source/array/without.js","../source/function/wrap.js","../source/array/xor.js"],"sourcesContent":["const arrayNative = Array;\n/**\n * Takes an array like object and creates a new Array from it.\n *\n * @function toArray\n * @category array\n * @param {*} arrayLike - Array like object.\n * @returns {*} - new array.\n *\n * @example\n * toArray([1, 2, 3]);\n * // => [1, 2, 3]\n*/\nexport const toArray = arrayNative.from;\n\n","/**\n * Calls a target function with arguments as specified.\n *\n * @function apply\n * @category function\n * @param {Function} target - The target function to call.\n * @param {*} thisArgument - Array like object.\n * @param {Array} argumentsList - An array-like object specifying the arguments with which target should be called.\n * @returns {*} - The result of calling the given target function with the specified this value and arguments.\n *\n * @example\n * apply(function (a) {return a;}, undefined, [2]);\n * // => 2\n*/\nexport const apply = Reflect.apply;\n\n","const objectNative = Object;\n/**\n * Get object's keys.\n *\n * @function keys\n * @category object\n * @param {*} source - The source object to pull keys from.\n * @returns {Array} - Array of keys.\n *\n * @example\n * keys({a: 1, b: 2});\n * // => ['a', 'b']\n*/\nexport const keys = objectNative.keys;\n/**\n * Determines whether two values are the same value.\n *\n * @function is\n * @category object\n * @param {*} source - Value to compare to.\n * @param {*} target - A value to compare.\n * @returns {Boolean} - A Boolean indicating whether or not the two arguments are the same value.\n *\n * @example\n * is('foo', 'foo');\n * // => true\n*/\nexport const is = objectNative.is;\n/**\n * Copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\n *\n * @function assign\n * @category object\n * @param {Object} target - The target object.\n * @param {...Object} sources - The source object(s).\n * @returns {Object} - Returns the target object.\n *\n * @example\n * assign({b: 2}, {a: 1});\n * // => {b: 2, a: 1}\n*/\nexport const assign = objectNative.assign;\n/**\n * Returns a property descriptor for an own property (that is, one directly present on an object and not in the object's prototype chain) of a given object.\n *\n * @function getOwnPropertyDescriptor\n * @category object\n * @param {Object} target - The target object.\n * @param {String} property - The name of the property whose description is to be retrieved.\n * @returns {Object} - A property descriptor of the given property if it exists on the object, undefined otherwise.\n *\n * @example\n * getOwnPropertyDescriptor({ bar: 42 }, 'bar');\n * // => { configurable: true, enumerable: true, value: 42, writable: true }\n*/\nexport const getOwnPropertyDescriptor = objectNative.getOwnPropertyDescriptor;\n/**\n * Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n *\n * @function defineProperty\n * @category object\n * @param {Object} target - The object on which to define the property.\n * @param {String} property - The name of the property whose description is to be retrieved.\n * @param {Object} descriptor - The descriptor for the property being defined or modified.\n * @returns {Object} - The object that was passed to the function.\n *\n * @example\n * defineProperty({}, 'key', {\n *  enumerable: false,\n *  configurable: false,\n *  writable: false,\n *  value: 'static'\n * }).key;\n * // => 'static'\n*/\nexport const defineProperty = objectNative.defineProperty;\n/**\n * Returns an array of all properties (enumerable or not) found directly upon a given object.\n *\n * @function getOwnPropertyNames\n * @category object\n * @param {Object} source - The object whose enumerable and non-enumerable own properties are to be returned.\n * @returns {Object} - An array of strings that correspond to the properties found directly upon the given object.\n *\n * @example\n * getOwnPropertyNames({ 0: 'a', 1: 'b', 2: 'c' });\n * // => ['0', '1', '2']\n*/\nexport const getOwnPropertyNames = objectNative.getOwnPropertyNames;\n/**\n * Returns the amount of keys on the object.\n *\n * @function objectSize\n * @category object\n * @param {Object} source - The target object.\n * @returns {number} - The amount of keys.\n *\n * @example\n * objectSize({ 0: 'a', 1: 'b', 2: 'c' });\n * // => 3\n*/\nexport const objectSize = (target) => {\n\treturn keys(target).length;\n};\n\n","import { objectSize } from './object';\n/**\n * Checks if the value is undefined.\n *\n * @function isUndefined\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isUndefined(undefined);\n * // => true\n*/\nexport function isUndefined(value) {\n\treturn value === undefined;\n}\n/**\n * Checks if the value is null.\n *\n * @function isNull\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isNull(null);\n * // => true\n*/\nexport function isNull(value) {\n\treturn value === null;\n}\n/**\n * Checks if the value is not null or undefined.\n *\n * @function hasValue\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * hasValue(1);\n * // => true\n*/\nexport function hasValue(value) {\n\treturn !isUndefined(value) && !isNull(value);\n}\nexport function isConstructor(nativeObject) {\n\treturn (obj) => {\n\t\treturn (hasValue(obj)) ? obj.constructor === nativeObject : false;\n\t};\n}\nexport const decimalCheck = /\\.|\\+/;\n/**\n * Checks if the value is a decimal.\n *\n * @function isDecimal\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isDecimal(1.01);\n * // => true\n*/\nexport const isDecimal = (value) => {\n\treturn decimalCheck.test(value.toString());\n};\n/**\n * Checks if the value is an array.\n *\n * @function isArray\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isArray([]);\n * // => true\n*/\nexport const isArray = Array.isArray;\n/**\n * Checks if the value is a string.\n *\n * @function isString\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isString('Lucy');\n * // => true\n*/\nexport const isString = isConstructor(String);\n/**\n * Checks if the value is a number.\n *\n * @function isNumber\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isNumber(1);\n * // => true\n*/\nexport const isNumber = isConstructor(Number);\n/**\n * Checks if the value is a plain object.\n *\n * @function isPlainObject\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isPlainObject({});\n * // => true\n*/\nexport const isPlainObject = (value) => {\n\tif (hasValue(value)) {\n\t\treturn value.constructor.toString().trim()\n\t\t\t.slice(9, 16) === 'Object(';\n\t}\n\treturn false;\n};\n/**\n * Checks if the value is a plain object.\n *\n * @function isFunction\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFunction(() => {});\n * // => true\n*/\nexport const isFunction = (value) => {\n\treturn (hasValue(value)) ? value instanceof Function : false;\n};\n/**\n * Checks if the value includes something.\n *\n * @function has\n * @category utility\n * @param {Array|String} value - Object to be checked.\n * @param {*} search - Object that is being searched for.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * has('My name is Acidjs', 'Acidjs');\n * // => true\n*/\nexport const has = (value, ...search) => {\n\treturn value.includes(...search);\n};\n/**\n * Checks if the value has length greater than 0.\n *\n * @function hasLength\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * hasLength([1]);\n * // => true\n*/\nexport const hasLength = (value) => {\n\treturn Boolean(value.length);\n};\n/**\n * Checks if the value is empty.\n *\n * @function isEmpty\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isEmpty([]);\n * // => true\n*/\nexport const isEmpty = (obj) => {\n\tif (isString(obj) || isArray(obj)) {\n\t\treturn !hasLength(obj);\n\t} else if (isPlainObject(obj)) {\n\t\treturn !objectSize(obj);\n\t}\n\treturn !hasValue(obj);\n};\nexport const regexGenerator = (regexType) => {\n\treturn (item) => {\n\t\treturn (hasValue(item)) ? regexType.test(item) : false;\n\t};\n};\n/**\n * Checks if the string has a .css extension.\n *\n * @function isFileCSS\n * @category utility\n * @param {string} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFileCSS('test.css');\n * // => true\n*/\nexport const isFileCSS = regexGenerator(/\\.css$/);\n/**\n * Checks if the string has a .json extension.\n *\n * @function isFileJSON\n * @category utility\n * @param {string} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFileJSON('test.json');\n * // => true\n*/\nexport const isFileJSON = regexGenerator(/\\.json$/);\n/**\n * Checks if the string has a .js extension.\n *\n * @function isFileJS\n * @category utility\n * @param {string} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFileJS('test.js');\n * // => true\n*/\nexport const isFileJS = regexGenerator(/\\.js$/);\n/**\n * Checks if the string has a .html extension.\n *\n * @function isFileHTML\n * @category utility\n * @param {string} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFileHTML('test.html');\n * // => true\n*/\nexport const isFileHTML = regexGenerator(/\\.html$/);\n/**\n * Checks if the string has a '.'.\n *\n * @function hasDot\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * hasDot('test.js');\n * // => true\n*/\nexport const hasDot = regexGenerator(/\\./);\nexport const getExtensionRegex = /\\.([0-9a-z]+)/;\n/**\n * Return the file extension.\n *\n * @function getFileExtension\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {string} - Returns the extension.\n *\n * @example\n * getFileExtension('test.js');\n * // => 'js'\n*/\nexport const getFileExtension = (string) => {\n\tconst match = string.match(getExtensionRegex);\n\tif (match) {\n\t\treturn match[1];\n\t}\n};\n/**\n * Checks if the value is a RegExp.\n *\n * @function isRegExp\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isRegExp(/test/);\n * // => true\n*/\nexport const isRegExp = (value) => {\n\treturn value instanceof RegExp;\n};\n/**\n * Checks if the value is an Arguments object.\n *\n * @function isArguments\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isArguments([]);\n * // => false\n*/\n/**\n * Checks if the value is a Boolean.\n *\n * @function isBoolean\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isBoolean(true);\n * // => true\n*/\nexport const isBoolean = (value) => {\n\treturn value.constructor.name === 'Boolean';\n};\n/**\n * Checks if the value is a Date.\n *\n * @function isDate\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isDate(new Date());\n * // => true\n*/\nexport const isDate = (value) => {\n\treturn value instanceof Date;\n};\n/**\n * Checks if an object is a promise.\n *\n * @function isPromise\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - True or false.\n *\n * @example\n * isPromise(new Promise(() => {}));\n * // => true\n*/\nexport const isPromise = (value) => {\n\tif (value) {\n\t\treturn value instanceof Promise;\n\t}\n\treturn false;\n};\n/**\n * Checks if an object is an async function.\n *\n * @function isAsync\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - True or false.\n *\n * @example\n * isAsync(async() => {});\n * // => true\n*/\nexport const isAsync = (value) => {\n\tif (value) {\n\t\treturn value.constructor?.name === 'AsyncFunction';\n\t}\n\treturn false;\n};\n/**\n * Checks if an object is an async function or promise.\n *\n * @function isKindAsync\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - True or false.\n *\n * @example\n * isKindAsync(async() => {});\n * // => true\n * isKindAsync(new Promise(() => {}));\n * // => true\n*/\nexport const isKindAsync = (value) => {\n\tif (value) {\n\t\treturn isPromise(value) || isAsync(value);\n\t}\n\treturn false;\n};\n/**\n * Checks if an object is a primitive.\n *\n * @function isPrimitive\n * @category utility\n * @param {*} value - Object to be checked.\n * @returns {boolean} - True or false.\n *\n * @example\n * isPrimitive(1);\n * // => true\n * isPrimitive(() => {});\n * // => false\n*/\nexport const isPrimitive = (value) => {\n\treturn value !== '__proto__' && value !== 'constructor' && value !== 'prototype';\n};\n/**\n * Checks if the source is a Map.\n *\n * @function isMap\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isMap(new Map());\n * // => true\n*/\n/**\n * Checks if the source is a Set.\n *\n * @function isSet\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isSet(new Set());\n * // => true\n*/\n/**\n * Checks if the source is a WeakMap.\n *\n * @function isWeakMap\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isWeakMap(new WeakMap());\n * // => true\n*/\n/**\n * Checks if the source is a ArrayBuffer.\n *\n * @function isArrayBuffer\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isArrayBuffer(new ArrayBuffer());\n * // => true\n*/\n/**\n * Checks if the source is a Float32Array.\n *\n * @function isFloat32Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFloat32Array(new Float32Array());\n * // => true\n*/\n/**\n * Checks if the source is a Float64Array.\n *\n * @function isFloat64Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isFloat64Array(new Float64Array());\n * // => true\n*/\n/**\n * Checks if the source is a Int8Array.\n *\n * @function isInt8Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isInt8Array(new Int8Array());\n * // => true\n*/\n/**\n * Checks if the source is a Int16Array.\n *\n * @function isInt16Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isInt16Array(new Int16Array());\n * // => true\n*/\n/**\n * Checks if the source is a Int32Array.\n *\n * @function isInt32Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isInt32Array(new Int32Array());\n * // => true\n*/\n/**\n * Checks if the source is a Uint8Array.\n *\n * @function isUint8Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isUint8Array(new Uint8Array());\n * // => true\n*/\n/**\n * Checks if the source is a Uint8ClampedArray.\n *\n * @function isUint8ClampedArray\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isUint8ClampedArray(new Uint8ClampedArray());\n * // => true\n*/\n/**\n * Checks if the source is a Uint16Array.\n *\n * @function isUint16Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isUint16Array(new Uint16Array());\n * // => true\n*/\n/**\n * Checks if the source is a Uint32Array.\n *\n * @function isUint32Array\n * @category utility\n * @param {*} source - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isUint32Array(new Uint32Array());\n * // => true\n*/\nconst objectArguments = '[object Arguments]';\nexport function isArguments(source) {\n\treturn (hasValue(source)) ? source.toString() === objectArguments : false;\n}\nconst objectMap = '[object Map]';\nexport function isMap(source) {\n\treturn (hasValue(source)) ? source.toString() === objectMap : false;\n}\nconst objectSet = '[object Set]';\nexport function isSet(source) {\n\treturn (hasValue(source)) ? source.toString() === objectSet : false;\n}\nconst objectWeakMap = '[object WeakMap]';\nexport function isWeakMap(source) {\n\treturn (hasValue(source)) ? source.toString() === objectWeakMap : false;\n}\nexport function isBuffer(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'ArrayBuffer' : false;\n}\nexport function isFloat32(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Float32Array' : false;\n}\nexport function isFloat64(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Float64Array' : false;\n}\nexport function isInt8(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Int8Array' : false;\n}\nexport function isInt16(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Int16Array' : false;\n}\nexport function isInt32(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Int32Array' : false;\n}\nexport function isUint8(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Uint8Array' : false;\n}\nexport function isUint8Clamped(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Uint8ClampedArray' : false;\n}\nexport function isUint16(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Uint16Array' : false;\n}\nexport function isUint32(source) {\n\treturn (hasValue(source)) ? source.constructor?.name === 'Uint32Array' : false;\n}\n\n","/**\n  * Iterates through the given array of async function(s). Each async function is awaited as to ensure synchronous order and is given the supplied object.\n  *\n  * @function asyncEach\n  * @type {Function}\n  * @category Array\n  * @async\n  * @param {Array} source - Array of async functions that will be looped through.\n  * Functions are given the supplied object, index, the calling array, and the array length.\n  * @param {*} firstArgument - The first argument given to each function.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   await asyncEach([async (item, index) => {\n  *     tempList.push(index);\n  *   }, async (item, index) => {\n  *     tempList.push(index);\n  *   }], {a:1});\n  *   return assert(tempList, [0, 1]);\n  * });\n  *\n  * @example\n  * asyncEach([async (item, index) =>{\n  *  console.log(item, index);\n  * }, async (item) =>{\n  *  console.log(item, index);\n  * }], {a:1});\n  * // {a:1} 0\n  * // {a:1} 1\n*/\nexport const asyncEach = async (source, firstArgument) => {\n\tconst arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst item = source[index];\n\t\tawait item(firstArgument, index, source, arrayLength);\n\t}\n\treturn source;\n};\n\n","import { isArray } from '../internal/is';\n/**\n  * Ensures the object is an array. If not wraps in array.\n  *\n  * @function ensureArray\n  * @category array\n  * @type {Function}\n  * @param {*} object - Data to be checked.\n  * @returns {Array} - Returns an array.\n  *\n  * @example\n  * ensureArray('Hello');\n  * // => ['Hello']\n  *\n  * @example\n  * ensureArray({a:1, b:2})\n  * // => [{a:1, b:2}]\n*/\nexport const ensureArray = (object) => {\n\treturn (isArray(object)) ? object : [object];\n};\n\n","import { ensureArray } from '../array/ensure';\n/**\n  * Flattens an array up to the provided level.\n  *\n  * @function flatten\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to flatten.\n  * @param {number} [level = 1] - Number which determines how deep the array nest can be.\n  * @returns {Array} - Returns an array.\n  *\n  * @example\n  * flatten([1, [2, [3, [4]], 5]]);\n  *  // => [1, 2, [3, [4]], 5]\n*/\nexport const flatten = (arrayArg, level = 1) => {\n\tlet array = arrayArg;\n\tfor (let i = 0; i < level; i++) {\n\t\tarray = array.reduce((previousValue, currentValue) => {\n\t\t\treturn previousValue.concat(ensureArray(currentValue));\n\t\t}, []);\n\t}\n\treturn array;\n};\n/**\n  * Flattens an array to a single level.\n  *\n  * @function flattenDeep\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to flatten.\n  * @returns {Array} - Returns a completely flattened array.\n  *\n  * @example\n  * flattenDeep([1, [2, [3, [4]], 5]]);\n  * // => [1, 2, 3, 4, 5]\n*/\nexport const flattenDeep = (arrayToFlatten) => {\n\treturn arrayToFlatten.flat(Infinity);\n};\n\n","/**\n  * Clears the values out of an array.\n  *\n  * @function clear\n  * @category Array\n  * @type {Function}\n  * @param {Array} array - Takes an array to be emptied.\n  * @returns {Array} - The originally given array.\n  *\n  * @example\n  * clear([1,'B', 'Cat']);\n  * // => []\n*/\nexport const clear = (array) => {\n\tarray.length = 0;\n\treturn array;\n};\n\n","const mathNative = Math;\nconst floorMethod = mathNative.floor;\nconst randomMethod = mathNative.random;\n/**\n  * Adds two numbers.\n  *\n  * @function add\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the sum of the arguments.\n  *\n  * @example\n  * add(1, 1);\n  * // => 2\n*/\nexport const add = (number, value) => {\n\treturn number + value;\n};\n/**\n  * Subtracts two numbers.\n  *\n  * @function minus\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the difference of the arguments.\n  *\n  * @example\n  * minus(1, 1);\n  * // => 0\n*/\nexport const minus = (number, value) => {\n\treturn number - value;\n};\n/**\n  * Divides two numbers.\n  *\n  * @function divide\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the quotient of the arguments.\n  *\n  * @example\n  * divide(10, 5);\n  * // => 2\n*/\nexport const divide = (number, value) => {\n\treturn number / value;\n};\n/**\n  * Multiplies two numbers.\n  *\n  * @function multiply\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the product of the arguments.\n  *\n  * @example\n  * multiply(10, 5);\n  * // => 50\n*/\nexport const multiply = (number, value) => {\n\treturn number * value;\n};\n/**\n  *  Extracts the remainder between two numbers.\n  *\n  * @function remainder\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @param {number} value - Second number.\n  * @returns {number} - Returns the remainder of the arguments.\n  *\n  * @example\n  * remainder(10, 6);\n  * // => 4\n*/\nexport const remainder = (number, value) => {\n\treturn number % value;\n};\n/**\n  *  Increments a number.\n  *\n  * @function increment\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @returns {number} - Returns an incremented version of the number.\n  *\n  * @example\n  * increment(10);\n  * // => 11\n*/\nexport const increment = (number) => {\n\treturn number + 1;\n};\n/**\n  *  Decrements a number.\n  *\n  * @function deduct\n  * @category number\n  * @type {Function}\n  * @param {number} number - First number.\n  * @returns {number} - Returns a decremented version of the number.\n  *\n  * @example\n  * deduct(10);\n  * // => 9\n*/\nexport const deduct = (number) => {\n\treturn number - 1;\n};\n/**\n  *  Produces a random number between min (included) and max (excluded).\n  *\n  * @function randomArbitrary\n  * @category number\n  * @type {Function}\n  * @param {number} max - Establishes highest possible value for the random number.\n  * @param {number} [min = 0] - Establishes lowest possible value for the random number.\n  * @returns {number} - Returns random integer between the max and min range.\n  *\n  * @test\n  * (async () => {\n  *   return assert(isNumber(randomArbitrary(10)), true);\n  * });\n  *\n  * @example\n  * randomArbitrary(10);\n  * // => 9.1\n*/\nexport const randomArbitrary = (max, min = 0) => {\n\treturn randomMethod() * (max - min) + min;\n};\n/**\n  *  Produces a random integer between min (included) and max (excluded).\n  *\n  * @function randomInt\n  * @category number\n  * @type {Function}\n  * @param {number} max - Establishes highest possible value for the random number.\n  * @param {number} [min = 0] - Establishes lowest possible value for the random number.\n  * @returns {number} - Returns random integer between the max and min range.\n  *\n  * @test\n  * (async () => {\n  *   return assert(isNumber(randomInt(10)), true);\n  * });\n  *\n  * @example\n  * randomInt(10);\n  * // => 9\n*/\nexport const randomInt = (max, min = 0) => {\n\treturn floorMethod(randomMethod() * (max - min)) + min;\n};\n\n","import { randomInt } from '../number/math';\nimport { toArray } from '../internal/array';\n/**\n  * Shuffle an array and return a new array.\n  *\n  * @function shuffle\n  * @category array\n  * @param {Array} target - Target Array to be shuffled.\n  * @returns {Array} - An array with the shuffled results.\n  *\n  * @test\n  * (async () => {\n  *   const tempResult = shuffle([1, 2]);\n  *   return assert(tempResult.includes(1) && tempResult.includes(2), true);\n  * });\n  *\n  * @example\n  * shuffle([1, 2, 3, 4]);\n  * // => [3, 4, 2, 1]\n*/\nexport const shuffle = (target, amount = target.length) => {\n\tif (target.length <= 1) {\n\t\treturn toArray(target);\n\t}\n\tconst shuffleArray = toArray(target);\n\tlet count = 0;\n\tlet index;\n\tlet value;\n\twhile (count < amount) {\n\t\tindex = randomInt(shuffleArray.length - 1, 0);\n\t\tvalue = shuffleArray[count];\n\t\tshuffleArray[count] = shuffleArray[index];\n\t\tshuffleArray[index] = value;\n\t\tcount++;\n\t}\n\treturn shuffleArray;\n};\n\n","const mathNativeMin = Math.min;\n/**\n   * Plucks the smallest value from an array.\n   *\n   * @function smallest\n   * @category array\n   * @type {Function}\n   * @param {Array} array - Array from which smallest number is taken.\n   * @returns {number} - The smallest number.\n   *\n   * @example\n   * smallest([1,2,3]);\n   * // => 1\n */\nexport const smallest = (array) => {\n\treturn mathNativeMin(...array);\n};\n\n","import { hasValue } from '../internal/is';\n/**\n  * Iterates through the given array.\n  *\n  * @function eachArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   eachArray([1, 2, 3], (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [1, 2, 3]);\n  * });\n  *\n  * @example\n  * eachArray([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [1, 2, 3]\n*/\nexport const eachArray = (source, iteratee) => {\n\tconst arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\titeratee(source[index], index, source, arrayLength);\n\t}\n\treturn source;\n};\n/**\n  * Iterates through the given array in reverse.\n  *\n  * @function eachArrayRight\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   eachArrayRight([1, 2, 3], (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [3, 2, 1]);\n  * });\n  *\n  * @example\n  * eachArrayRight([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [1, 2, 3]\n*/\nexport const eachArrayRight = (source, iteratee) => {\n\tconst arrayLength = source.length;\n\tfor (let index = arrayLength - 1; index >= 0; index--) {\n\t\titeratee(source[index], index, source, arrayLength);\n\t}\n\treturn source;\n};\n/**\n  * Iterates through the given array while the iteratee returns true.\n  *\n  * @function whileArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n  * @returns {boolean} - Returns true if all returns are true or false if one value returns false.\n  *\n  * @example\n  * whileArray([true, true, false], (item) => {\n  *   return item;\n  * });\n  * // => false\n*/\nexport const whileArray = (source, iteratee) => {\n\tconst arrayLength = source.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tif (iteratee(source[index], index, source, arrayLength) === false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n/**\n  * Iterates through the calling array and creates an array with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filterArray\n  * @category array\n  * @type {Function}\n  * @category array\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created object, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - An array with properties that passed the test.\n  *\n  * @example\n  * filterArray([false, true, true], (item) => {\n  *   return item;\n  * });\n  * // => [true, true]\n*/\nexport const filterArray = (source, iteratee, results = []) => {\n\teachArray(source, (item, index, arrayOriginal, arrayLength) => {\n\t\tif (iteratee(item, index, results, arrayOriginal, arrayLength) === true) {\n\t\t\tresults.push(item);\n\t\t}\n\t});\n\treturn results;\n};\nconst generateMap = (callable) => {\n\treturn (source, iteratee, results = []) => {\n\t\tcallable(source, (item, index, arrayOriginal, arrayLength) => {\n\t\t\tresults[index] = iteratee(item, index, results, arrayOriginal, arrayLength);\n\t\t});\n\t\treturn results;\n\t};\n};\n/**\n  * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n  *\n  * @function mapArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - An array of the same calling array's type.\n  *\n  * @example\n  * mapArray([1, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [2, 4, 6]\n*/\nexport const mapArray = generateMap(eachArray);\n/**\n  * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array in reverse.\n  *\n  * @function mapArrayRight\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - An array of the same calling array's type.\n  *\n  * @example\n  * mapArrayRight([1, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [6, 4, 2]\n*/\nexport const mapArrayRight = (source, iteratee, results = []) => {\n\tlet trueIndex = 0;\n\tconst arrayLength = source.length;\n\tfor (let index = arrayLength - 1; index >= 0; index--) {\n\t\tresults[trueIndex] = iteratee(source[index], index, source, arrayLength);\n\t\ttrueIndex++;\n\t}\n\treturn results;\n};\n/**\n  * Iterates through the calling array and creates an array with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling array.\n  *\n  * @function compactMapArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - An array with mapped properties that are not null or undefined.\n  *\n  * @example\n  * compactMapArray([null, 2, 3], (item) => {\n  *   return item;\n  * });\n  * // => [2, 3]\n*/\nexport const compactMapArray = (source, iteratee, results = []) => {\n\teachArray(source, (item, index, arrayOriginal, arrayLength) => {\n\t\tconst returned = iteratee(item, index, results, arrayOriginal, arrayLength);\n\t\tif (hasValue(returned)) {\n\t\t\tresults.push(returned);\n\t\t}\n\t});\n\treturn results;\n};\n/**\n  * Iterates through the given and creates an object with all elements that pass the test implemented by the iteratee.\n  *\n  * @function mapWhile\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Array} - An array with properties that passed the test.\n  *\n  * @example\n  * mapWhile([true, true, false], (item) => {\n  *   return item;\n  * });\n  * // => [true, true]\n*/\nexport const mapWhile = (source, iteratee, results = []) => {\n\tconst arrayLength = source.length;\n\tfor (let index = 0;index < arrayLength;index++) {\n\t\tconst item = source[index];\n\t\tconst returned = iteratee(item, index, results, source, arrayLength);\n\t\tif (returned === false) {\n\t\t\tbreak;\n\t\t}\n\t\tresults[index] = item;\n\t}\n\treturn results;\n};\n/**\n  * Iterates through the given array but re-checks the length each loop. Usefull while mutating the same array being looped over.\n  *\n  * @function whileEachArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   whileEachArray([1, 2, 3], (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [1, 2, 3]);\n  * });\n  *\n  * @example\n  * whileEachArray([1, 2, 3], (item) => {\n  *   console.log(item);\n  * });\n  * // => [1, 2, 3]\n*/\nexport const whileEachArray = (source, iteratee) => {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\titeratee(source[index], index, source, source.length);\n\t\tindex++;\n\t}\n\treturn source;\n};\n/**\n  * Iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n  * Re-checks the length each loop.\n  *\n  * @function whileMapArray\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   whileMapArray([1, 2, 3, false, null], (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [1, 2, 3, false, null]);\n  * });\n  *\n  * @example\n  * whileMapArray([1, 2, 3, false, null], (item) => {\n  *   return item;\n  * });\n  * // => [1, 2, 3, false, null]\n*/\nexport const whileMapArray = (source, iteratee, results = []) => {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\tresults.push(iteratee(source[index], index, source, source.length));\n\t\tindex++;\n\t}\n\treturn source;\n};\n/**\n  * Iterates through the calling object and creates a new object based on the calling object's type with the results,\n  * (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  * Re-checks the length each loop.\n  *\n  * @function whileCompactMap\n  * @category array\n  * @type {Function}\n  * @param {Array} source - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   whileCompactMap([1, 2, 3, false, undefined, null], (item) => {\n  *     return item;\n  *   });\n  *   return assert(tempList, [1, 2, 3, false]);\n  * });\n  *\n  * @example\n  * whileCompactMap([1, 2, 3, false, undefined, null], (item) => {\n  *   return item;\n  * });\n  * // => [1, 2, 3, false]\n*/\nexport const whileCompactMap = (source, iteratee, results = []) => {\n\tlet index = 0;\n\twhile (index < source.length) {\n\t\tconst result = results.push(iteratee(source[index], index, source, source.length));\n\t\tindex++;\n\t\tif (hasValue(result)) {\n\t\t\tresults.push(result);\n\t\t}\n\t}\n\treturn source;\n};\n\n","/**\n  * Removes all items from an array after a specified index.\n  *\n  * @function drop\n  * @category array\n  * @type {Function}\n  * @param {Array} array - Source array.\n  * @param {number} amount - Amount of items to drop from the array.\n  * @param {number} [upTo = array.length] - Index to stop at.\n  * @returns {Array} - An array with all values removed after a user defined index.\n  *\n  * @example\n  * drop([1, 2, 3], 1);\n  * // => [2, 3]\n*/\nexport const drop = (array, amount, upTo = array.length) => {\n\treturn array.splice(amount, upTo);\n};\n/**\n  * Removes all items from an array before a specified index.\n  *\n  * @function dropRight\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Source array.\n  * @param {number} amount - Amount of items to drop from the array.\n  * @param {number} [upTo = array.length] - Index to stop at.\n  * @returns {Array} - An array with all values removed before a user defined index.\n  *\n  * @example\n  * dropRight([1, 2, 3], 1);\n  * // => [1, 2]\n*/\nexport const dropRight = (array, amount, upTo = array.length) => {\n\treturn drop(array, 0, upTo - amount);\n};\n\n","import { whileArray } from './each';\n/**\n   * Performs a shallow strict comparison between two objects.\n   *\n   * @function isMatchArray\n   * @type {Function}\n   * @category array\n   * @param {Array} source - Source object.\n   * @param {Array} compareArray - Object to compare to source.\n   * @returns {boolean} - Returns true or false.\n   *\n   * @example\n   * isMatchArray([1, 2, 3], [1, 2, 3]);\n   * // => true\n */\nexport const isMatchArray = (source, compareArray) => {\n\tif (source.length === compareArray.length) {\n\t\treturn whileArray(source, (item, index) => {\n\t\t\treturn compareArray[index] === item;\n\t\t});\n\t}\n\treturn false;\n};\n\n","const mathNativeMax = Math.max;\n/**\n  * Plucks the largest value from an array.\n  *\n  * @function largest\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array from which largest number is taken.\n  * @returns {number} - The largest number.\n  *\n  * @example\n  * largest([1,2,3]);\n  * // => 3\n*/\nexport const largest = (array) => {\n\treturn mathNativeMax(...array);\n};\n\n","/**\n  * Asynchronously Iterates through the given array. Each async function is awaited as to ensure synchronous order.\n  *\n  * @function eachAsync\n  * @category array\n  * @type {Function}\n  * @async\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   await eachAsync([1, 2, 3], async (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [1, 2, 3]);\n  * });\n  *\n  * @example\n  * eachAsync([3,4], async (item, index) =>{\n  *  console.log(item, index);\n  * });\n  * // 3 0\n  * // 4 1\n*/\nexport const eachAsync = async (callingArray, iteratee) => {\n\tconst arrayLength = callingArray.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tawait iteratee(callingArray[index], index, callingArray, arrayLength);\n\t}\n\treturn callingArray;\n};\n/**\n  * Asynchronously Iterates through the given array in reverse. Each async function is awaited as to ensure synchronous order.\n  *\n  * @function eachAsyncRight\n  * @category array\n  * @type {Function}\n  * @async\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, calling array, and array length.\n  * @returns {Object} - The originally given array.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   await eachAsyncRight([1, 2, 3], async (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [3, 2, 1]);\n  * });\n  *\n  * @example\n  * eachAsyncRight([3,4], async (item, index) =>{\n  *  console.log(item, index);\n  * });\n  * // 4 0\n  * // 3 1\n*/\nexport const eachAsyncRight = async (callingArray, iteratee) => {\n\tconst arrayLength = callingArray.length;\n\tfor (let index = arrayLength - 1; index >= 0; index--) {\n\t\tawait iteratee(callingArray[index], index, callingArray, arrayLength);\n\t}\n\treturn callingArray;\n};\n\n","import { eachAsync } from './eachAsync';\n/**\n  * Asynchronously iterates through the calling array and creates an object with the results of the iteratee on every element in the calling array.\n  *\n  * @function mapAsync\n  * @category array\n  * @type {Function}\n  * @async\n  * @param {Array} callingArray - Array that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, index, the newly created array, calling array, and array length.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Array} - An array of the same calling array's type.\n  *\n  * @example\n  * mapAsync([1, 2, 3], (item) => {\n  *   return item * 2;\n  * });\n  * // => [2, 4, 6]\n*/\nexport const mapAsync = async (array, iteratee) => {\n\tconst results = [];\n\tawait eachAsync(array, async (item, index, arrayLength) => {\n\t\tresults[index] = await iteratee(item, index, arrayLength);\n\t});\n\treturn results;\n};\n\n","const onlyUnique = (value, index, array) => {\n\treturn array.indexOf(value) === index;\n};\nconst sortUnique = (item, index, array) => {\n\treturn item !== array[index - 1];\n};\n/**\n  * Filters the array down to unique elements.\n  *\n  * @function unique\n  * @category array\n  * @type {Function}\n  * @param {Array} array - The array to be filtered.\n  * @returns {Array} - The filtered array.\n  *\n  * @example\n  * unique([1, 2, 2, 4]);\n  * // => [1, 2, 4]\n*/\nexport const unique = (array, isSorted) => {\n\tif (isSorted) {\n\t\treturn array.filter(sortUnique);\n\t}\n\treturn array.filter(onlyUnique);\n};\n\n","export const numericalCompare = (a, b) => {\n\treturn a - b;\n};\n/**\n  * Sorts an array in place using a numerical comparison algorithm from lowest to highest.\n  *\n  * @function numSort\n  * @category array\n  * @type {Function}\n  * @param {Array} numberList - Array of numbers.\n  * @returns {Array} - The array this method was called on.\n  *\n  * @example\n  * numSort([10, 0, 2, 1]);\n  * // => [0, 1, 2, 10]\n*/\nexport const numSort = (numberList) => {\n\treturn numberList.sort(numericalCompare);\n};\n\n","export const numericalCompareReverse = (a, b) => {\n\treturn b - a;\n};\n/**\n  * Sorts an array in place using a reverse numerical comparison algorithm from highest to lowest.\n  *\n  * @function rNumSort\n  * @category array\n  * @param {Array} numberList - Array of numbers.\n  * @returns {Array} - The array this method was called on.\n  *\n  * @example\n  * rNumSort([10, 0, 2, 1]);\n  * // => [10, 2, 1, 0]\n*/\nexport const rNumSort = (numberList) => {\n\treturn numberList.sort(numericalCompareReverse);\n};\n\n","import { hasValue } from '../internal/is';\n/**\n  * Iterates based on a start index and an end index. The loop ends when the start index is equal to the end index.\n  *\n  * @function times\n  * @category array\n  * @type {Function}\n  * @param {number} startIndex - The number to start loop from.\n  * @param {number} endIndex - The number to stop at the loop.\n  * @param {Function} iteratee - Transformation function which is passed position, start, and end.\n  * @returns {undefined} - Nothing.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   times(0, 3, (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [0, 1, 2]);\n  * });\n  *\n  * @example\n  * times(0, 3, (item) => {\n  *   console.log(item);\n  * });\n  * //Will log\n  * // 0\n  * // 1\n  * // 2\n  * // => undefined\n*/\nexport const times = (startIndex, endIndex, iteratee) => {\n\tconst start = (iteratee) ? startIndex : 0;\n\tconst end = (iteratee) ? endIndex : startIndex;\n\tconst iterateeMethod = iteratee || endIndex;\n\tfor (let position = start; position < end; position++) {\n\t\titerateeMethod(position, start, end);\n\t}\n};\n/**\n  * Iterates based on a start index and end index. Creates an array with the results of the iteratee on every element in the calling array. The loop ends when the start index is equal to the end index.\n  *\n  * @function timesMap\n  * @category array\n  * @type {Function}\n  * @param {number} startIndex - The number to start loop from.\n  * @param {number} endIndex - The number to stop at the loop.\n  * @param {Function} iteratee - Transformation function which is passed position, start, and end.\n  * @param {Array} [results = []] - Array that will be used to assign results.\n  * @returns {Object} - An array with iteratee's returned values.\n  *\n  * @example\n  * timesMap(0, 3, (item) => {\n  *   return item;\n  * });\n  * // => [0, 1, 2]\n*/\nexport const timesMap = (startIndex, endIndex, iteratee, results = []) => {\n\tconst start = (iteratee) ? startIndex : 0;\n\tconst end = (iteratee) ? endIndex : startIndex;\n\tconst iterateeMethod = iteratee || endIndex;\n\tlet result;\n\ttimes(start, end, (position) => {\n\t\tresult = iterateeMethod(position, start, end, results);\n\t\tif (hasValue(result)) {\n\t\t\tresults.push(result);\n\t\t}\n\t});\n\treturn results;\n};\n\n","import { hasValue } from '../internal/is';\nimport { keys } from '../internal/object';\nimport { eachArray, whileArray } from '../array/each';\n/**\n  * Iterates through the given object.\n  *\n  * @function eachObject\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling object, key count, and array of keys.\n  * @returns {Object|Function} - Returns the calling object.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = {};\n  *   eachObject({a: 1, b: 2, c: 3}, (item, key) => {\n  *     tempList[key] = item;\n  *   });\n  *   return assert(tempList, {a: 1, b: 2, c: 3});\n  * });\n  *\n  * @example\n  * eachObject({a: 1, b: 2, c: 3}, (item) => {\n  *   console.log(item);\n  * });\n  * // => {a: 1, b: 2, c: 3}\n*/\nexport const eachObject = (source, iteratee) => {\n\tconst objectKeys = keys(source);\n\teachArray(objectKeys, (key, index, original, propertyCount) => {\n\t\titeratee(source[key], key, source, propertyCount, original);\n\t});\n};\n/**\n  * Iterates through the given object while the iteratee returns true.\n  *\n  * @function whileObject\n  * @category object\n  * @type {Function}\n  * @param {Object} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n  * @returns {boolean} - Returns true if all values returned are true or false if one value returns false.\n  *\n  * @example\n  * whileObject({a: false, b: true, c: true}, (item) => {\n  *   return item;\n  * });\n  * // => false\n  * @example\n  * whileObject({a: true, b: true, c: true}, (item) => {\n  *   return item;\n  * });\n  * // => true\n*/\nexport const whileObject = (source, iteratee) => {\n\tconst objectKeys = keys(source);\n\treturn whileArray(objectKeys, (key, index, original, propertyCount) => {\n\t\treturn iteratee(source[key], key, source, propertyCount, original);\n\t});\n};\n/**\n  * Iterates through the calling object and creates an object with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filterObject\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} - An object with properties that passed the test.\n  *\n  * @example\n  * filterObject({a: false, b: true, c: true}, (item) => {\n  *   return item;\n  * });\n  * // => {b: true, c: true}\n*/\nexport const filterObject = (source, iteratee, results = {}) => {\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tif (iteratee(item, key, results, original, propertyCount, objectKeys) === true) {\n\t\t\tresults[key] = item;\n\t\t}\n\t});\n\treturn results;\n};\n/**\n  * Iterates through the calling object and creates an object with the results of the iteratee on every element in the calling object.\n  *\n  * @function mapObject\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} - An object of the same calling object's type.\n  *\n  * @example\n  * mapObject({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const mapObject = (source, iteratee, results = {}) => {\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tresults[key] = iteratee(item, key, results, original, propertyCount, objectKeys);\n\t});\n\treturn results;\n};\n/**\n  * Iterates through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  *\n  * @function compactMapObject\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} - An object with mapped properties that are not null or undefined.\n  *\n  * @example\n  * compactMapObject({a: undefined, b: 2, c: 3}, (item) => {\n  *   return item;\n  * });\n  * // => {b: 2, c: 3}\n*/\nexport const compactMapObject = (source, iteratee, results = {}) => {\n\teachObject(source, (item, key, original, propertyCount, objectKeys) => {\n\t\tconst result = iteratee(item, key, results, original, propertyCount, objectKeys);\n\t\tif (hasValue(result)) {\n\t\t\tresults[key] = result;\n\t\t}\n\t});\n\treturn results;\n};\n\n","import { eachArray } from '../array/each';\nimport { eachObject } from '../object/each';\nimport { isBoolean } from '../internal/is';\nimport { keys } from '../internal/object';\n/**\n  * Checks to see of the browser agent has a string.\n  *\n  * @function isAgent\n  * @category browser\n  * @type {Function}\n  * @param {string} value - The string to search for.\n  * @returns {boolean} - Returns true or false.\n  * @example\n  * isAgent('mobile');\n  * // => false\n*/\nexport const isAgent = (value) => {\n\treturn (value) ? isAgent[value] : keys(isAgent);\n};\nconst userAgent = globalThis.navigator?.userAgentData;\nif (userAgent) {\n\teachObject(userAgent, (value, key) => {\n\t\tif (isBoolean(value) && value) {\n\t\t\tisAgent[key] = value;\n\t\t}\n\t});\n\teachArray(userAgent.brands, (value) => {\n\t\tisAgent[value.brand] = value.version;\n\t});\n} else if (navigator.userAgent) {\n\tlet userAgentNormalized = navigator.userAgent.toLowerCase();\n\tuserAgentNormalized = userAgentNormalized.replace(/_/g, '.');\n\tuserAgentNormalized = userAgentNormalized.replace(/[#_,;()]/g, '');\n\tconst userAgentSplit = userAgentNormalized.split(/ |\\//);\n\teachArray(userAgentSplit, (item) => {\n\t\tisAgent[item] = true;\n\t});\n}\n\n","/**\n  * Attaches an event listener to a node.\n  *\n  * @function eventAdd\n  * @category browser\n  * @type {Function}\n  * @param {Node} node - Given node.\n  * @param {string} type - A string representing the event type.\n  * @param {Object|Function} listener - The object which receives a notification when an event of the specified type occurs.\n  * @param {Object} options - An options object that specifies characteristics about the event listener.\n  * @returns {Node} - Returns given node.\n  *\n  * @example\n  * eventAdd(document.body, 'click', () => {console.log('CLICKED');});\n  * // = > document.body\n*/\nexport const eventAdd = (node, ...args) => {\n\tnode.addEventListener(...args);\n\treturn node;\n};\n/**\n  * Attaches an event listener to a node.\n  *\n  * @function eventRemove\n  * @category browser\n  * @type {Function}\n  * @param {Node} node - Given node.\n  * @param {string} type - A string representing the event type.\n  * @param {Object|Function} listener - An object|function representing the listener.\n  * @param {Object} options - An options object that specifies characteristics about the event listener.\n  * @returns {undefined} - Undefined.\n  *\n  * @example\n  * eventRemove(document.body, () => {console.log('CLICKED');});\n  * // = > Undefined\n*/\nexport const eventRemove = (node, ...args) => {\n\tnode.removeEventListener(...args);\n\treturn node;\n};\n\n","/**\n  * Create a document fragment.\n  *\n  * @function createFragment\n  * @category browser\n  * @type {Function}\n  * @ignore\n  * @returns {Fragment} - Returns a new document fragment.\n*/\nexport const createFragment = document.createDocumentFragment.bind(document);\n","/**\n  * Append a DOM node.\n  *\n  * @function append\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @ignore\n  * @param {Node} parentNode - The parent node.\n  * @param {Node} child - The node to be appended.\n  * @returns {undefined} - Returns the child.\n*/\nexport const append = (parentNode, child) => {\n\tparentNode.appendChild(child);\n\treturn child;\n};\n","import { eachArray } from '../array/each';\nimport { eachObject } from './each';\n/**\n  * Creates an object from two arrays, one of property identifiers and one of corresponding values.\n  *\n  * @function zipObject\n  * @type {Function}\n  * @category object\n  * @param {Array} properties - The property identifiers.\n  * @param {Array} values - The property values.\n  * @returns {Object} - Returns the new object.\n  *\n  * @example\n  * zipObject(['a', 'b'], [1, 2]);\n  * // => { 'a': 1, 'b': 2 }\n*/\nexport const zipObject = (properties, values) => {\n\tconst zipedObject = {};\n\teachArray(properties, (item, key) => {\n\t\tzipedObject[item] = values[key];\n\t});\n\treturn zipedObject;\n};\n/**\n  * Takes an array of grouped elements and creates an array regrouping the elements to their pre-zip object configuration.\n  *\n  * @function unZipObject\n  * @type {Function}\n  * @category object\n  * @param {Object} object - The object to process.\n  * @returns {Array} - Returns two arrays one of keys and the other of values inside a single array.\n  *\n  * @example\n  * unZipObject({ 'a': 1, 'b': 2 });\n  * // => [['a', 'b'], [1, 2]]\n*/\nexport const unZipObject = (object) => {\n\tconst unZippedKeys = [];\n\tconst values = [];\n\teachObject(object, (item, key) => {\n\t\tunZippedKeys.push(key);\n\t\tvalues.push(item);\n\t});\n\treturn [unZippedKeys, values];\n};\n\n","import { eachObject } from '../object/each';\nimport { isArray } from '../internal/is';\nimport { mapArray } from '../array/each';\nimport { zipObject } from '../object/zip';\n/**\n  * Assign attributes to a DOM node.\n  *\n  * @function nodeAttribute\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @async\n  * @param {Node} node - The DOM node.\n  * @param {Object|Array} object - Object with key being the attribute name and the value being the attribute value. If an array is given it will get the values corresponding to the array items.\n  * @returns {Object|Node} - If using an array this returns an object of attribute names as keys and their values as the property value. If using an object this will return the provided node.\n  *\n  * @example\n  * nodeAttribute(document.body, { 'data-example': 'test'});\n*/\nexport const nodeAttribute = (node, object) => {\n\tif (isArray(object)) {\n\t\treturn zipObject(object, mapArray(object, (item) => {\n\t\t\treturn node.getAttribute(item);\n\t\t}));\n\t}\n\teachObject(object, (item, key) => {\n\t\tnode.setAttribute(key, item);\n\t});\n\treturn node;\n};\n\n","/**\n  * A wrapper around the promise constructor.\n  *\n  * @function promise\n  * @type {Function}\n  * @category utility\n  * @param {Function} callback - Function to be called back.\n  * @returns {Object} - A constructor with a callback function.\n  *\n  * @test\n  * (async () => {\n  *   const result = await promise((accept) => {\n  *     accept(true);\n  *   });\n  *   return assert(result, true);\n  * });\n  *\n  * @example\n  * promise((a) => {});\n  * // => Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n*/\nexport const promise = (callback) => {\n\treturn new Promise(callback);\n};\n\n","/**\n  * Inserts text into a string at a given position.\n  *\n  * @function insertInRange\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to insert the text into.\n  * @param {number} index - Point of insertion.\n  * @param {string} text - The string to be inserted.\n  * @returns {string} - The string with the text inserted at the given point.\n  *\n  * @example\n  * insertInRange('A from Lucy.', 1, ' tab');\n  * // => 'A tab from Lucy.'\n*/\nexport const insertInRange = (string, index, text) => {\n\treturn string.slice(0, index) + text + string.slice(index, string.length);\n};\n/**\n  * Plucks a letter using the index starting from the right.\n  *\n  * @function rightString\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to extract the letter from.\n  * @param {number} [index=1] - The starting position.\n  * @returns {string} - A letter at the given index.\n  *\n  * @example\n  * rightString('rightString');\n  * // => 'g'\n  * @example\n  * rightString('rightString', 2);\n  * // => 'n'\n*/\nexport const rightString = (string, index = 1) => {\n\treturn string[string.length - index];\n};\n/**\n  * Splits up a string into chunks.\n  *\n  * @function chunkString\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to chunked.\n  * @param {number} [size] - The max string length per chunk.\n  * @returns {Array} - An array with strings that are <= size parameter.\n  *\n  * @example\n  * chunkString('chunk', 2);\n  * // => ['ch', 'un', 'k']\n*/\nexport const chunkString = (string, size) => {\n\treturn string.match(new RegExp(`(.|[\\r\\n]){1,${size}}`, 'g'));\n};\n/**\n  * Truncates everything before the index starting from the right.\n  *\n  * @function initialString\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to extract the initial letters from.\n  * @param {number} [index=1] - Starting point from the right.\n  * @returns {string} - A string with the characters before the index starting from the right.\n  *\n  * @example\n  * initialString('initialString');\n  * // => 'initialStrin'\n  * @example\n  * initialString('initialString', 2);\n  * // => 'initialStri'\n*/\nexport const initialString = (string, index = 1) => {\n\treturn string.slice(0, index * -1);\n};\n/**\n  * Truncates everything after a index.\n  *\n  * @function restString\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to extract the rest of the letters from.\n  * @param {number} [index=1] - Starting point.\n  * @returns {string} - A string without the characters up-to to the index.\n  *\n  * @example\n  * restString('restString');\n  * // => 'estString'\n  * @example\n  * restString('restString', 2);\n  * // => 'stString'\n*/\nexport const restString = (string, index = 1) => {\n\treturn string.substr(index);\n};\n\n","import { restString } from '../string/range';\nconst dotString = '.';\nconst poundString = '#';\nconst classTest = /^.[\\w_-]+$/;\nconst tagTest = /^[A-Za-z]+$/;\nconst regexSpace = /\\s/;\n/**\n  * Wrapper around getElementsByClassName.\n  *\n  * @function getByClass\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n*/\nexport const getByClass = document.getElementsByClassName.bind(document);\n/**\n  * Wrapper around getElementsByTagName.\n  *\n  * @function getByTag\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n*/\nexport const getByTag = document.getElementsByTagName.bind(document);\n/**\n  * Wrapper around getElementsByIdName.\n  *\n  * @function getById\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n*/\nexport const getById = document.getElementById.bind(document);\n/**\n  * Wrapper around querySelector.\n  *\n  * @function querySelector\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n*/\nexport const querySelector = document.querySelector.bind(document);\n/**\n  * Wrapper around querySelectorAll.\n  *\n  * @function querySelectorAll\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n*/\nexport const querySelectorAll = document.querySelectorAll.bind(document);\n/**\n  * Returns relevant DOM node.\n  *\n  * @function selector\n  * @category browser\n  * @ignoreTest\n  * @param {string} select - String to be evaluated.\n  * @type {Function}\n  * @returns {Node} - Returns a DOM node.\n  *\n  * @example\n  * selector('#node');\n  * // => <div id=\"node\"></div>\n*/\nexport const selector = (select) => {\n\tconst firstLetter = select[0];\n\tswitch (firstLetter) {\n\tcase poundString:\n\t\tif (!regexSpace.test(select)) {\n\t\t\treturn getById(restString(select));\n\t\t}\n\t\tbreak;\n\tcase dotString:\n\t\tif (classTest.test(select)) {\n\t\t\treturn getByClass(restString(select));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (tagTest.test(select)) {\n\t\t\treturn getByTag(select);\n\t\t}\n\t}\n\treturn querySelectorAll(select);\n};\n\n","import { append } from './append';\nimport { eventAdd } from './event';\nimport { nodeAttribute } from './attribute';\nimport { promise } from '../utility/promise';\nimport { querySelector } from './selector';\nconst createTag = document.createElement.bind(document);\nconst nodeAttachLoadingEvents = (node) => {\n\treturn promise((accept, reject) => {\n\t\teventAdd(node, 'load', accept, true);\n\t\teventAdd(node, 'error', reject, true);\n\t\tappend(querySelector('head'), node);\n\t});\n};\n/**\n  * Asynchronously import a js file and append it to the head node.\n  *\n  * @function importjs\n  * @category browser\n  * @type {Function}\n  * @async\n  * @returns {Promise} - Returns a promise.\n  *\n  * @example\n  * importjs('core.js');\n*/\nexport const importjs = (url) => {\n\tconst node = nodeAttribute(createTag('script'), {\n\t\tasync: '',\n\t\tsrc: `${url}.js`\n\t});\n\treturn nodeAttachLoadingEvents(node);\n};\n\n","import { eventAdd } from './event';\nimport { importjs } from './importScript';\n/**\n  * Runs a function if the document has finished loading. If not, add an eventlistener.\n  *\n  * @function isDocumentReady\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @param {Function} callable - Function to be run.\n  * @returns {Boolean|Function} - If the document is ready, returns a function. If not, return false.\n  *\n  * @example\n  * isDocumentReady(() => {return 1});\n  * // => 1\n*/\nexport const isDocumentReady = (callable) => {\n\tconst state = document.readyState;\n\tconst checkStatus = state === 'interactive' || state === 'completed' || state === 'complete';\n\tif (checkStatus) {\n\t\treturn (callable) ? callable() : true;\n\t}\n\tif (callable) {\n\t\teventAdd(document, 'DOMContentLoaded', callable);\n\t}\n\treturn false;\n};\nisDocumentReady(() => {\n\timportjs('/index');\n});\n","const protocol = location.protocol;\nconst protocolSocket = (protocol === 'http:') ? 'ws' : 'wss';\nconst hostname = location.hostname;\n/**\n  * Holds client hardware, browser, and host info.\n  *\n  * @memberof $\n  * @category browser\n  * @ignoreTest\n  * @property info\n  * @type {Object}\n*/\nexport const info = {\n\thardware: {\n\t\tcores: navigator.hardwareConcurrency\n\t},\n\thost: {\n\t\tname: hostname,\n\t\tprotocol,\n\t\tprotocolSocket,\n\t}\n};\n\n","import { assign } from '../internal/object';\nimport { eventAdd } from './event';\nimport { info } from './info';\nimport { isDocumentReady } from './ready';\nexport const saveDimensions = () => {\n\tassign(info, {\n\t\tbodyHeight: document.body.offsetHeight,\n\t\tbodyWidth: document.body.offsetWidth,\n\t\twindowHeight: window.innerHeight,\n\t\twindowWidth: window.innerWidth,\n\t});\n};\n/**\n  * Save current document & window dimensions to the info property.\n  *\n  * @function updateDimensions\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * updateDimensions();\n*/\nexport const updateDimensions = () => {\n\tsaveDimensions();\n};\nisDocumentReady(updateDimensions);\neventAdd(window, 'load', updateDimensions, true);\neventAdd(window, 'resize', updateDimensions, true);\n\n","const jsonNative = JSON;\n/**\n   * Parses JSON string.\n   *\n   * @function jsonParse\n   * @category utility\n   * @type {Function}\n   * @param {string} string - String to be parsed.\n   * @returns {Object} - Returns the parsed object.\n   *\n   * @example\n   * jsonParse('{}');\n   * // => {}\n */\nexport const jsonParse = jsonNative.parse;\n/**\n   * Stringify an object into a JSON string.\n   *\n   * @function stringify\n   * @category utility\n   * @type {Function}\n   * @param {Object} object - Object to Stringify.\n   * @returns {string} - Returns the object as a valid JSON string.\n   *\n   * @example\n   * stringify({});\n   * // => '{}'\n */\nexport const stringify = jsonNative.stringify;\n\n","import { hasValue, isString } from '../internal/is';\nimport { stringify } from '../utility/json';\n/**\n  * A virtual storage & drop in replacement for localStorage.\n  * The virtualStorage function is a factory which wraps the VirtualStorage constructor & returns it.\n  * Direct class/constructor access is named VirtualStorage.\n  *\n  * @function virtualStorage\n  * @category browser\n  * @type {Function}\n  * @returns {*} - Returns a new VirtualStorage Object.\n  *\n  * @example\n  * const myVirtualStorage = virtualStorage();\n  * // => New Crate Object\n*/\n/**\n  * Save an item to a virtual storage object.\n  *\n  * @function virtualStorage.setItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to store the data.\n  * @param {*} value - If saving to localStorage, & the object isn't a string it will be converted to a string using JSON.stringify\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const myVirtualStorage = virtualStorage();\n  * myVirtualStorage.setItem('key', 'value');\n  * // => undefined\n*/\n/**\n  * Get an item from a virtual storage object.\n  *\n  * @function virtualStorage.getItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to store the data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const myVirtualStorage = virtualStorage();\n  * myVirtualStorage.setItem('key', 'value');\n  * myVirtualStorage.getItem('key');\n  * // => 'value'\n*/\n/**\n  * Remove an item from a virtual storage object.\n  *\n  * @function virtualStorage.removeItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to remove data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const myVirtualStorage = virtualStorage();\n  * myVirtualStorage.setItem('key', 'value');\n  * myVirtualStorage.removeItem('key');\n  * myVirtualStorage.getItem('key');\n  * // => undefined\n*/\n/**\n  * Clears all data from the virtual storage object by replacing with a new object.\n  *\n  * @function virtualStorage.clear\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to remove data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const myVirtualStorage = virtualStorage();\n  * myVirtualStorage.setItem('key', 'value');\n  * myVirtualStorage.clear();\n  * myVirtualStorage.getItem('key');\n  * // => undefined\n*/\nexport class VirtualStorage {\n\tconstructor(initialObject = {}) {\n\t\tthis.items = initialObject;\n\t}\n\tgetItem(key) {\n\t\treturn this.items[key];\n\t}\n\tsetItem(key, value) {\n\t\tthis.items[key] = value;\n\t}\n\tclear() {\n\t\tthis.items = {};\n\t}\n\tremoveItem(key) {\n\t\tthis.items[key] = null;\n\t}\n}\nexport function virtualStorage() {\n\treturn new VirtualStorage();\n}\n/**\n  * Create a virtual storage container with localStorage support. Crate will fallback to strictly virtual storage if localStorage isn't supported. If localStorage is supported virtual storage will be used first and only fallback to localStorage when needed. Crate is ideal as a seemless drop in replacement for localStorage when the browser doesn't support or allow localStorage.\n  * The crate function is a factory which wraps the Crate constructor & returns it.\n  * Direct class/constructor access is named Crate.\n  *\n  * @function crate\n  * @category browser\n  * @type {Function}\n  * @returns {*} - Returns a new Crate Object.\n  *\n  * @example\n  * const storageCrate = crate();\n  * // => New Crate Object\n*/\n/**\n  * Save an item to a crate.\n  *\n  * @function crate.setItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to store the data.\n  * @param {*} value - If saving to localStorage, & the object isn't a string it will be converted to a string using JSON.stringify\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const storageCrate = crate();\n  * storageCrate.setItem('key', 'value');\n  * // => undefined\n*/\n/**\n  * Get an item from a crate.\n  *\n  * @function crate.getItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to store the data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const storageCrate = crate();\n  * storageCrate.setItem('key', 'value');\n  * storageCrate.getItem('key');\n  * // => 'value'\n*/\n/**\n  * Remove an item from a crate.\n  *\n  * @function crate.removeItem\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to remove data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const storageCrate = crate();\n  * storageCrate.setItem('key', 'value');\n  * storageCrate.removeItem('key');\n  * storageCrate.getItem('key');\n  * // => undefined\n*/\n/**\n  * Clears all data for the crate including all of localStorage if supported.\n  *\n  * @function crate.clear\n  * @category browser\n  * @type {Function}\n  * @param {string} key - The key used to remove data.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * const storageCrate = crate();\n  * storageCrate.setItem('key', 'value');\n  * storageCrate.clear();\n  * storageCrate.getItem('key');\n  * // => undefined\n*/\nexport let hasLocal;\nfunction hasStorage(storeCheck) {\n\ttry {\n\t\tstoreCheck().removeItem('TESTING');\n\t\thasLocal = true;\n\t} catch (e) {\n\t\thasLocal = false;\n\t}\n}\nhasStorage(() => {\n\treturn localStorage;\n});\nexport class Crate {\n\tconstructor(initialObject) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local = localStorage;\n\t\t}\n\t\tthis.storage = virtualStorage(initialObject);\n\t}\n\thasLocal = hasLocal;\n\tsetItem(key, value) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.setItem(key, (isString(value)) ? value : stringify(value));\n\t\t}\n\t\treturn this.storage.setItem(key, value);\n\t}\n\tgetItem(key) {\n\t\tconst item = this.storage.getItem(key);\n\t\tif (hasValue(item)) {\n\t\t\treturn item;\n\t\t}\n\t\tif (!hasValue(item) && this.hasLocal) {\n\t\t\treturn this.local.getItem(key);\n\t\t}\n\t}\n\tclear() {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.clear();\n\t\t}\n\t\tthis.storage.clear();\n\t}\n\tremoveItem(key) {\n\t\tif (this.hasLocal) {\n\t\t\tthis.local.removeItem(key);\n\t\t}\n\t\tthis.storage.removeItem(key);\n\t}\n}\nexport function crate(virtualFlag) {\n\treturn new Crate(virtualFlag);\n}\n\n","import { isString } from '../internal/is';\nimport { stringify } from '../utility/json';\nconst generateTheme = (color, bg) => {\n\treturn `color:${color};background:${bg};`;\n};\nexport const themes = {\n\talert: generateTheme('#fff', '#f44336'),\n\timportant: generateTheme('#fff', '#E91E63'),\n\tnotify: generateTheme('#fff', '#651FFF'),\n\twarning: generateTheme('#000', '#FFEA00'),\n};\n/**\n  * Console.trace wrapper with theme support.\n  *\n  * @function cnsl\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @param {Object} value - The value to be logged.\n  * @param {string} themeName - The name of the theme to be used.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * cnsl('Lucy', 'notify');\n  * // 'Lucy'\n*/\nexport const cnsl = (value, themeName) => {\n\tconst data = isString(value) ? value : stringify(value);\n\tif (themeName === 'alert' || themeName === 'warning') {\n\t\treturn console.trace(`%c${data}`, `${themes[themeName]}font-size:13px;padding:2px 5px;border-radius:2px;`);\n\t}\n\tconsole.log(`%c${data}`, `${themes[themeName]}font-size:13px;padding:2px 5px;border-radius:2px;`);\n};\n/**\n  * Create color themes for cnsl method.\n  *\n  * @function cnslTheme\n  * @category browser\n  * @ignoreTest\n  * @type {Function}\n  * @param {string} themeName - The name of the theme.\n  * @param {string} color - The text color.\n  * @param {string} background - The background color of the block.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * cnslTheme('BlackNWhite', '#fff', '#000');\n*/\nexport const cnslTheme = (themeName, color, background) => {\n\tthemes[themeName] = generateTheme(color, background);\n};\n\n","/**\n  * Sorts an array in place using a key from newest to oldest.\n  *\n  * @function sortNewest\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Collection to be sorted.\n  * @param {string} propertyName - The property name to sort by based on it's value.\n  * @param {boolean} [pureMode = true] - Mutates the source array. If set to false creates a new array.\n  * @returns {Array} - The sorted array and or a clone of the array sorted.\n  *\n  * @example\n  * sortNewest([{id: 1}, {id: 0}], 'id');\n  * // => [{id: 1}, {id: 0}]\n*/\nexport const sortNewest = (collection, propertyName, pureMode = true) => {\n\tconst array = (pureMode) ? collection : [...collection];\n\treturn array.sort((previous, next) => {\n\t\tif (!next[propertyName]) {\n\t\t\treturn -1;\n\t\t} else if (!previous[propertyName]) {\n\t\t\treturn 1;\n\t\t} else if (previous[propertyName] < next[propertyName]) {\n\t\t\treturn 1;\n\t\t} else if (previous[propertyName] > next[propertyName]) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t});\n};\n/**\n  * Sorts an array in place using a key from newest to oldest and returns the latest. Does not mutate the array.\n  *\n  * @function getNewest\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Collection to be sorted.\n  * @param {string} propertyName - The property name to sort by based on it's value.\n  * @returns {Object} - The newest object in the collection.\n  *\n  * @example\n  * getNewest([{id: 1}, {id: 0}], 'id');\n  * // => {id: 1}\n*/\nexport const getNewest = (collection, propertyName) => {\n\treturn sortNewest(collection, propertyName, false)[0];\n};\n\n","/**\n  * Sorts an array in place using a key from oldest to newest.\n  *\n  * @function sortOldest\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Collection to be sorted.\n  * @param {string} key - The property name to sort by based on it's value.\n  * @param {boolean} [pureMode = true] - Mutates the source array. If set to false creates a new array.\n  * @returns {Array} - The sorted array and or a clone of the array sorted.\n  *\n  * @example\n  * sortOldest([{id: 1}, {id: 0}], 'id');\n  * // => [{id: 0}, {id: 1}]\n*/\nexport const sortOldest = (collection, key = 'id', pureMode = true) => {\n\tconst array = (pureMode) ? collection : [...collection];\n\treturn array.sort((previous, next) => {\n\t\tif (!next[key]) {\n\t\t\treturn 1;\n\t\t} else if (!previous[key]) {\n\t\t\treturn -1;\n\t\t} else if (previous[key] < next[key]) {\n\t\t\treturn -1;\n\t\t} else if (previous[key] > next[key]) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n};\n/**\n  * Sorts an array in place using a key from oldest to newest and returns the oldest. Does not mutate the array.\n  *\n  * @function getOldest\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Collection to be sorted.\n  * @param {string} key - The property name to sort by based on it's value.\n  * @returns {Object} - The newest object in the collection.\n  *\n  * @example\n  * getOldest([{id: 1}, {id: 0}], 'id');\n  * // => {id: 0}\n*/\nexport const getOldest = (collection, key = 'id') => {\n\treturn sortOldest(collection, key)[0];\n};\n\n","import { mapArray } from '../array/each';\n/**\n  * Returns an array of the plucked values from the object. Values are plucked in the order given by the array.\n  *\n  * @function pluckObject\n  * @category object\n  * @type {Function}\n  * @param {Object} value - Array used to determine what values to be plucked.\n  * @param {string|Array} pluckThese - Property name.\n  * @returns {Array} - An array of plucked values.\n  *\n  * @example\n  * pluckObject({a: 1, b:3}, ['a','b']);\n  * // => [1, 3]\n*/\nexport const pluckObject = (value, pluckThese) => {\n\treturn mapArray(pluckThese, (item) => {\n\t\treturn value[item];\n\t});\n};\n\n","const findIndexCache = (element, index, array, indexMatch, propertyName) => {\n\tif (element[propertyName] === indexMatch) {\n\t\treturn true;\n\t}\n};\n/**\n  * Finds an object in a collection by the given id and property name.\n  *\n  * @function findItem\n  * @type {Function}\n  * @category collection\n  * @param {Array} collection - Collection to be checked for an item.\n  * @param {number|string} id - The value to look for.\n  * @param {string} [propertyName = 'id'] - The name of the property to compare.\n  * @returns {Object} - The found object.\n  *\n  * @example\n  * findItem([{id: 1}, {id: 2}], 1);\n  * // => {id: 1}\n*/\nexport const findItem = (collection, id, propertyName = 'id') => {\n\tconst result = collection.find((element, index) => {\n\t\treturn findIndexCache(element, index, collection, id, propertyName);\n\t});\n\treturn (result === -1) ? false : result;\n};\n/**\n  * Finds an object in a collection by the given id and property name and returns the array index of the object.\n  *\n  * @function findIndex\n  * @type {Function}\n  * @category collection\n  * @param {Array} collection - Collection to be checked for an item.\n  * @param {number|string} id - The value to look for.\n  * @param {string} [propertyName = 'id'] - The name of the property to compare.\n  * @returns {number} - The index of the object.\n  *\n  * @example\n  * findIndex([{id: 1}, {id: 2}], 1);\n  * // => 0\n*/\nexport const findIndex = (collection, id, propertyName = 'id') => {\n\tconst result = collection.findIndex((element, index) => {\n\t\treturn findIndexCache(element, index, collection, id, propertyName);\n\t});\n\treturn (result === -1) ? false : result;\n};\n\n","import {\n\tcompactMapArray, eachArray, filterArray, mapArray, whileArray\n} from '../array/each';\nimport {\n\tcompactMapObject, eachObject, filterObject, mapObject, whileObject\n} from '../object/each';\nimport { hasValue, isArray, isFunction, isPlainObject } from '../internal/is';\nconst forEachWrap = (object, callback) => {\n\treturn object.forEach(callback);\n};\nconst generateCheckLoops = (arrayLoop, objectLoop) => {\n\treturn (source, iteratee, results) => {\n\t\tlet returned;\n\t\tif (!hasValue(source)) {\n\t\t\treturn;\n\t\t} else if (isArray(source)) {\n\t\t\treturned = arrayLoop;\n\t\t} else if (isPlainObject(source) || isFunction(source)) {\n\t\t\treturned = objectLoop;\n\t\t} else if (source.forEach) {\n\t\t\treturned = forEachWrap;\n\t\t} else {\n\t\t\treturned = objectLoop;\n\t\t}\n\t\treturn returned(source, iteratee, results);\n\t};\n};\n/**\n  * Iterates through the given object while the iteratee returns true.\n  *\n  * @function eachWhile\n  * @category utility\n  * @type {Function}\n  * @param {Object|Array|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling array, and array length.\n  * @returns {boolean} - Returns true if all values returned are true or false if one value returns false.\n  *\n  * @example\n  * eachWhile({a: false, b: true, c: true}, (item) => {\n  *  return item;\n  * });\n  * // => false\n*/\nexport const eachWhile = generateCheckLoops(whileArray, whileObject);\n/**\n  * Iterates through the given object.\n  *\n  * @function each\n  * @category utility\n  * @type {Function}\n  * @param {Array|Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @returns {Array|Object|Function} - The originally given object.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   each({a: 1, b: 2, c: 3}, (item) => {\n  *     tempList.push(item);\n  *   });\n  *   return assert(tempList, [1, 2, 3]);\n  * });\n  *\n  * @example\n  * each({a: 1, b: 2, c: 3}, (item) => {\n  *   console.log(item);\n  * });\n  * // => {a: 1, b: 2, c: 3}\n*/\nexport const each = generateCheckLoops(eachArray, eachObject);\n/**\n  * Iterates through the calling object and creates a new object of the same calling object's type with all elements that pass the test implemented by the iteratee.\n  *\n  * @function filter\n  * @category utility\n  * @type {Function}\n  * @param {Array|Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} - A new object of the same calling object's type.\n  *\n  * @example\n  * filter({a: false, b: true, c: true}, (item) => {\n  *   return item;\n  * });\n  * // => {b: true, c: true}\n*/\nexport const filter = generateCheckLoops(filterArray, filterObject);\n/**\n  * Iterates through the calling object and creates a new object based on the calling object's type with the results of the iteratee on every element in the calling object.\n  *\n  * @function map\n  * @category utility\n  * @type {Function}\n  * @param {Array|Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} - A new object of the same calling object's type.\n  *\n  * @example\n  * map({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const map = generateCheckLoops(mapArray, mapObject);\n/**\n  * Iterates through the calling object and creates a new object based on the calling object's type with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  *\n  * @function compactMap\n  * @category utility\n  * @type {Function}\n  * @param {Array|Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created map object and arguments unique to mapArray or mapObject depending on the object type.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Array|Object|Function} - A new object of the same calling object's type.\n  *\n  * @example\n  * compactMap({a: null, b: 2, c: 3}, (item) => {\n  *   return item;\n  * });\n  * // => {b: 2, c: 3}\n*/\nexport const compactMap = generateCheckLoops(compactMapArray, compactMapObject);\n\n","import { eachWhile } from '../utility/each';\n/**\n  * Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate returns falsey. The predicate is invoked with three arguments: (value, index|key, collection).\n  *\n  * @function every\n  * @category function\n  * @type {Function}\n  * @param {Array|Object} collection - The collection to iterate over.\n  * @param {Function} predicate - The function invoked per iteration.\n  * @returns {boolean} - Returns true if all elements pass the predicate check, else false.\n  *\n  * @example\n  * every([[], true, 1, null, 'string'], Boolean);\n  * // => false\n*/\nexport const every = eachWhile;\n\n","import { times } from '../array/times';\n/**\n  * Timer wrapper.\n  *\n  * @function timer\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {number} time - The time in milliseconds.\n  * @returns {Object} - Returns setTimeout ID.\n  *\n  * @example\n  * timer(() => {}, 100);\n  * // => 0\n*/\nexport const timer = (callable, time) => {\n\treturn setTimeout(callable, time);\n};\n/**\n  * Interval wrapper.\n  *\n  * @function interval\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {number} time - The time in milliseconds.\n  * @returns {Object} - Returns setInterval ID.\n  *\n  * @example\n  * interval(() => {}, 100);\n  * // => 0\n*/\nexport const interval = (callable, time) => {\n\treturn setInterval(callable, time);\n};\nconst generateClear = (callable, clearMethod) => {\n\treturn () => {\n\t\ttimes(0, callable(() => {}, 0), (index) => {\n\t\t\tclearMethod(index);\n\t\t});\n\t};\n};\n/**\n  * Clear all active timers.\n  *\n  * @function clearTimers\n  * @category function\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * clearTimers();\n  * // => undefined\n*/\nexport const clearTimers = generateClear(timer, clearTimeout);\n/**\n  * Clear all active intervals.\n  *\n  * @function clearIntervals\n  * @category function\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * clearIntervals();\n  * // => undefined\n*/\nexport const clearIntervals = generateClear(interval, clearInterval);\n/**\n  * Creates a debounced function that delays invoking callable until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounce function has a clear method to cancel the timer.\n  *\n  * @function debounce\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {number} time - The time in milliseconds.\n  * @returns {Function} - The debounced function.\n  *\n  * @example\n  * debounce(() => { console.log('debounced'); }, 0)();\n  * // 'debounced'\n*/\nexport const debounce = (callable, time) => {\n\tlet timeout = false;\n\tconst debounced = (...args) => {\n\t\tif (timeout !== false) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = timer(() => {\n\t\t\tcallable(...args);\n\t\t\ttimeout = false;\n\t\t}, time);\n\t};\n\tdebounced.clear = () => {\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = false;\n\t\t}\n\t};\n\treturn debounced;\n};\n/**\n  * Creates a throttled function that only invokes callable at most once per every wait milliseconds. The throttle function has a clear method to cancel the timer.\n  *\n  * @function throttle\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {number} time - The time in milliseconds.\n  * @returns {Function} - The throttled function.\n  *\n  * @example\n  * throttle(() => { console.log('throttle'); }, 0)();\n  * // 'throttle'\n*/\nexport const throttle = (callable, time) => {\n\tlet timeout = false;\n\tlet shouldThrottle;\n\tconst throttled = (...args) => {\n\t\tif (timeout) {\n\t\t\tshouldThrottle = true;\n\t\t\treturn;\n\t\t}\n\t\tcallable(...args);\n\t\ttimeout = timer(() => {\n\t\t\tif (shouldThrottle) {\n\t\t\t\tcallable(...args);\n\t\t\t}\n\t\t\ttimeout = false;\n\t\t}, time);\n\t};\n\tthrottled.clear = () => {\n\t\tclearTimeout(timeout);\n\t\ttimeout = false;\n\t};\n\treturn throttled;\n};\n\n","import { whileArray } from '../array/each';\nimport { keys } from '../internal/object';\n/**\n  * Checks to see if an object has all of the given property names.\n  *\n  * @function hasKeys\n  * @category object\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @param {Array} properties - Array of object keys.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * hasKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','Thor']);\n  * // => true\n  *\n  * @example\n  * hasKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy','Tom']);\n  * // => false\n*/\nexport const hasKeys = (object, properties) => {\n\tconst objectKeys = keys(object);\n\treturn whileArray(properties, (item) => {\n\t\treturn objectKeys.includes(item);\n\t});\n};\n/**\n  * Checks to see if an object has any of the given property names.\n  *\n  * @function hasAnyKeys\n  * @category object\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @param {Array} properties - Array of object keys.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * hasAnyKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Lucy', 'Tom']);\n  * // => true\n  * @example\n  * hasAnyKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: 'Bobo'}, ['Other', 'Tom']);\n  * // => false\n*/\nexport const hasAnyKeys = (object, properties) => {\n\tconst objectKeys = keys(object);\n\treturn Boolean(properties.find((item) => {\n\t\treturn objectKeys.includes(item);\n\t}));\n};\n\n","import { eachAsync } from '../array/eachAsync';\nimport { keys } from '../internal/object';\n/**\n  * Asynchronously iterates through the given object.\n  *\n  * @function eachObjectAsync\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, calling object, key count, and array of keys.\n  * @returns {Object|Function} - Returns source.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = {};\n  *   await eachObjectAsync({a: 1, b: 2, c: 3}, async (item, key) => {\n  *     tempList[key] = item;\n  *   });\n  *   return assert(tempList, {a: 1, b: 2, c: 3});\n  * });\n  *\n  * @example\n  * eachObjectAsync({a: 1, b: 2, c: 3}, (item) => {\n  *   console.log(item);\n  * });\n  * // => {a: 1, b: 2, c: 3}\n*/\nexport const eachObjectAsync = async (source, iteratee) => {\n\tconst objectKeys = keys(source);\n\tawait eachAsync(objectKeys, (key, index, array, propertyCount) => {\n\t\treturn iteratee(source[key], key, source, propertyCount, objectKeys);\n\t});\n\treturn source;\n};\n\n","const normalizeCase = /[-_]/g;\nconst spaceFirstLetter = / (.)/g;\n/**\n  * Converts a string and converts it entirely into uppercase.\n  *\n  * @function upperCase\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be converted into upper case.\n  * @returns {string} - Converted string in upper case.\n  *\n  * @example\n  * upperCase('upper case');\n  * // => 'UPPER CASE'\n*/\nexport const upperCase = (string) => {\n\treturn string.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toUpperCase();\n};\n/**\n  * Converts a string into Camel case format.\n  *\n  * @function camelCase\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be converted into Camel case.\n  * @returns {string} - Converted string in Camel case.\n  *\n  * @example\n  * camelCase('camel case');\n  * // => 'camelCase'\n*/\nexport const camelCase = (string) => {\n\treturn string.toLowerCase()\n\t\t.replace(spaceFirstLetter, (match) => {\n\t\t\treturn match.toUpperCase().replace(/ /g, '');\n\t\t});\n};\n/**\n  * Converts a string into Kebab case format.\n  *\n  * @function kebabCase\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be converted into Kebab case.\n  * @returns {string} - Converted string in Kebab case.\n  *\n  * @example\n  * kebabCase('kebab case');\n  * // => 'kebab-case'\n*/\nexport const kebabCase = (string) => {\n\treturn string.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toLowerCase()\n\t\t.replace(spaceFirstLetter, '-$1');\n};\n/**\n  * Converts a string into snake case format.\n  *\n  * @function snakeCase\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be converted into snake case.\n  * @returns {string} - Converted string in Snake case.\n  *\n  * @example\n  * snakeCase('snake case');\n  * // => 'snake_case'\n*/\nexport const snakeCase = (string) => {\n\treturn string.replace(normalizeCase, ' ')\n\t\t.trim()\n\t\t.toLowerCase()\n\t\t.replace(spaceFirstLetter, '_$1');\n};\n\n","const rawURLDecodeRegex = /%(?![\\da-f]{2})/gi;\nconst andRegex = /&/g;\nconst lessThanRegex = /</g;\nconst moreThanRegex = />/g;\nconst doubleQuoteRegex = /\"/g;\n/**\n  * Raw URL decoder.\n  *\n  * @function rawURLDecode\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} - Converted string into the decoded URI Component .\n  *\n  * @example\n  * rawURLDecode('Lucy%20saw%20diamonds%20in%20the%20sky.');\n  * // => 'Lucy saw diamonds in the sky.'\n*/\nexport const rawURLDecode = (string) => {\n\treturn decodeURIComponent(string.replace(rawURLDecodeRegex, () => {\n\t\treturn '%25';\n\t}));\n};\n/**\n  * Replaced sensitive characters with their matching html entity.\n  *\n  * @function htmlEntities\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} - Replaced string.\n  *\n  * @example\n  * htmlEntities(`<script>console.log('Lucy & diamonds.')</script>`);\n  * // => `&lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;`\n*/\nexport const htmlEntities = (string) => {\n\treturn string.replace(andRegex, '&amp;')\n\t\t.replace(lessThanRegex, '&lt;')\n\t\t.replace(moreThanRegex, '&gt;')\n\t\t.replace(doubleQuoteRegex, '&quot;');\n};\n/**\n  * Executes rawURLDecode followd by htmlEntities methods on a string.\n  *\n  * @function sanitize\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @returns {string} - Replaced string.\n  *\n  * @example\n  * sanitize(`<script>console.log('Lucy%20&%20diamonds.')</script>`);\n  * // => `&lt;script&gt;console.log('Lucy &amp; diamonds.')&lt;/script&gt;`\n*/\nexport const sanitize = (string) => {\n\treturn htmlEntities(rawURLDecode(string));\n};\n\n","const tokenizeRegEx = /\\S+/g;\nconst wordsRegEx = /\\w+/g;\n/**\n  * Break string by non-white space characters matches.\n  *\n  * @function tokenize\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array of words without white space characters.\n  *\n  * @example\n  * tokenize('I am Lucy!');\n  * // => [\"I\", \"am\", \"Lucy!\"]\n*/\nexport const tokenize = (string) => {\n\treturn string.match(tokenizeRegEx) || [];\n};\n/**\n  * Break string into word matches.\n  *\n  * @function words\n  * @type {Function}\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array of words with word characters only.\n  *\n  * @example\n  * words('I am Lucy!');\n  * // => [\"I\", \"am\", \"Lucy\"]\n*/\nexport const words = (string) => {\n\treturn string.match(wordsRegEx) || [];\n};\n\n","import { restString } from './range';\nconst spaceFirstLetter = / (.)/g;\n/**\n  * Returns the first letter capitalized.\n  *\n  * @function upperFirstLetter\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to extract first letter from.\n  * @returns {string} - An upper case letter.\n  *\n  * @example\n  * upperFirstLetter('upper');\n  * // => \"U\"\n*/\nexport const upperFirstLetter = (string) => {\n\treturn string[0].toUpperCase();\n};\n/**\n  * Capitalizes the first letter.\n  *\n  * @function upperFirst\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with first letter capitalized.\n  *\n  * @example\n  * upperFirst('upper');\n  * // => 'Upper'\n*/\nexport const upperFirst = (string) => {\n\treturn upperFirstLetter(string) + restString(string);\n};\n/**\n  * Capitalize all first letters.\n  *\n  * @function upperFirstAll\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with all first letters capitalized.\n  *\n  * @example\n  * upperFirstAll('Lucy is next up.');\n  * // => 'Lucy Is Next Up.'\n*/\nexport const upperFirstAll = (string) => {\n\treturn string.replace(spaceFirstLetter, (match) => {\n\t\treturn match.toUpperCase();\n\t});\n};\n/**\n  * Capitalize first letter and lower case the rest.\n  *\n  * @function upperFirstOnly\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with first letter capitalized.\n  *\n  * @example\n  * upperFirstOnly('LYSERGIC ACID DIETHYLAMIDE');\n  * // => 'Lysergic namespace diethylamide'\n*/\nexport const upperFirstOnly = (string) => {\n\treturn upperFirstLetter(string) + restString(string).toLowerCase();\n};\n/**\n  * Capitalize all first letters and lower case the rest.\n  *\n  * @function upperFirstOnlyAll\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be mutated.\n  * @returns {string} - String with all first letters capitalized.\n  *\n  * @example\n  * upperFirstOnlyAll('LYSERGIC ACID DIETHYLAMIDE');\n  * // => 'Lysergic Acid Diethylamide'\n*/\nexport const upperFirstOnlyAll = (string) => {\n\treturn upperFirstOnly(string.toLowerCase()).replace(spaceFirstLetter, (match) => {\n\t\treturn match.toUpperCase();\n\t});\n};\n\n","import { keys } from '../internal/object';\nimport { isArray, isPlainObject } from '../internal/is';\nexport const objectCreate = Object.create;\n/**\n  * Creates new object with deeply assigned values from another object.\n  *\n  * @function assignDeep\n  * @category utility\n  * @type {Function}\n  * @param {Object|Function|Class|Array} target - Object to be assigned new properties.\n  * @param {Object|Function|Class|Array} source - Object from which properties are extracted.\n  * @param {boolean} [mergeArrays = true] - Array from which items are assigned to the new object.\n  * @returns {Object} - Returns object with the newly assigned properties.\n  *\n  * @example\n  * assignDeep({a:1}, {b:2});\n  * // => {a:1, b:2}\n*/\nexport const assignDeep = (target, source, mergeArrays = false, indexArg, lengthArg, objectKeysArg) => {\n\tif (target) {\n\t\tif (objectKeysArg) {\n\t\t\tconst currentKey = objectKeysArg.pop();\n\t\t\tif (currentKey) {\n\t\t\t\tconst sourceItem = source[currentKey];\n\t\t\t\ttarget[currentKey] = assignDeep(target[currentKey], sourceItem, mergeArrays);\n\t\t\t} else if (!lengthArg) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tif (lengthArg) {\n\t\t\t\tlet index = indexArg || 0;\n\t\t\t\tindex++;\n\t\t\t\tif (index < lengthArg) {\n\t\t\t\t\treturn assignDeep(target, source, mergeArrays, index, lengthArg, objectKeysArg);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn assignDeep(target, source, mergeArrays, null, null, objectKeysArg);\n\t\t} else if (lengthArg) {\n\t\t\tif (indexArg < lengthArg) {\n\t\t\t\tlet index = indexArg || 0;\n\t\t\t\tconst sourceItem = source[index];\n\t\t\t\tif (sourceItem) {\n\t\t\t\t\tconst targetItem = target[index];\n\t\t\t\t\tif (mergeArrays) {\n\t\t\t\t\t\ttarget.push(assignDeep(targetItem, sourceItem, mergeArrays));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[index] = assignDeep(targetItem, sourceItem, mergeArrays);\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (index < lengthArg) {\n\t\t\t\t\t\treturn assignDeep(target, source, mergeArrays, index, lengthArg, objectKeysArg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isArray(source)) {\n\t\t\tif (lengthArg === 0) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\treturn assignDeep(target, source, mergeArrays, 0, source.length);\n\t\t} else if (isPlainObject(source)) {\n\t\t\tconst objectKeys = keys(source);\n\t\t\treturn assignDeep(target, source, mergeArrays, null, null, objectKeys);\n\t\t}\n\t} else if (isPlainObject(source)) {\n\t\tif (objectKeysArg) {\n\t\t\treturn assignDeep({}, source, mergeArrays, null, null, objectKeysArg);\n\t\t}\n\t\treturn assignDeep({}, source, mergeArrays);\n\t} else if (isArray(source)) {\n\t\tif (indexArg < lengthArg) {\n\t\t\treturn assignDeep([], source, mergeArrays, indexArg, lengthArg, objectKeysArg);\n\t\t}\n\t\treturn assignDeep([], source, mergeArrays);\n\t}\n\tif (!target) {\n\t\treturn source;\n\t}\n\treturn target;\n};\n/**\n  * Creates a deep clone of an object.\n  *\n  * @function assignDeep\n  * @category utility\n  * @type {Function}\n  * @param {Object} source - Source object to clone.\n  * @returns {Object} - Returns a deep clone of an object.\n  *\n  * @example\n  * clone({b:2})\n  * // => {a:1, b:2}\n*/\nconst structuredCloneSafe = globalThis.structuredClone;\nlet clone;\nif (structuredCloneSafe) {\n\tclone = (item) => {\n\t\treturn globalThis.structuredClone(item);\n\t};\n} else {\n\tclone = (item) => {\n\t\tif (isPlainObject(item)) {\n\t\t\treturn assignDeep({}, item);\n\t\t} else if (isArray(item)) {\n\t\t\treturn assignDeep([], item);\n\t\t}\n\t\treturn objectCreate(item);\n\t};\n}\nexport { clone };\n\n","const functionPrototype = Function.prototype;\n/**\n  * Caches a prototype method.\n  *\n  * @function cacheNativeMethod\n  * @category utility\n  * @type {Function}\n  * @param {Function} method - Prototype method.\n  * @returns {Function} - Cached method.\n  *\n  * @example\n  * cacheNativeMethod(Array.prototype.push)([], 1);\n  * // => 1\n*/\nexport function cacheNativeMethod(method) {\n\treturn functionPrototype.call.bind(method);\n}\n\n","import { hasValue } from '../internal/is';\n/**\n   * Checks if a property on an object has a value. If not, it will assign a value.\n   *\n   * @function ifNotEqual\n   * @category utility\n   * @type {Function}\n   * @param {Object} rootObject - The object to check.\n   * @param {string} property - The property name which is to be checked.\n   * @param {*} equalThis - The reassignment value for the property being checked.\n   * @returns {Object} - Returns the provided rootObject.\n   *\n   * @example\n   * ifNotEqual({}, 'a', 1);\n   * // => {a:1}\n */\nexport const ifNotEqual = (rootObject, property, equalThis) => {\n\tif (property && !hasValue(rootObject[property])) {\n\t\trootObject[property] = equalThis;\n\t}\n\treturn rootObject;\n};\n\n","import { hasKeys } from '../object/hasKeys.js';\nimport { whileArray } from '../array/each';\nimport { keys } from '../internal/object';\nimport { isArray, isPlainObject } from '../internal/is';\n/**\n   * Performs a deep comparison between two objects.\n   *\n   * @function isEqual\n   * @type {Function}\n   * @category utility\n   * @param {Object} source - Source object.\n   * @param {Object} compareObject - Object to compare to source.\n   * @returns {boolean} - Returns true or false.\n   *\n   * @example\n   * isEqual({a: [1,2,3]}, {a: [1,2,3]});\n   * // => true\n */\nexport const isEqual = (source, compareObject) => {\n\tif (source === compareObject) {\n\t\treturn true;\n\t} else if (source.toString() === compareObject.toString()) {\n\t\tif (isPlainObject(source)) {\n\t\t\tconst sourceProperties = keys(source);\n\t\t\tif (hasKeys(compareObject, sourceProperties)) {\n\t\t\t\treturn whileArray(sourceProperties, (key) => {\n\t\t\t\t\treturn isEqual(source[key], compareObject[key]);\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (isArray(source)) {\n\t\t\tif (source.length === compareObject.length) {\n\t\t\t\treturn whileArray(source, (item, index) => {\n\t\t\t\t\treturn isEqual(item, compareObject[index]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\n","const regexToPath = /\\.|\\[/;\nconst regexCloseBracket = /]/g;\nconst emptyString = '';\n/**\n  * Breaks up string into object chain list.\n  *\n  * @function toPath\n  * @type {Function}\n  * @category utility\n  * @param {string} string - String to be broken up.\n  * @returns {Array} - Array used to go through object chain.\n  *\n  * @example\n  * toPath('post.like[2]');\n  * // => ['post', 'like', '2']\n*/\nexport const toPath = (string) => {\n\treturn string.replace(regexCloseBracket, emptyString).split(regexToPath);\n};\n\n","import { hasValue } from '../internal/is';\nlet count = 0;\nconst uidFree = [];\nconst uidClosed = {};\n/**\n  * Creates a numerical unique ID and recycles old ones. UID numerically ascends however freed UIDs are later reused.\n  *\n  * @function uid\n  * @category utility\n  * @type {Function}\n  * @category utility\n  * @returns {number} - Returns a unique id.\n  *\n  * @test\n  * (async () => {\n  *   return await assert(uid(), 0) && await assert(uid(), 1);\n  * });\n  *\n  * @example\n  * uid();\n  * // => 0\n  * uid();\n  * // => 1\n*/\nexport function uid() {\n\tlet result = uidFree.shift(uidFree);\n\tif (!hasValue(result)) {\n\t\tresult = count;\n\t\tuidClosed[result] = true;\n\t\tcount++;\n\t}\n\treturn result;\n}\n/**\n  * Frees an UID so that it may be recycled for later use.\n  *\n  * @function uid.free\n  * @category utility\n  * @type {Function}\n  * @param {number} id - Number to be freed.\n  * @returns {undefined} - Nothing is returned.\n  *\n  * @test\n  * (async () => {\n  *   return await assert(uid(), 0) &&\n  *    await assert(uid(), 1) &&\n  *    await assert(uid.free(0), undefined) &&\n  *    await assert(uid(), 0);\n  * });\n  *\n  * @example\n  * uid();\n  * // => 0\n  * uid();\n  * // => 1\n  * uid.free(0);\n  * // => undefined\n  * uid();\n  * // => 0\n*/\nuid.free = (id) => {\n\tuidClosed[id] = null;\n\tuidFree.push(id);\n};\n\n","import { hasValue } from '../internal/is';\nimport { toPath } from '../utility/toPath';\nimport { whileArray } from '../array/each';\n/**\n  * Returns property on an object.\n  *\n  * @function get\n  * @category utility\n  * @type {Function}\n  * @param  {string} propertyString - String used to retrieve properties.\n  * @param {Object} objectChain - Object which has a property retrieved from it.\n  * @returns {Object} - Returns property from the given object.\n  *\n  * @example\n  * get('post.like[2]', {\n  *   post: {\n  *     like: ['a','b','c']\n  *   }\n  * });\n  * // => 'c'\n*/\nexport const get = (propertyString, objectChain) => {\n\tlet link = objectChain;\n\twhileArray(toPath(propertyString), (item) => {\n\t\tlink = link[item];\n\t\treturn hasValue(link);\n\t});\n\treturn link;\n};\n\n","import { get } from './get';\nimport { hasValue } from '../internal/is';\n/**\n  * Set & Get a model.\n  *\n  * @function model\n  * @type {Function}\n  * @category utility\n  * @param {string} modelName - Name of the model.\n  * @param {Object} modelObject - The model object.\n  * @returns {*} - Returns the associated model.\n  *\n  * @example\n  * model('test', {a: 1}) && model('test');\n  * // => {a: 1}\n*/\nexport const model = (modelName, modelObject) => {\n\tif (hasValue(modelObject)) {\n\t\tmodel[modelName] = modelObject;\n\t}\n\treturn get(modelName, model);\n};\n\n","import { eachArray, eachArrayRight } from '../array/each';\nconst returnFlow = (callable) => {\n\treturn (...methods) => {\n\t\treturn (arg) => {\n\t\t\tlet value = arg;\n\t\t\tcallable(methods, (item) => {\n\t\t\t\tvalue = item(value);\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n};\n/**\n  * Creates a function that returns the result of invoking the given functions, where each successive invocation is supplied the return value of the previous.\n  *\n  * @function flow\n  * @category utility\n  * @type {Function}\n  * @param {Array} collection - Methods to invoke.\n  * @returns {Function} - Returns the new composite function.\n  *\n  * @example\n  * flow(increment, increment, deduct)(0);\n  * // => 1\n*/\nexport const flow = returnFlow(eachArray);\n/**\n  * This method is like flow except that it creates a function that invokes the given functions from right to left.\n  *\n  * @function flowRight\n  * @category utility\n  * @type {Function}\n  * @param {Array} collection - Methods to invoke.\n  * @returns {Function} - Returns the new composite function.\n  *\n  * @example\n  * flowRight(increment, increment, deduct)(0);\n  * // => 1\n*/\nexport const flowRight = returnFlow(eachArrayRight);\n\n","import { eachAsync, eachAsyncRight } from '../array/eachAsync';\nconst returnFlow = (callable) => {\n\treturn (...methods) => {\n\t\treturn async (arg) => {\n\t\t\tlet value = arg;\n\t\t\tawait callable(methods, async (item) => {\n\t\t\t\tvalue = await item(value);\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n};\n/**\n  * Creates a function that returns the result of invoking the given functions, where each successive invocation is supplied the return value of the previous.\n  *\n  * @function flowAsync\n  * @category utility\n  * @type {Function}\n  * @async\n  * @param {Array} collection - Methods to invoke.\n  * @returns {Function} - Returns the new composite function.\n  *\n  * @example\n  * flowAsync(async (item) => {return increment(item);}, async (item) => {return increment(item);})(0);\n  * // => 2\n*/\nexport const flowAsync = returnFlow(eachAsync);\n/**\n  * This method is like flow except that it creates a function that invokes the given functions from right to left.\n  *\n  * @function flowAsyncRight\n  * @category utility\n  * @type {Function}\n  * @async\n  * @param {Array} collection - Methods to invoke.\n  * @returns {Function} - Returns the new composite function.\n  *\n  * @example\n  * flowAsyncRight(async (item) => {return increment(item);}, async (item) => {return increment(item);})(0);\n  * // => 2\n*/\nexport const flowAsyncRight = returnFlow(eachAsyncRight);\n\n","import { hasValue } from '../internal/is';\n/**\n  * Creates a function that is restricted to execute method once. Repeat calls to the function will return the value of the first call. The method is executed with the this binding of the created function.\n  *\n  * @function once\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be called.\n  * @returns {Function} - Returns the new pass-thru function.\n  *\n  * @test\n  * (async () => {\n  *   const onceOnly = once((item) => { return item;});\n  *   return await assert(onceOnly(5), 5) && await assert(onceOnly(2), 5);\n  * });\n  *\n  * @example\n  * const onceOnly = once((item) => { return item;});\n  * onceOnly(5);\n  * onceOnly(3);\n  * // => 5\n*/\nexport const once = (callable) => {\n\tlet value;\n\tconst onlyOnce = (...args) => {\n\t\tif (!hasValue(value)) {\n\t\t\tvalue = callable(...args);\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyOnce;\n};\n/**\n  * Creates a function that executes callable, only after being called n times.\n  *\n  * @function after\n  * @category function\n  * @type {Function}\n  * @param {number} amount - The number of calls until method is invoked.\n  * @param {Function} callable - The function to be called.\n  * @returns {Function} - Returns the new pass-thru function.\n  *\n  * @test\n  * (async () => {\n  *   const onlyAfter = after(2, (item) => { return item;});\n  *   return await assert(onlyAfter(1), undefined) && await assert(onlyAfter(2), 2);\n  * });\n  *\n  * @example\n  * const onlyAfter = after(1, (item) => { return item;});\n  * onlyAfter(1);\n  * // => undefined\n  * onlyAfter(2);\n  * // => 2\n*/\nexport const after = (amount, callable) => {\n\tlet point = amount;\n\tlet value;\n\tconst onlyAfter = (...args) => {\n\t\tif (point !== null) {\n\t\t\tpoint--;\n\t\t}\n\t\tif (point <= 0) {\n\t\t\tvalue = callable(...args);\n\t\t\tpoint = null;\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyAfter;\n};\n/**\n  * Creates a function that executes callable, only before n times.\n  *\n  * @function before\n  * @category function\n  * @type {Function}\n  * @param {number} amount - The number of calls before n.\n  * @param {Function} callable - The function to be called.\n  * @returns {Function} - Returns the new pass-thru function.\n  *\n  * @test\n  * (async () => {\n  *   const onlyBefore = before(3, (item) => { return item;});\n  *   return await assert(onlyBefore(1), 1) && await assert(onlyBefore(2), 2) && await assert(onlyBefore(3), 2);\n  * });\n  *\n  * @example\n  * const onlyBefore = before(3, () => { return 1;});\n  * onlyBefore(1);\n  * // => 1\n  * onlyBefore(2);\n  * // => 2\n  * onlyBefore(3);\n  * // => 2\n*/\nexport const before = (amount, callable) => {\n\tlet point = amount;\n\tlet value;\n\tconst onlyBefore = (...args) => {\n\t\tif (point !== null) {\n\t\t\tpoint--;\n\t\t}\n\t\tif (point >= 1) {\n\t\t\tvalue = callable(...args);\n\t\t} else {\n\t\t\tpoint = null;\n\t\t}\n\t\treturn value;\n\t};\n\treturn onlyBefore;\n};\n\n","import { eachArray } from './each';\n/**\n  * Takes all but the last item in the array.\n  *\n  * @function arrayToObject\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to have items extracted from.\n  * @param {Array} properties - Array to have items extracted from.\n  * @returns {Array} - Returns a completely flattened array.\n  *\n  * @example\n  * arrayToObject([1, 2, 3], ['i', 'love', 'lucy']);\n  * // => {i:1, love:2, lucy: 3}\n*/\nexport const arrayToObject = (values, properties) => {\n\tconst sortedObject = {};\n\teachArray(values, (item, key) => {\n\t\tsortedObject[properties[key]] = item;\n\t});\n\treturn sortedObject;\n};\n\n","/**\n  * Creates a function that invokes callable, with up to n arguments, ignoring any additional arguments.\n  *\n  * @function ary\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to cap arguments for.\n  * @param {number} amount - The arity cap.\n  * @returns {Object} - Returns the new capped function.\n  *\n  * @example\n  * ary((...args) => { return args;}, 2)(1, 2, 3);\n  * // => [1, 2]\n*/\nexport const ary = (callable, amount) => {\n\treturn (...args) => {\n\t\treturn callable(...args.splice(0, amount));\n\t};\n};\n\n","import { isFunction } from '../internal/is';\nimport { map } from '../utility/each';\n/**\n  * Loops through an object or an array and binds the given object to all functions encountered.\n  *\n  * @function bindAll\n  * @category function\n  * @type {Function}\n  * @param {Object|Function|Array} collection - The functions to bind.\n  * @param {*} bindThis - Object to be bound to functions.\n  * @returns {Object|Function|Array} - Returns the method invoked or undefined.\n  *\n  * @example\n  * bindAll([function () { return this;}], 'Lucy')[0]().toString();\n  * // => 'Lucy'\n  * @example\n  * bindAll({a() { return this;}}, 'Lucy').a().toString();\n  * // => 'Lucy'\n*/\nexport const bindAll = (collection, bindThis) => {\n\treturn map(collection, (item) => {\n\t\treturn isFunction(item) ? item.bind(bindThis) : item;\n\t});\n};\n\n","import { assign } from '../internal/object';\nimport { each } from '../utility/each';\nconst add = (link, methods) => {\n\teach(methods, (item, key) => {\n\t\tlink.methods[key] = (...args) => {\n\t\t\titem(link.value, ...args);\n\t\t\treturn link.methods;\n\t\t};\n\t});\n\treturn link;\n};\n/**\n  * Creates a chainable set of functions.\n  *\n  * @function chain\n  * @category function\n  * @type {Function}\n  * @param {Array|Object} methods - The object to take methods from.\n  * @returns {*} - Returns a function which has value, methods, add, and done. When invoking the function the argument is saved as the value property for further chaining.\n  *\n  * @test\n  * (async () => {\n  *   const chained = chain({a(item) { return item;}});\n  *   chained('Acid').a();\n  *   return assert(chained.done(), 'Acid');\n  * });\n  *\n  * @example\n  * const chained = chain({a(item) { return item;}});\n  * chained('Acid').a();\n  * chained.done();\n  * // => 'Acid'\n*/\nexport const chain = (methods) => {\n\tconst link = (value) => {\n\t\tlink.value = value;\n\t\treturn link.methods;\n\t};\n\tassign(link, {\n\t\tadd(addToChain) {\n\t\t\treturn add(link, addToChain);\n\t\t},\n\t\tdone() {\n\t\t\tconst value = link.value;\n\t\t\tlink.value = null;\n\t\t\treturn value;\n\t\t},\n\t\tmethods: {},\n\t});\n\tlink.add(methods);\n\treturn link;\n};\n\n","/**\n  * Chunks an array according to a user defined number.\n  *\n  * @function chunk\n  * @category Array\n  * @type {Function}\n  * @param {Array} array - Array to be chunked.\n  * @param {number} size - Number which determines the size of each chunk.\n  * @returns {Array} - A chunked version of the source array.\n  *\n  * @example\n  *  chunk([1,2,3], 1);\n  * // => [[1],[2],[3]]\n*/\nexport const chunk = (array, size = 1) => {\n\tconst chunked = [];\n\tlet index = 0;\n\tarray.forEach((item, key) => {\n\t\tif (!(key % size)) {\n\t\t\tchunked.push([]);\n\t\t\tif (key) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tchunked[index].push(item);\n\t});\n\treturn chunked;\n};\n\n","/**\n  * Clears the values out of an array.\n  *\n  * @function cloneArray\n  * @category Array\n  * @type {Function}\n  * @param {Array} array - Takes an array to be cloned.\n  * @returns {Array} - The originally given array.\n  *\n  * @example\n  * cloneArray([1,'B', 'Cat']);\n  * // => [1, 'B', 'Cat']\n*/\nexport const cloneArray = (array) => {\n\treturn array.slice();\n};\n\n","import { isString } from '../internal/is';\n/**\n  * Creates an array with all falsey values removed. The values false, null, 0, \"\", undefined, and NaN are falsey.\n  *\n  * @function compact\n  * @category Array\n  * @type {Function}\n  * @param {Array} array - Array to be compacted.\n  * @returns {Array} - The new array of filtered values.\n  *\n  * @example\n  * compact([1,'B', 'Cat', false, null, 0 , '', undefined, NaN]);\n  * // => [1, 'B', 'Cat']\n*/\nexport const compact = (array) => {\n\treturn array.filter((item) => {\n\t\treturn isString(item) && !item.length ? false : item;\n\t});\n};\n\n","import { eachObject } from '../object/each';\n/**\n  * Extracts all keys from an object whose values are not falsey. The values false, null, 0, \"\", undefined, and NaN are falsey.\n  *\n  * @function compactKeys\n  * @category object\n  * @type {Function}\n  * @param {Object} object - Object from which keys are extracted.\n  * @returns {Array} - Returns an array of key values.\n  *\n  * @test\n  * (async () => {\n  *   const results = compactKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: undefined, other: false, that: null});\n  *   return assert(results.includes('Lucy') && results.includes('John'), true);\n  * });\n  *\n  * @example\n  * compactKeys({Lucy: 'Ringo', John: 'Malkovich', Thor: undefined, other: false, that: null});\n  * // => ['Lucy', 'John']\n*/\nexport const compactKeys = (object) => {\n\tconst compactedKeys = [];\n\teachObject(object, (item, key) => {\n\t\tif (item) {\n\t\t\tcompactedKeys.push(key);\n\t\t}\n\t});\n\treturn compactedKeys;\n};\n\n","import { eachAsync } from './eachAsync';\nimport { hasValue } from '../internal/is';\n/**\n  * Asynchronously iterates through the calling array and creates an array with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling array.\n  *\n  * @function compactMapAsync\n  * @type {Function}\n  * @category array\n  * @async\n  * @param {Array} array - Array to be compacted.\n  * @param {Function} iteratee - Iteratee to be performed on array.\n  * @returns {Array} - Array values after being put through an iterator.\n  *\n  * @example\n  * compactMapAsync([1, 2, 3, null], async (item) => {return item;});\n  * // => [1, 2, 3]\n*/\nexport const compactMapAsync = async (array, iteratee) => {\n\tconst results = [];\n\tlet result;\n\tawait eachAsync(array, async (item, index, arrayLength) => {\n\t\tresult = await iteratee(item, index, results, arrayLength);\n\t\tif (hasValue(result)) {\n\t\t\tresults.push(result);\n\t\t}\n\t});\n\treturn results;\n};\n\n","import { eachObjectAsync } from './eachAsync';\nimport { hasValue } from '../internal/is';\n/**\n  * Asynchronously iterates through the calling object and creates an object with the results of the iteratee on every element in the calling object.\n  *\n  * @function mapObjectAsync\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} - An object of the same calling object's type.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = await mapObjectAsync({a: 1, b: 2, c: 3}, async (item, key) => {\n  *     return item;\n  *   });\n  *   return assert(tempList, {a: 1, b: 2, c: 3});\n  * });\n  *\n  * @example\n  * mapObjectAsync({a: 1, b: 2, c: 3}, (item) => {\n  *   return item * 2;\n  * });\n  * // => {a: 2, b: 4, c: 6}\n*/\nexport const mapObjectAsync = async (source, iteratee, results = {}) => {\n\tawait eachObjectAsync(source, async (item, key, thisObject, propertyCount, objectKeys) => {\n\t\tresults[key] = await iteratee(item, key, results, thisObject, propertyCount, objectKeys);\n\t});\n\treturn results;\n};\n/**\n  * Asynchronously iterates through the calling object and creates an object with the results, (excludes results which are null or undefined), of the iteratee on every element in the calling object.\n  *\n  * @function compactMapObjectAsync\n  * @category object\n  * @type {Function}\n  * @param {Object|Function} source - Object that will be looped through.\n  * @param {Function} iteratee - Transformation function which is passed item, key, the newly created object, calling object, key count, and array of keys.\n  * @param {Object|Function} [results = {}] - Object that will be used to assign results.\n  * @returns {Object|Function} - An object with mapped properties that are not null or undefined.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = await compactMapObjectAsync({a: 1, b: 2, c: 3}, async (item, key) => {\n  *     return item;\n  *   });\n  *   return assert(tempList, {a: 1, b: 2, c: 3});\n  * });\n  *\n  * @example\n  * compactMapObjectAsync({a: undefined, b: 2, c: 3}, (item) => {\n  *   return item;\n  * });\n  * // => {b: 2, c: 3}\n*/\nexport const compactMapObjectAsync = async (source, iteratee, results = {}) => {\n\tawait eachObjectAsync(source, async (item, key, thisObject, propertyCount, objectKeys) => {\n\t\tconst result = await iteratee(item, key, results, propertyCount, objectKeys);\n\t\tif (hasValue(result)) {\n\t\t\tresults[key] = result;\n\t\t}\n\t});\n\treturn results;\n};\n\n","import { eachArray } from '../array/each';\n/**\n  * Creates an object composed of keys generated from the results of running each element of collection through iteratee.\n  *\n  * @function countBy\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array of objects.\n  * @param {Function} iteratee - The iteratee to transform keys.\n  * @returns {Object} - Returns the composed aggregate object.\n  *\n  * @example\n  * countBy([{a:1}, {a:3}], (item) => { return 'a';});\n  * // => {a: 2}\n*/\nexport const countBy = (collection, iteratee) => {\n\tconst object = {};\n\tlet result;\n\teachArray(collection, (item) => {\n\t\tresult = iteratee(item);\n\t\tif (!object[result]) {\n\t\t\tobject[result] = 0;\n\t\t}\n\t\tobject[result]++;\n\t});\n\treturn object;\n};\n/**\n  * Count the amount of times a key is present in a collection.\n  *\n  * @function countKey\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array of objects.\n  * @param {Function} propertyName - The name of the key.\n  * @returns {number} - The count.\n  *\n  * @example\n  * countKey([{a:1}, {a:3}], 'a');\n  * // => 2\n*/\nexport const countKey = (collection, propertyName) => {\n\tlet count = 0;\n\teachArray(collection, (item) => {\n\t\tif (item[propertyName]) {\n\t\t\tcount++;\n\t\t}\n\t});\n\treturn count;\n};\n/**\n  * Count the amount of times a key is not present in a collection.\n  *\n  * @function countWithoutKey\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array of objects.\n  * @param {string} propertyName - The name of the key.\n  * @returns {number} - The count.\n  *\n  * @example\n  * countWithoutKey([{a:1}, {a:3}], 'b');\n  * // => 2\n*/\nexport const countWithoutKey = (collection, propertyName) => {\n\tlet count = 0;\n\teachArray(collection, (item) => {\n\t\tif (!item[propertyName]) {\n\t\t\tcount++;\n\t\t}\n\t});\n\treturn count;\n};\n\n","import { clear } from '../array/clear';\n/**\n  * Creates a function that accepts arguments of method and either invokes method returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining method arguments, and so on. The arity of method may be specified if method length is not sufficient.\n  *\n  * @function curry\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to curry.\n  * @param {number} arity - The arity of method.\n  * @returns {*} - Returns the new curried function.\n  *\n  * @example\n  * curry((a, b, c) => {\n  *   return [a, b, c];\n  * })(1)(2)(3);\n  * // => [1, 2, 3]\n*/\nexport const curry = (callable, arity = callable.length) => {\n\tconst curries = [];\n\tconst curried = (...curryArgs) => {\n\t\tcurries.push(...curryArgs);\n\t\tif (curries.length === arity) {\n\t\t\tconst result = callable(...curries);\n\t\t\tclear(curries);\n\t\t\treturn result;\n\t\t}\n\t\treturn curried;\n\t};\n\treturn curried;\n};\n/**\n  * Creates a function that accepts arguments of method and either invokes method returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining method arguments, and so on. The arity of method may be specified if method.length is not sufficient. The arguments are given in reverse order.\n  *\n  * @function curryRight\n  * @type {Function}\n  * @param {Function} callable - The function to curry.\n  * @param {number} arity - The arity of method.\n  * @returns {*} - Returns the new curried function.\n  *\n  * @example\n  * curryRight((a, b, c) => {\n  *   return [a, b, c];\n  * })(1)(2)(3);\n  * // => [3, 2, 1]\n*/\nexport const curryRight = (callable, arity = callable.length) => {\n\tconst curries = [];\n\tconst curried = (...curryArgs) => {\n\t\tcurries.unshift(...curryArgs);\n\t\tif (curries.length === arity) {\n\t\t\tconst result = callable(...curries);\n\t\t\tclear(curries);\n\t\t\treturn result;\n\t\t}\n\t\treturn curried;\n\t};\n\treturn curried;\n};\n\n","import { compactMapArray } from './each';\nimport { flattenDeep } from './flatten';\n/**\n  * Checks for differences between arrays, then creates an array based on those differences.\n  *\n  * @function difference\n  * @category array\n  * @type {Function}\n  * @param {Array} array - Source array.\n  * @param {Array} compare - Array source array is compared against.\n  * @returns {Array} - An array which contains the differences between the source and compare array.\n  *\n  * @example\n  * difference([1, 2, 3], [1, 2]);\n  * // => [3]\n*/\nexport const difference = (array, ...compares) => {\n\tconst compare = flattenDeep(compares);\n\treturn compactMapArray(array, (item) => {\n\t\tif (!compare.includes(item)) {\n\t\t\treturn item;\n\t\t}\n\t});\n};\n\n","/**\n  * Takes the first or multiple items from an array.\n  *\n  * @function first\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to extract from.\n  * @param {number} upTo - Number which determines how many items after the first item are extracted from the array.\n  * @returns {Array} - Returns an array.\n  *\n  * @example\n  * first([1, 2, 3]);\n  * // => 1\n  * @example\n  * first([1, 2, 3], 2);\n  * // => [1, 2]\n*/\nexport const first = (array, upTo) => {\n\treturn (upTo) ? array.slice(0, upTo) : array[0];\n};\n\n","import { eachArray } from '../array/each';\n/**\n  * Creates an object composed of keys generated from the results of running each element of collection thru iteratee.\n  * The order of grouped values is determined by the order they occur in collection.\n  * The corresponding value of each key is an array of elements responsible for generating the key.\n  *\n  * @function groupBy\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array of objects.\n  * @param {Function} iteratee - The iteratee to transform keys.\n  * @returns {Object} - Returns the composed aggregate object.\n  *\n  * @example\n  * groupBy([6.1, 4.2, 6.3], Math.floor);\n  * // => { '4': [4.2], '6': [6.1, 6.3] }\n*/\nexport const groupBy = (array, iteratee) => {\n\tconst sortedObject = {};\n\teachArray(array, (item) => {\n\t\tconst results = iteratee(item);\n\t\tif (!sortedObject[results]) {\n\t\t\tsortedObject[results] = [];\n\t\t}\n\t\tsortedObject[results].push(item);\n\t});\n\treturn sortedObject;\n};\n\n","import { isFunction } from '../internal/is';\n/**\n  * Checks if the given method is a function. If it is then it invokes it with the given arguments.\n  *\n  * @function ifInvoke\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked if possible.\n  * @param {...Array} args - Arguments to pass to the method.\n  * @returns {*} - Returns the method invoked or undefined.\n  *\n  * @example\n  * ifInvoke((...args) => { return args;}, 1, 2);\n  * // => [1, 2]\n  * @example\n  * ifInvoke(undefined, 1, 2);\n  * // => undefined\n*/\nexport const ifInvoke = (callable, ...args) => {\n\tif (isFunction(callable)) {\n\t\treturn callable(...args);\n\t}\n};\n\n","import { each } from '../utility/each';\nimport { eachAsync } from '../array/eachAsync';\n/**\n  * Invoke an array of functions.\n  *\n  * @function inSync\n  * @category function\n  * @type {Function}\n  * @param {Array|Object|Function} collection - The functions to be invoked.\n  * @param {*} value - The object passed as an argument to each method.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   inSync([() => {tempList.push(1);}, () => {tempList.push(2);}]);\n  *   return assert(tempList, [1, 2]);\n  * });\n  *\n  * @example\n  * inSync([() => {console.log(1);}, () => {console.log(2);}]);\n  * // 1\n  * // 2\n  * // => undefined\n*/\nexport const inSync = (collection, value) => {\n\treturn each(collection, (item) => {\n\t\titem(value);\n\t});\n};\n/**\n  * Invoke an array of functions asynchronously. Each function is awaited to ensure execution order.\n  *\n  * @function inAsync\n  * @category function\n  * @type {Function}\n  * @async\n  * @param {Array|Object|Function} collection - The functions to be invoked.\n  * @param {*} value - The object passed as an argument to each method.\n  * @returns {undefined} - Returns undefined.\n  *\n  * @test\n  * (async () => {\n  *   const tempList = [];\n  *   await inAsync([async () => {tempList.push(1);}, async () => {tempList.push(2);}]);\n  *   return assert(tempList, [1, 2]);\n  * });\n  *\n  * @example\n  * inAsync([async () => {console.log(1);}, async () => {console.log(2);}]);\n  * // 1\n  * // 2\n  * // => undefined\n*/\nexport const inAsync = async (collection, value) => {\n\treturn eachAsync(collection, async (item) => {\n\t\tawait item(value);\n\t});\n};\n\n","import { eachArray } from '../array/each';\n/**\n  * Given a list, and an iteratee function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know the keys are unique.\n  *\n  * @function indexBy\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array of objects.\n  * @param {string} propertyName - The property name to index by.\n  * @returns {Object} - Returns the composed aggregate object.\n  *\n  * @example\n  * indexBy([{name: 'Lucy', id: 0}, {name: 'Erick', id: 1}], 'id');\n  * // => { \"0\": {name: 'Lucy', id: 0}, \"1\": {name: 'Erick', id: 1}}\n*/\nexport const indexBy = (collection, propertyName = 'id') => {\n\tconst sortedObject = {};\n\teachArray(collection, (item) => {\n\t\tsortedObject[item[propertyName]] = item;\n\t});\n\treturn sortedObject;\n};\n\n","/**\n  * Takes all but the last item in the array.\n  *\n  * @function initial\n  * @category array\n  * @type {Function}\n  * @param {Array} array - Array to have items extracted from.\n  * @returns {Array} - Returns a completely flattened array.\n  *\n  * @example\n  * initial([1, 2, 3, 4, 5]);\n  * // => [1, 2, 3, 4]\n*/\nexport const initial = (array) => {\n\treturn array.slice(0, array.length - 1);\n};\n\n","import { compactMapArray, whileArray } from './each';\n/**\n * Returns an new array that is the [set intersection](http://en.wikipedia.org/wiki/Intersection_(set_theory))\n * of the array and the input array(s).\n *\n * @function intersect\n * @param {Array} array - Array to compare other arrays to.\n * @param {...Array} arrays - A variable number of arrays.\n * @category array\n * @returns {Array} - The new array of unique values shared by all of the arrays.\n *\n * @example\n * intersect([1, 2, 3], [2, 3, 4]);\n * // => [2, 3]\n * @example\n * intersect([1, 2, 3], [101, 2, 50, 1], [2, 1]);\n * // => [1, 2]\n */\nexport const intersect = (array, ...arrays) => {\n\treturn compactMapArray(array, (item) => {\n\t\tconst shouldReturn = whileArray(arrays, (otherItem) => {\n\t\t\treturn otherItem.includes(item);\n\t\t});\n\t\tif (shouldReturn) {\n\t\t\treturn item;\n\t\t}\n\t});\n};\n\n","import { eachObject } from './each';\n/**\n  * Creates an inverted version of a given object by switching it's keys and values.\n  *\n  * @function invert\n  * @type {Function}\n  * @category object\n  * @param {Object} thisObject - Object to be inverted.\n  * @param {Array} [invertedObject = {}] - Empty object to be populated with inverted values from thisObject.\n  * @returns {Object} - Returns object with keys and values switched.\n  *\n  * @example\n  * invert({a:1});\n  * // => {1:'a'}\n*/\nexport const invert = (thisObject, invertedObject = {}) => {\n\teachObject(thisObject, (item, key) => {\n\t\tinvertedObject[item] = key;\n\t});\n\treturn invertedObject;\n};\n\n","import { mapArray } from '../array/each';\n/**\n  * Invokes a function on the provided property name in each object in the collection.\n  *\n  * @function invoke\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Collection from which method will be taken.\n  * @param {string} property - Value used to pluck method from object.\n  * @param {*} value - Value to be passed to callable property.\n  * @returns {Array} - Returns the results of the invoked method.\n  *\n  * @example\n  * invoke([{lucy(item, index) { return [item, index];}}, {lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n  * // => [['EXAMPLE', 0], ['EXAMPLE', 1]]\n*/\nexport const invoke = (collection, property, value) => {\n\treturn mapArray(collection, (item, index) => {\n\t\treturn item[property](value, index);\n\t});\n};\n\n","import { mapAsync } from '../array/mapAsync';\n/**\n  * Asynchronously awaits & invokes a function on the provided property name in each object in the collection.\n  *\n  * @function invokeAsync\n  * @category collection\n  * @type {Function}\n  * @async\n  * @param {Array} collection - Collection from which method will be taken.\n  * @param {string} property - Value used to pluck method from object.\n  * @param {*} value - Value to be passed to callable property.\n  * @returns {Array} - Returns the results of the invoked method.\n  *\n  * @test\n  * (async () => {\n  *   const result = await invokeAsync([{async lucy(item, index) { return [item, index];}}, {async lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n  *   return assert(result, [['EXAMPLE', 0], ['EXAMPLE', 1]]);\n  * });\n  *\n  * @example\n  * invokeAsync([{async lucy(item, index) { return [item, index];}}, {async lucy(item, index) { return [item, index];}}], 'lucy', 'EXAMPLE');\n  * // => [['EXAMPLE', 0], ['EXAMPLE', 1]]\n*/\nexport const invokeAsync = (collection, property, value) => {\n\treturn mapAsync(collection, async (item, index) => {\n\t\treturn item[property](value, index);\n\t});\n};\n\n","import { hasValue } from '../internal/is';\n/**\n * Checks if value is a plain DOM Node.\n *\n * @function isDom\n * @category browser\n * @ignoreTest\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isDom(document.querySelectorAll('.test'));\n * // => true\n*/\nexport const isDom = (value) => {\n\treturn value && value.nodeType !== 9;\n};\n/**\n * Checks if the value is a HTMLCollection.\n *\n * @function isHTMLCollection\n * @category browser\n * @ignoreTest\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isHTMLCollection(document.getElementsByClassName('test'));\n * // => true\n*/\nconst objectHTMLCollection = '[object HTMLCollection]';\nexport function isHTMLCollection(source) {\n\treturn (hasValue(source)) ? source.toString() === objectHTMLCollection : false;\n}\n/**\n * Checks if the value is a NodeList.\n *\n * @function isNodeList\n * @category browser\n * @ignoreTest\n * @param {*} value - Object to be checked.\n * @returns {boolean} - Returns true or false.\n *\n * @example\n * isNodeList(document.querySelectorAll('.test'));\n * // => true\n*/\nconst objectNodeList = '[object NodeList]';\nexport function isNodeList(source) {\n\treturn (hasValue(source)) ? source.toString() === objectNodeList : false;\n}\n","/**\n  * Checks if the keycode of the event is strictly equal to 13.\n  *\n  * @function isEnter\n  * @category browser\n  * @type {Function}\n  * @param {Object} eventObject - Object to be checked.\n  * @returns {boolean} - Returns true if the keycode property of the object equals 13.\n  *\n  * @example\n  * isEnter('click');\n  * // => false\n*/\nexport const isEnter = (eventObject) => {\n\treturn eventObject.keyCode === 13;\n};\n\n","import { isMatchArray } from '../array/isMatch';\nimport { whileArray } from '../array/each';\nimport { keys } from '../internal/object';\n/**\n   * Performs a shallow strict comparison between two objects.\n   *\n   * @function isMatchObject\n   * @type {Function}\n   * @category object\n   * @param {Object} source - Source object.\n   * @param {Object} compareObject - Object to compare to source.\n   * @returns {boolean} - Returns true or false.\n   *\n   * @example\n   * isMatchObject({a: 1}, {a: 1});\n   * // => true\n */\nexport const isMatchObject = (source, compareObject) => {\n\tconst sourceProperties = keys(source);\n\tif (isMatchArray(sourceProperties, keys(compareObject))) {\n\t\treturn whileArray(sourceProperties, (key) => {\n\t\t\treturn source[key] === compareObject[key];\n\t\t});\n\t}\n\treturn false;\n};\n\n","/**\n  * Strictly checks if a number is zero.\n  *\n  * @function isZero\n  * @category number\n  * @type {Function}\n  * @param {number} item - Number to be checked.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * isZero(0);\n  * // => true\n  * @example\n  * isZero(1);\n  * // => false\n*/\nexport const isZero = (item) => {\n\treturn item === 0;\n};\n/**\n  * Strictly checks if a number equal to another number.\n  *\n  * @function isNumberEqual\n  * @category number\n  * @type {Function}\n  * @param {number} item - Number to be checked against num.\n  * @param {number} num - Number to be checked against item.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * isNumberEqual(0, 0);\n  * // => true\n  * @example\n  * isNumberEqual(0, 1);\n  * // => false\n*/\nexport const isNumberEqual = (item, num) => {\n\treturn item === num;\n};\n/**\n  * Checks if a number is within a range.\n  *\n  * @function isNumberInRange\n  * @category number\n  * @type {Function}\n  * @param {number} num - Number to be checked.\n  * @param {number} start - Beginning of range.\n  * @param {number} end - End of range.\n  * @returns {boolean} - Returns true or false.\n  *\n  * @example\n  * isNumberInRange(1, 0, 2);\n  * // => true\n  * @example\n  * isNumberInRange(1, -1, 0);\n  * // => false\n*/\nexport const isNumberInRange = (num, start, end) => {\n\treturn num > start && num < end;\n};\n\n","/**\n  * Extracts item(s) from an array starting from the last item in the array.\n  *\n  * @function last\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to have items extracted from.\n  * @param {number} [indexFrom = 0] - Value which determines how many items are extracted from the array.\n  * @returns {Array} - Items from the array.\n  *\n  * @example\n  * last([1, 2, 3, 4, 5] , 2);\n  * // => [4, 5]\n  * @example\n  * last([1, 2, 3, 4, 5]);\n  * // => 5\n*/\nexport const last = (array, indexFrom) => {\n\tconst arrayLength = array.length;\n\treturn (indexFrom) ? array.slice(arrayLength - indexFrom, arrayLength) : array[arrayLength - 1];\n};\n\n","/**\n  * Creates a function that negates the result of the predicate callable.\n  *\n  * @function negate\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @returns {*} - Returns the given methods result.\n  *\n  * @example\n  * negate(() => { return false;})();\n  * // => true\n*/\nexport const negate = (callable) => {\n\treturn (...args) => {\n\t\treturn !callable(...args);\n\t};\n};\n\n","/**\n  * This method returns a new empty object.\n  *\n  * @function stubObject\n  * @category function\n  * @type {Function}\n  * @returns {Object} - Returns the new empty object.\n  *\n  * @example\n  * stubObject();\n  * // => {}\n*/\nexport const stubObject = () => {\n\treturn {};\n};\n/**\n  * This method returns a new empty array.\n  *\n  * @function stubArray\n  * @category function\n  * @type {Function}\n  * @returns {Array} - Returns the new empty array.\n  *\n  * @example\n  * stubArray();\n  * // => []\n*/\nexport const stubArray = () => {\n\treturn [];\n};\n/**\n  * This method returns a new empty string.\n  *\n  * @function stubString\n  * @category function\n  * @type {Function}\n  * @returns {string} - Returns the new empty string.\n  *\n  * @example\n  * stubString();\n  * // => ''\n*/\nexport const stubString = () => {\n\treturn '';\n};\n/**\n  * This method returns false.\n  *\n  * @function stubFalse\n  * @category function\n  * @type {Function}\n  * @returns {boolean} - Returns false.\n  *\n  * @example\n  * stubFalse();\n  * // => false\n*/\nexport const stubFalse = () => {\n\treturn false;\n};\n/**\n  * This method returns true.\n  *\n  * @function stubTrue\n  * @category function\n  * @type {Function}\n  * @returns {boolean} - Returns true.\n  *\n  * @example\n  * stubTrue();\n  * // => true\n*/\nexport const stubTrue = () => {\n\treturn true;\n};\n/**\n  * This method returns undefined.\n  *\n  * @function noop\n  * @category function\n  * @type {Function}\n  * @returns {undefined} - Returns undefined.\n  *\n  * @example\n  * noop();\n  * // => undefined\n*/\nexport const noop = () => {\n\treturn undefined;\n};\n\n","/**\n  * Creates a function that gets the argument at index n. If n is negative, the nth argument from the end is returned.\n  *\n  * @function nthArg\n  * @category function\n  * @type {Function}\n  * @param {number} [index = 0] - The index of the argument to return.\n  * @returns {Function} - Returns the new pass-thru function.\n  *\n  * @example\n  * nthArg(1)('a', 'b');\n  * // => 'b'\n*/\nexport const nthArg = (index = 0) => {\n\treturn (...args) => {\n\t\treturn args[index];\n\t};\n};\n\n","import { filterObject } from './each';\n/**\n  * Returns a clone of the given object without the given properties.\n  *\n  * @function omit\n  * @category object\n  * @type {Function}\n  * @param {Object} originalObject - Object from which keys are extracted.\n  * @param {Array} array - Array of object keys.\n  * @returns {Object} - A new object with the removed.\n  *\n  * @example\n  * omit({a:1, b:2}, ['a']);\n  * // => {b:2}\n*/\nexport const omit = (originalObject, array) => {\n\treturn filterObject(originalObject, (item, key) => {\n\t\treturn !array.includes(key);\n\t});\n};\n\n","import { eachWhile, map } from '../utility/each';\n/**\n  * Creates a function that invokes iteratees with the arguments it receives and returns their results.\n  *\n  * @function over\n  * @category function\n  * @type {Function}\n  * @param {Array|Object} iteratees - The iteratees to invoke.\n  * @returns {Function} - Returns the new function.\n  *\n  * @example\n  * over([Math.max, Math.min])(1, 2, 3, 4);\n  * // => [4, 1]\n*/\nexport const over = (iteratees) => {\n\treturn (...args) => {\n\t\treturn map(iteratees, (item) => {\n\t\t\treturn item(...args);\n\t\t});\n\t};\n};\n/**\n  * Creates a function that checks if all of the predicates return truthy when invoked with the arguments it receives.\n  *\n  * @function overEvery\n  * @category function\n  * @type {Function}\n  * @param {Array|Object} predicates -  The predicates to check.\n  * @returns {Function} - Returns the new function.\n  *\n  * @example\n  * overEvery([Boolean, isFinite])('1');\n  * // => true\n  * @example\n  * overEvery([Boolean, isFinite])(null);\n  * // => false\n*/\nexport const overEvery = (predicates) => {\n\treturn (...args) => {\n\t\treturn eachWhile(predicates, (item) => {\n\t\t\treturn item(...args);\n\t\t});\n\t};\n};\n\n","import { compactMapArray } from './each';\n/**\n  * Split array into two arrays: one whose elements all satisfy predicate and one whose elements all do not satisfy predicate.\n  *\n  * @function partition\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Takes an array to split.\n  * @param {Function} funct - Function run on each item in array.\n  * @returns {Array} - One array split into two arrays.\n  *\n  * @example\n  * partition([\n  *  {user: 'barney', age: 36, active: false},\n  *  {user: 'fred', age: 40, active: true},\n  *  {user: 'pebbles', age: 1,  active: false}\n  * ], (item) => { return item.active; });\n  * // => [\n  * [{\"user\":\"fred\",\"age\":40,\"active\":true}],\n  *   [{\"user\":\"barney\",\"age\":36,\"active\":false},\n  *   {\"user\":\"pebbles\",\"age\":1,\"active\":false}]]\n*/\nexport const partition = (array, funct) => {\n\tconst failed = [];\n\treturn [\n\t\tcompactMapArray(array, (item) => {\n\t\t\tif (funct(item)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t\tfailed.push(item);\n\t\t}),\n\t\tfailed\n\t];\n};\n\n","import { eachArray } from '../array/each';\n/**\n  * Returns a clone of the source object with the plucked properties.\n  *\n  * @function pick\n  * @type {Function}\n  * @category object\n  * @param {Object} source - Object to be cloned.\n  * @param {Array} array - Array used to determine what values to be plucked.\n  * @param {Object} [newObject = {}] - Object to be populated with plucked values.\n  * @returns {Object} - A new object with plucked properties.\n  *\n  * @example\n  * pick({a:1, b:2, c:3}, ['a','b']);\n  * // => {a:1, b:2}\n*/\nexport const pick = (source, array, newObject = {}) => {\n\teachArray(array, (item) => {\n\t\tnewObject[item] = source[item];\n\t});\n\treturn newObject;\n};\n\n","import { mapArray } from '../array/each';\n/**\n  * Returns an array of the plucked values from the collection.\n  *\n  * @function pluck\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array used to determine what value to be plucked.\n  * @param {string} pluckThis - Property name.\n  * @returns {Array} - An array of plucked values.\n  *\n  * @example\n  * pluck([{lucy: 'Ants moving around on the walls.'}, {lucy: 'In the sky with diamonds.'}], 'lucy');\n  * // => ['Ants moving around on the walls.', 'In the sky with diamonds.']\n*/\nexport const pluck = (collection, pluckThis) => {\n\treturn mapArray(collection, (item) => {\n\t\tconst result = item[pluckThis];\n\t\treturn result;\n\t});\n};\n\n","import { mapArray } from '../array/each';\nimport { pluckObject } from '../object/pluckObject';\n/**\n  * Returns an array of the arrays of plucked values from the collection.\n  *\n  * @function pluckValues\n  * @category collection\n  * @type {Function}\n  * @param {Array} collection - Array used to determine what values to be plucked.\n  * @param {Array} pluckThese - Property names.\n  * @returns {Array} - An array of arrays of plucked values.\n  *\n  * @example\n  * pluckValues([{a: 1, b:3}, {a: 1, b:3}], ['a','b']);\n  * // => [[1, 3], [1, 3]]\n*/\nexport const pluckValues = (collection, pluckThese) => {\n\treturn mapArray(collection, (item) => {\n\t\treturn pluckObject(item, pluckThese);\n\t});\n};\n\n","import { isEqual } from './isEqual';\nimport { whileArray } from '../array/each';\nimport { keys } from '../internal/object';\n/**\n  * Using a deep comparison it checks if properties of two objects using an array are equal.\n  *\n  * @function propertyMatch\n  * @type {Function}\n  * @category utility\n  * @param {Object} source - The source object to compare.\n  * @param {Object} compared - Object to be compared to source.\n  * @param {Array} properties - List of properties to compare defaults to keys(source).\n  * @returns {Array} - Returns an array of properties.\n  *\n  * @example\n  * propertyMatch({\n  *   a: 1,\n  *   b: 2\n  * }, {\n  *   a: 1,\n  *   b: 2\n  * }, ['a', 'b']);\n  * // => true\n*/\nexport const propertyMatch = (source, compared, properties = keys(source)) => {\n\treturn whileArray(properties, (property) => {\n\t\treturn isEqual(source[property], compared[property]);\n\t});\n};\n\n","const rangeUp = (start, end, increment) => {\n\tconst rangeArray = [];\n\tlet position = start;\n\twhile (position < end) {\n\t\trangeArray.push(position);\n\t\tposition += increment;\n\t}\n\treturn rangeArray;\n};\nconst rangeDown = (start, end, incrementArg) => {\n\tconst increment = (incrementArg < 0) ? incrementArg * -1 : incrementArg;\n\tconst rangeArray = [];\n\tlet position = start;\n\twhile (position > end) {\n\t\trangeArray.push(position);\n\t\tposition -= increment;\n\t}\n\treturn rangeArray;\n};\n/**\n  * Create a numbered list of integers.\n  *\n  * @type {Function} range\n  * @category array\n  * @param {number} start - Value which determines the start of the range.\n  * @param {number} end - Value which determines the end of the range.\n  * @param {number} increment - Value used to step between integers.\n  * @returns {Array} - An array of integers.\n  *\n  * @example\n  * range(0, 30, 5);\n  * // => [0, 5, 10, 15, 20, 25]\n*/\nexport const range = (start, end, increment = 1) => {\n\tif (start < end) {\n\t\treturn rangeUp(start, end, increment);\n\t} else {\n\t\treturn rangeDown(start, end, increment);\n\t}\n};\n\n","/**\n  * Creates a function that invokes method with arguments arranged according to the specified indexes where the argument value at the first index is provided as the first argument, the argument value at the second index is provided as the second argument, and so on.\n  *\n  * @function reArg\n  * @category function\n  * @type {Function}\n  * @param {Function} callable - The function to be invoked.\n  * @param {Array} indexes - The arranged argument indexes.\n  * @returns {Function} - Returns the new function.\n  *\n  * @example\n  * reArg((a, b, c) => {\n  *   return [a, b, c];\n  * }, [1,2,0])(1,2,3);\n  * // => [2, 3, 1]\n*/\nexport const reArg = (callable, indexes) => {\n\treturn (...args) => {\n\t\treturn callable(...indexes.map((item) => {\n\t\t\treturn args[item];\n\t\t}));\n\t};\n};\n\n","/**\n  * Removes all occurrences of the passed in items from the array and returns the array. This mutates the given array. Clone the array if you desire to avoid mutation.\n  *\n  * @function remove\n  * @category array\n  * @param {Array} array - Array to be mutated.\n  * @param {string|Array} removeThese - Items to remove from the array.\n  * @returns {Array} - The array this method was called on.\n  *\n  * @example\n  * remove([1, 2, 3, 3, 4, 3, 5], 1);\n  * // => [2, 3, 3, 4, 3, 5]\n  * @example\n  * remove([3, 3, 4, 5], 3, 4);\n  * // => [5]\n*/\nexport const remove = (array, removeThese) => {\n\tlet arrayLength = array.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst item = array[index];\n\t\tif (removeThese.includes(item)) {\n\t\t\tarray.splice(index, 1);\n\t\t\tindex--;\n\t\t\tarrayLength--;\n\t\t}\n\t}\n\treturn array;\n};\n/**\n  * Removes items that pass the method's test. This mutates the given array. Clone the array if you desire to avoid mutation.\n  *\n  * @function removeBy\n  * @category array\n  * @param {Array} array - Array to be mutated.\n  * @param {Function} method - Function used to check object. Return true to remove the value.\n  * @returns {Array} - The array this method was called on.\n  *\n  * @example\n  * removeBy([1, 2, 3, 3, 4, 3, 5], (item) => { return Boolean(item % 2);});\n  * // => [2, 4]\n*/\nexport const removeBy = (array, iteratee) => {\n\tlet arrayLength = array.length;\n\tfor (let index = 0; index < arrayLength; index++) {\n\t\tconst item = array[index];\n\t\tif (iteratee(item, index)) {\n\t\t\tarray.splice(index, 1);\n\t\t\tindex--;\n\t\t\tarrayLength--;\n\t\t}\n\t}\n\treturn array;\n};\n\n","/**\n  * Replaces all occurrences of strings in an array with a value.\n  *\n  * @function replaceList\n  * @category string\n  * @type {Function}\n  * @param {string} string - String to be replaced.\n  * @param {Array} words - Strings to replace.\n  * @param {string} value - The match replacement.\n  * @returns {string} - The string with the replacement.\n  *\n  * @example\n  * replaceList('Her name was user.', ['user'], 'Lucy');\n  * // => 'Her name was Lucy.'\n*/\nexport const replaceList = (string, words, value) => {\n\treturn string.replace(new RegExp(`\\\\b${words.join('|')}\\\\b`, 'gi'), value);\n};\n\n","/**\n  * Extracts all items in array except the first and last item.\n  *\n  * @function rest\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to be sliced.\n  * @returns {Array} - Returns the aggregated array.\n  *\n  * @example\n  * rest([1, 2, 3, 4, 5]);\n  * // => [2, 3, 4, 5]\n*/\nexport const rest = (array) => {\n\treturn array.slice(1, array.length);\n};\n\n","/**\n  * Get the item at the supplied index starting at the end of the array.\n  *\n  * @function right\n  * @type {Function}\n  * @category array\n  * @param {Array} array - Array to be sliced.\n  * @returns {*} - Returns the object at the evaluated position.\n  *\n  * @example\n  * right([1, 2, 3, 4, 5] , 1);\n  * // => 4\n*/\nexport const right = (array, amount) => {\n\treturn array[array.length - 1 - amount];\n};\n\n","import { randomInt } from '../number/math';\nimport { shuffle } from './shuffle';\n/**\n  * Produce a random sample from the list. Pass a number to return n random elements from the list. Otherwise a single random item will be returned.\n  *\n  * @function sample\n  * @category array\n  * @param {Array} array - Array to pull sample(s).\n  * @returns {Array} - An array of randomly pulled samples.\n  *\n  * @test\n  * (async () => {\n  *   const tempResult = sample([1, 2] , 2);\n  *   return assert(tempResult.includes(1) && tempResult.includes(2), true);\n  * });\n  *\n  * @example\n  * sample([1, 2, 3, 4] , 2);\n  * // => [1, 3]\n*/\nexport const sample = (array, amount = 1) => {\n\tif (!array) {\n\t\treturn false;\n\t}\n\tconst arrayLength = array.length;\n\tif (arrayLength === amount || amount > arrayLength) {\n\t\treturn shuffle(array);\n\t}\n\tif (amount === 1) {\n\t\treturn [array[randomInt(arrayLength - 1, 0)]];\n\t}\n\tconst sampleArray = [];\n\tconst used = {};\n\tlet count = 0;\n\tlet index;\n\twhile (count < amount) {\n\t\tindex = randomInt(array.length - 1, 0);\n\t\tif (!used[index]) {\n\t\t\tsampleArray.push(array[index]);\n\t\t\tused[index] = true;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn sampleArray;\n};\n\n","/**\n   * Perform alphabetical sort on a collection with the provided key name. Mutates the array.\n   *\n   * @function sortAlphabetical\n   * @category collection\n   * @type {Function}\n   * @param {Array} collection - Collection to be sorted.\n   * @param {string} propertyName - Name of property to compare.\n   * @returns {Array} - The sorted array.\n   *\n   * @example\n   * sortAlphabetical([{letter:'a'}, {letter:'f'}, {letter:'c'}], 'letter');\n   * // => [{\"letter\":\"a\"},{\"letter\":\"c\"},{\"letter\":\"f\"}]\n */\nexport const sortAlphabetical = (collection, propertyName) => {\n\treturn collection.sort((current, next) => {\n\t\tconst currentKey = current[propertyName];\n\t\tconst nextKey = next[propertyName];\n\t\tif (currentKey < nextKey) {\n\t\t\treturn -1;\n\t\t} else if (currentKey > nextKey) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n};\n\n","import { whileArray } from './each';\n/**\n   * Uses a binary search to determine the index at which the value should be inserted into the list in order to maintain the list's sorted order.\n   *\n   * @function sortedIndex\n   * @category array\n   * @type {Function}\n   * @param {Array} array - Array to be sorted.\n   * @param {number} insertThis - Number to be inserted.\n   * @returns {number} - The index at which to insert.\n   *\n   * @example\n   * sortedIndex([30, 50], 40);\n   * // => 1\n */\nexport const sortedIndex = (array, insertThis) => {\n\tlet min = 0;\n\twhileArray(array, (item, index) => {\n\t\tmin = index;\n\t\tif (insertThis > item) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn min;\n};\n\n","/**\n  * Reduces the values in an array into a single number.\n  *\n  * @function sum\n  * @category array\n  * @type {Function}\n  * @param {Array} array - Array to be reduced.\n  * @returns {number} - Returns a single value.\n  *\n  * @example\n  * sum([1, 2, 3, 4]);\n  * // => 10\n*/\nexport const sum = (array) => {\n\treturn array.reduce((a, b) => {\n\t\treturn a + b;\n\t}, 0);\n};\n\n","/**\n  * Returns a shallow copy of the array up to an amount.\n  *\n  * @function take\n  * @category array\n  * @type {Function}\n  * @param {Array} source - The source array to take from.\n  * @param {Array} [end = 1] - Zero-based index before which to end extraction.\n  * @returns {Array} - The aggregated array.\n  *\n  * @example\n  * take([1,2,3], 2);\n  * // => [1, 2]\n*/\nexport const take = (source, end = 1) => {\n\treturn source.slice(0, end);\n};\n/**\n  * Returns a shallow copy of the array up to an amount starting from the right.\n  *\n  * @function takeRight\n  * @category array\n  * @type {Function}\n  * @param {Array} source - The source array to take right from.\n  * @param {Array} [end = 1] - Zero-based index before which to end extraction.\n  * @returns {Array} - The aggregated array.\n  *\n  * @example\n  * takeRight([1,2,3], 2);\n  * // => [2, 3]\n*/\nexport const takeRight = (source, amount = 1) => {\n\tconst arrayLength = source.length;\n\treturn source.slice(arrayLength - amount, arrayLength);\n};\n\n","import { isEqual } from './isEqual';\n/**\n  * Performs a toggle between 2 values using a deep or strict comparison.\n  *\n  * @function toggle\n  * @type {Function}\n  * @category utility\n  * @param  {(string|number|Object|Array)} value - Strictly compared against on & off arguments.\n  * @param {(string|number|Object|Array)} on -  The first object to be compared to.\n  * @param {(string|number|Object|Array)} off - The second object to be compared to.\n  * @returns {(string|number|Object|Array)} - The opposing value to the current.\n  *\n  * @example\n  * let toggleMe = true;\n  * toggleMe = toggle(toggleMe, true, false);\n  * // => false\n*/\nexport const toggle = (value, on = true, off = false) => {\n\treturn (isEqual(on, value)) ? off : on;\n};\n\n","const truncateDown = (string, maxLength, stringLength) => {\n\tconst breakAll = string.split('');\n\tconst breakAllLength = breakAll.length;\n\tlet item;\n\tlet index = stringLength - maxLength;\n\tfor (; index < breakAllLength && index >= 0; index--) {\n\t\titem = breakAll[index];\n\t\tif (item === ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string.slice(0, index).trim();\n};\nconst truncateUp = (string, maxLength, stringLength) => {\n\tconst breakAll = string.split('');\n\tconst breakAllLength = breakAll.length;\n\tlet item;\n\tlet index = maxLength;\n\tfor (; index < breakAllLength && index > 0; index++) {\n\t\titem = breakAll[index];\n\t\tif (item === ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string.substr(index, stringLength).trim();\n};\n/**\n  * Truncates the string, accounting for word placement and character count.\n  *\n  * @function truncate\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be truncated.\n  * @param {number} maxLength - The desired max length of the string.\n  * @returns {string} - The mutated string.\n  *\n  * @example\n  * truncate('Where is Lucy?', 2);\n  * // => 'Where is'\n*/\nexport const truncate = (string, maxLength) => {\n\tconst stringLength = string.length;\n\treturn (stringLength > maxLength) ? truncateDown(string, maxLength, stringLength) : string;\n};\n/**\n  * Truncates the string, accounting for word placement and character count from the right.\n  *\n  * @function truncateRight\n  * @type {Function}\n  * @category string\n  * @param {string} string - String to be truncated.\n  * @param {number} maxLength - The desired max length of the string.\n  * @returns {string} - The mutated string.\n  *\n  * @example\n  * truncateRight('Where is Lucy?', 6);\n  * // => 'Lucy?'\n*/\nexport const truncateRight = (string, maxLength) => {\n\tconst stringLength = string.length;\n\treturn (stringLength > maxLength) ? truncateUp(string, maxLength, stringLength) : string;\n};\n\n","/**\n  * Merges together the values of each of the arrays with the values at the corresponding position.\n  *\n  * @function zip\n  * @type {Function}\n  * @category array\n  * @param {Array} properties - The arrays to process.\n  * @returns {Array} - Returns the new array of regrouped elements.\n  *\n  * @example\n  * zip(['a', 'b'], [1, 2], [true, false]);\n  * // => [['a', 1, true], ['b', 2, false]]\n*/\nexport const zip = (...args) => {\n\treturn args[0].map((item, index) => {\n\t\treturn args.map((array) => {\n\t\t\treturn array[index];\n\t\t});\n\t});\n};\n/**\n  * Takes an array of grouped elements and creates an array regrouping the elements to their pre-zip array configuration.\n  *\n  * @function unZip\n  * @type {Function}\n  * @category array\n  * @param {Array} properties - The array of grouped elements to process.\n  * @returns {Array} - Returns the new array of regrouped elements.\n  *\n  * @example\n  * unZip([['a', 1, true], ['b', 2, false]]);\n  * // => [['a', 'b'], [1, 2], [true, false]]\n*/\nexport const unZip = (array) => {\n\treturn array[0].map((item, index) => {\n\t\treturn array.map((arraySet) => {\n\t\t\treturn arraySet[index];\n\t\t});\n\t});\n};\n\n","import { flattenDeep } from './flatten';\nimport { unique } from './unique';\n/**\n  * Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.\n  *\n  * @function union\n  * @category array\n  * @type {Function}\n  * @param {...Array} arrays - The arrays to be evaluated.\n  * @returns {Array} - The aggregated array.\n  *\n  * @example\n  * union([1,2,4], [1,2,3]);\n  * // => [1, 2, 4, 3]\n*/\nexport const union = (...arrays) => {\n\treturn unique(flattenDeep(arrays));\n};\n\n","/**\n  * Returns a copy of the array with all instances of the values removed.\n  *\n  * @function without\n  * @type {Function}\n  * @category array\n  * @param {Array} target - The target array to be filtered.\n  * @param {Array} removeThese - Items to be removed.\n  * @returns {Array} - The target array filtered.\n  *\n  * @example\n  * without([1, 2, 2, 4], [4]);\n  * // => [1, 2, 2]\n*/\nexport const without = (target, removeThese) => {\n\treturn target.filter((item) => {\n\t\treturn !removeThese.includes(item);\n\t});\n};\n\n","/**\n  * Creates a function that provides value to wrapper as its first argument. The wrapper function is given two arguments the value and the provided argument from the newly created function.\n  *\n  * @function wrap\n  * @category function\n  * @type {Function}\n  * @param {*} value - The value to wrap.\n  * @param {Function} wrapper - The wrapper function.\n  * @returns {Function} - The new function.\n  *\n  * @example\n  * wrap('Lucy', (firstName, lastName) => {\n  *  return `My name is ${firstName} ${lastName}.`;\n  * })('Diamonds');\n  * // => 'My name is Lucy Diamonds.'\n*/\nexport const wrap = (value, wrapper) => {\n\treturn (...arg) => {\n\t\treturn wrapper(value, ...arg);\n\t};\n};\n\n","import { eachArray } from './each';\nimport { unique } from './unique';\n/**\n  * Creates an array that is the symmetric difference of the provided arrays.\n  *\n  * @function xor\n  * @category array\n  * @type {Function}\n  * @param {Array} array - The array to be filtered.\n  * @param {Array} removeThese - Items to be removed.\n  * @returns {Array} - The filtered array.\n  *\n  * @example\n  * xor([2, 1], [2, 3]);\n  * // => [1, 3]\n*/\nexport const xor = (...arrays) => {\n\tconst xored = [];\n\teachArray(arrays, (array) => {\n\t\teachArray(unique(array), (item) => {\n\t\t\tif (xored.includes(item)) {\n\t\t\t\txored.splice(xored.indexOf(item), 1);\n\t\t\t} else {\n\t\t\t\txored.push(item);\n\t\t\t}\n\t\t});\n\t});\n\treturn xored;\n};\n\n"],"names":["toArray","Array","from","apply","Reflect","objectNative","Object","keys","is","assign","getOwnPropertyDescriptor","defineProperty","getOwnPropertyNames","objectSize","target","length","isUndefined","value","undefined","isNull","hasValue","isConstructor","nativeObject","obj","constructor","decimalCheck","isArray","isString","String","isNumber","Number","isPlainObject","toString","trim","slice","isFunction","Function","hasLength","Boolean","regexGenerator","regexType","item","test","isFileCSS","isFileJSON","isFileJS","isFileHTML","hasDot","getExtensionRegex","isBoolean","name","isPromise","Promise","isAsync","ensureArray","object","flattenDeep","arrayToFlatten","flat","Infinity","clear","array","mathNative","Math","floorMethod","floor","randomMethod","random","randomInt","max","min","shuffle","amount","shuffleArray","index","count","mathNativeMin","eachArray","source","iteratee","arrayLength","eachArrayRight","whileArray","filterArray","results","arrayOriginal","push","mapArray","callable","compactMapArray","returned","drop","upTo","splice","isMatchArray","compareArray","mathNativeMax","eachAsync","async","callingArray","eachAsyncRight","mapAsync","onlyUnique","indexOf","sortUnique","unique","isSorted","filter","numericalCompare","a","b","numericalCompareReverse","times","startIndex","endIndex","start","end","iterateeMethod","position","eachObject","objectKeys","key","original","propertyCount","whileObject","filterObject","mapObject","compactMapObject","result","isAgent","userAgent","globalThis","navigator","userAgentData","brands","brand","version","userAgentNormalized","toLowerCase","replace","userAgentSplit","split","eventAdd","node","args","addEventListener","createFragment","document","createDocumentFragment","bind","append","parentNode","child","appendChild","zipObject","properties","values","zipedObject","nodeAttribute","getAttribute","setAttribute","promise","callback","restString","string","substr","classTest","tagTest","regexSpace","getByClass","getElementsByClassName","getByTag","getElementsByTagName","getById","getElementById","querySelector","querySelectorAll","createTag","createElement","importjs","url","accept","reject","nodeAttachLoadingEvents","src","isDocumentReady","state","readyState","protocol","location","protocolSocket","hostname","info","hardware","cores","hardwareConcurrency","host","saveDimensions","bodyHeight","body","offsetHeight","bodyWidth","offsetWidth","windowHeight","window","innerHeight","windowWidth","innerWidth","updateDimensions","jsonNative","JSON","jsonParse","parse","stringify","VirtualStorage","initialObject","this","items","getItem","setItem","removeItem","virtualStorage","exports","hasLocal","storeCheck","e","hasStorage","localStorage","Crate","local","storage","generateTheme","color","bg","themes","alert","important","notify","warning","sortNewest","collection","propertyName","pureMode","sort","previous","next","sortOldest","pluckObject","pluckThese","findIndexCache","element","indexMatch","forEachWrap","forEach","generateCheckLoops","arrayLoop","objectLoop","eachWhile","each","map","compactMap","every","timer","time","setTimeout","interval","setInterval","generateClear","clearMethod","clearTimers","clearTimeout","clearIntervals","clearInterval","hasKeys","includes","eachObjectAsync","normalizeCase","spaceFirstLetter","rawURLDecodeRegex","andRegex","lessThanRegex","moreThanRegex","doubleQuoteRegex","rawURLDecode","decodeURIComponent","htmlEntities","tokenizeRegEx","wordsRegEx","upperFirstLetter","toUpperCase","upperFirstOnly","objectCreate","create","assignDeep","mergeArrays","indexArg","lengthArg","objectKeysArg","currentKey","pop","sourceItem","targetItem","structuredCloneSafe","structuredClone","clone","functionPrototype","prototype","isEqual","compareObject","sourceProperties","regexToPath","regexCloseBracket","toPath","uidFree","uidClosed","uid","shift","free","id","get","propertyString","objectChain","link","model","modelName","modelObject","returnFlow","methods","arg","flow","flowRight","flowAsync","flowAsyncRight","number","point","sortedObject","firstArgument","bindThis","method","call","match","add","addToChain","done","size","chunked","RegExp","themeName","data","console","trace","log","background","compactedKeys","thisObject","virtualFlag","arity","curries","curried","curryArgs","unshift","timeout","debounced","compares","compare","removeEventListener","findIndex","find","arrayArg","level","i","reduce","previousValue","currentValue","concat","search","rootObject","property","equalThis","text","arrays","otherItem","invertedObject","Date","nodeType","eventObject","keyCode","num","indexFrom","trueIndex","numberList","originalObject","iteratees","predicates","funct","failed","newObject","pluckThis","compared","increment","rangeArray","rangeUp","incrementArg","rangeDown","indexes","removeThese","words","join","sampleArray","used","select","current","nextKey","insertThis","shouldThrottle","throttled","on","off","maxLength","stringLength","breakAll","breakAllLength","truncateDown","truncateUp","arraySet","unZippedKeys","wrapper","xored"],"mappings":"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"}